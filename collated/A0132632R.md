# A0132632R
###### Tasker\src\application\gui\Cli.java
``` java
package application.gui;

import java.util.ArrayList;
import java.util.Scanner;
import application.storage.Task;

public class Cli implements Ui{
    private static final int FIRST_INDEX_FOR_USER = 1;
            
    private static final String MESSAGE_WELCOME = "Welcome to Tasker. "
            + "We'll make your life easy and organised!";
    private static final String MESSAGE_ASK_FOR_INPUT = "What would you like to do?: ";

    private Scanner inChannel;

    public Cli() {
        inChannel = new Scanner(System.in);
    }

    public void printWelcomeMessage(ArrayList<Task> tasks) {
        showToUser(MESSAGE_WELCOME, tasks);
    }

    public void showToUser(String message,ArrayList<Task> tasks){
        showLine(message);
        showList(tasks);
    }
    private void showLine(String message) {
        System.out.println(message);
    }
    
    private void showList(ArrayList<Task> tasks){
        int i = FIRST_INDEX_FOR_USER;
        for(Task task: tasks){
            showLine(i + ". " + task.toString());
            i++;
        }
    }

    public String getCommand() {
        askForCommand();
        String input = takeCommand();
        return input;
    }

    private String takeCommand() {
        String command = inChannel.nextLine();
        return command;
    }

    private void askForCommand() {
        System.out.print(MESSAGE_ASK_FOR_INPUT);
    }

    @Override
    public void showError(String message) {
        showLine(message);
    }


}
```
###### Tasker\src\application\gui\GuiP.java
``` java
package application.gui;

import java.util.ArrayList;
import java.util.List;

import javafx.application.Application;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class GuiP extends Application{
    private static final String WINDOW_TITLE = "Tasker"; 
    
    
    public static void main(String[] args){
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setTitle(WINDOW_TITLE);
        ListItem item = new ListItem(1, "HI" , "28 MAR" , "AT YALE-NUS");
        //modifyListItem(item);
        System.out.println("HEE");
        //hbox.setLabels(1, "Hello", "", "");
        OpeningPage page = new OpeningPage();
        //List<HBox> list = new ArrayList();
        //list.add(item);
        //ObservableList obsList = FXCollections.observableArrayList(list);
        //ListView<String> list2 = (ListView<String>) page.lookup("#displayList");
        //list2.setItems(obsList);
        //list.getItems().add(item);
        //page.getChildren().add(list);
        //page.getChildren().add(item);
        Scene scene = new Scene(page);
        primaryStage.setScene(scene);
        primaryStage.setTitle(WINDOW_TITLE);
        primaryStage.show();
    }

    private void modifyListItem(HBox item){
        Label taskNumber = (Label) item.lookup("#listNumber");
        taskNumber.setText("1");
        Label taskName = (Label) item.lookup("#taskName");
        taskName.setText("TENNIS IS AWESOME");
        Label date = (Label) item.lookup("#date");
        date.setText("28 MAR TO 30 MAR");
        Label location = (Label) item.lookup("#location");
        location.setText("AT COURTS");
    }
    
}
```
###### Tasker\src\application\gui\ListItem.java
``` java
package application.gui;

import java.io.IOException;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;

public class ListItem extends HBox {
	public static final String EMPTY = "";
	public static final String BACKGROUND_STYLE = "-fx-background-color: %1$s;";
	public static final String FONT_STYLE = "-fx-text-fill: %1$s;";
	public static final String RED = "#EF9A9A";
	public static final String GREEN = "#A5D6A7";
	public static final String BLUE = "#B2EBF2";
	public static final String DARK_RED = "#B71C1C";

	@FXML
	public Label listNumber;
	@FXML
	private Label taskName;
	@FXML
	private Label date;
	@FXML
	private Label taskLocation;

	public ListItem(int taskNumber, String name, String date, String location, String taskPriority, int overdueCheck) {
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("ListItem.fxml"));
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
			this.setLabels(taskNumber, name, date, location, taskPriority, overdueCheck);
		} catch (IOException exception) {
			System.out.println("Could not load");
			throw new RuntimeException(exception);
		}

	}

	private void setLabels(int taskNumber, String name, String date, String location, String taskPriority,
			int overdueCheck) {
		listNumber.setText(EMPTY + taskNumber);
		setBackground(taskPriority);
		taskName.setText(name.toUpperCase());
		this.date.setText(date.toUpperCase());
		setLocation(location.trim().toUpperCase());
		overdueCheck(overdueCheck);
	}

```
###### Tasker\src\application\gui\ListItem.java
``` java

	private void setLocation(String location) {
		if (!location.equals(EMPTY)) {
			this.taskLocation.setText(location);
		}
	}
}
```
###### Tasker\src\application\gui\OpeningPage.java
``` java
package application.gui;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javafx.scene.control.SelectionMode;

import application.logic.Feedback;
import application.logic.Logic;
import application.storage.Task;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.util.Callback;

public class OpeningPage extends AnchorPane {
	private static final String SPACE = " ";
	private static final String EMPTY_STRING = "";
	private static final String LOCATION_PREFIX = "AT";
	private static final String BY = "By ";
	private static final String BACKSLASH = "\\";
	private static final String DIRECTORY_CHOOSER_TITLE = "Pick Where To Store Tasks";
	private static final String CURRENT_DIRECTORY = "user.dir";
	private static final int TASK_NUM_OFFSET = 1;

	// Messages
	private static final String ADD_HINT_MESSAGE = "To add: [task description] from [start] to [end] at [location]";
	private static final String HELP_HINT_MESSAGE = "To get help: help";
	private static final String DELETE_HINT_MESSAGE = "To delete: delete [task description/number]";
	private static final String SEARCH_HINT_MESSAGE = "To search: search [task decription/priority [level]/[task description] by [date]]";
	private static final String EXIT_HINT_MESSAGE = "To exit: exit";
	private static final String UPDATE_HINT_MESSAGE = "To update: update [task number] [new task desc]";
	private static final String UNDO_HINT_MESSAGE = "To undo: undo";
	private static final String STORAGE_HINT_MESSAGE = "To change storage: storage";
	private static final String DONE_HINT_MESSAGE = "To mark task as complete: done [task number]";
	private static final String MESSAGE_STORAGE_URL_NOT_FOUND = "Storage Location Invalid: Opening Directory Chooser";
	private static final String MESSAGE_HELP_INTRO = "Start typing and we'll help you out!";
	private static final String MESSAGE_FEEDBACK_INTRO = "We'll give you feedback on your commands here.";

	private static final String MESSAGE_ERROR = "There was some problem processing your request. "
			+ "Please check your input format.";

	String text = EMPTY_STRING;
	private static ArrayList<String> commands = new ArrayList<String>();
	private static int pointer = 0;

	private ArrayList<Task> tasksOnScreen;
	private Logic logic;
	@FXML
	public Label feedbackLabel;
	@FXML
	private Label helpLabel;
	@FXML
	private TextField textInputArea;
	@FXML
	private ListView<Task> displayList;

	public OpeningPage(ArrayList<Task> taskList, Logic logic) {
		tasksOnScreen = taskList;
		this.logic = logic;
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("ListView.fxml"));
		loadFromFxml(fxmlLoader);
		initialize();
		initializeInputArea();
	}

	private void loadFromFxml(FXMLLoader fxmlLoader) {
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
		} catch (IOException exception) {
			System.out.println("Could not load");
			throw new RuntimeException(exception);
		}
	}
```
###### Tasker\src\application\gui\OpeningPage.java
``` java

	
	private void updateListView(ArrayList<Task> taskList) {
		ObservableList<Task> list = makeDisplayList(taskList);
		this.displayList.setItems(list);
//		if(){
//		displayList.scrollTo(taskList.get(0));}
	}

	private ObservableList<Task> makeDisplayList(ArrayList<Task> taskList) {
		ObservableList<Task> displayList = FXCollections.observableArrayList();
		for (Task task : taskList) {
			displayList.add(task);
		}
		return displayList;
	}

	private String getLocationString(Task task) {
		String location = task.getLocation();
		if (location.trim().equals(EMPTY_STRING)) {
			return EMPTY_STRING;
		} else {
			return (LOCATION_PREFIX + SPACE + location);
		}
	}
```
###### Tasker\src\application\gui\OpeningPage.java
``` java
	private String getFirstLetter(String input) {
		String firstLetter = input.substring(0, 1);
		return firstLetter;
	}

	private String getFirstWord(String input) {
		String[] inputArgs = input.trim().split(SPACE);
		String firstWord = inputArgs[0];
		return firstWord;
	}

	private String getSecondLetter(String input) {
		String secondLetter = input.substring(0, 2);
		return secondLetter;
	}

}
```
###### Tasker\src\application\gui\Ui.java
``` java
package application.gui;

import java.util.ArrayList;

import application.storage.Task;

public interface Ui {
    void showError(String message);
    void showToUser(String feedback, ArrayList<Task> tasks);
    void printWelcomeMessage(ArrayList<Task> tasks);
    String getCommand();
    
}
```
###### Tasker\src\application\logic\Add.java
``` java


package application.logic;

import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Storage;
import application.storage.Task;

import java.io.IOException;

public class Add implements UndoableCommand{
    public static final int NOT_FOUND = -1;
    public static final String EMPTY = "";
    private static final String MESSAGE_ADD_FEEDBACK= "Added Task: %1$s";
    private static final String MESSAGE_ADD_ERROR = 
            "We encountered an error while adding the task. Sorry for the inconvenience.";    
    
    private static final String MESSAGE_UNDO_FAILURE = "We encountered a problem while undoing.";
    private static final String MESSAGE_UNDO_FEEDBACK = "Unadded: %1$s";
    
    Task addedTask;
    StorageConnector storageConnector;
    
    String description = EMPTY;
    Calendar startDateTime;
    Calendar endDateTime;
    String location = EMPTY;
    Calendar remindDate;
    String priority = EMPTY;
    
    Add(String description, Calendar startDateTime, Calendar endDateTime, String location, Calendar remindDate, String priority) throws NoDescriptionException{
        this.description = description;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        this.remindDate = remindDate;
        this.priority = priority;
    }
    
   
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks){
        try{
            this.storageConnector = storageConnector;
            addedTask = storageConnector.addTaskInList(description, startDateTime
                    ,endDateTime, location, remindDate, priority);
            String feedbackMessage = String.format(MESSAGE_ADD_FEEDBACK, addedTask.toString());
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), addedTask);
        } catch(IOException e) {
            return getFeedbackCal(MESSAGE_ADD_ERROR, storageConnector.getOpenList(), null);
        }
    }
    
    public Feedback undo(){
        try {
            storageConnector.deleteTask(addedTask.getTaskIndex());
            String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK,addedTask.toString());
            return getFeedbackCal(feedbackMessage, storageConnector.getOpenList(), null);
        }catch(IOException e){
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }
    
    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
    
    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
    
    
    /*
    private String makeFeedback(){
        if (startDateTime.equals(EMPTY)){
            return String.format(MESSAGE_ADD_FEEDBACK_NO_START_DATE, description, endDateTime, location);
        } else {
            return String.format(MESSAGE_ADD_FEEDBACK_WITH_START_DATE, description, startDateTime, endDateTime, location);
        }
        
    }*/
}
```
###### Tasker\src\application\logic\Command.java
``` java

public interface Command {

    Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen);
    
}
```
###### Tasker\src\application\logic\DeleteByName.java
``` java

import java.io.IOException;
import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;

public class DeleteByName implements UndoableCommand {
    private static final int FIRST_INDEX = 0;
    private static final String FEEDBACK_DELETE = "Deleted Task: %1$s";
    private static final String MESSAGE_NOTHING_TO_DELETE = "There is no task with that description.";
    private static final String MESSAGE_WHICH_DELETE = "Which task would you like to delete?";
    private static final String MESSAGE_DELETE_ERROR = "We encountered some "
            + "problem while deleting this task. We apologise for the inconvenience.";
    private static final String MESSAGE_UNDO_FAILURE = "We encountered a problem while undoing.";
    private static final String MESSAGE_UNDO_FEEDBACK = "Re-added: %1$s";
    
    String taskToDelete;
    StorageConnector storageConnector;
    Task deletedTask;
    
    DeleteByName(String taskToDelete){
        this.taskToDelete = taskToDelete;
    }
     
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks){
        try{
            ArrayList<Task> taskList = storageConnector.searchTaskByName(taskToDelete);
            Feedback feedback = takeAction(taskList, storageConnector);
            return feedback;
        }catch(IOException e){
            Feedback feedback = new Feedback(MESSAGE_DELETE_ERROR, storageConnector.getOpenList(), null);
            feedback.setCalFlag();
            return feedback;
        }
    }
    
    public Feedback takeAction(ArrayList<Task> taskList, StorageConnector storageConnector) throws IOException{
        assert(taskList != null);
        this.storageConnector = storageConnector;
        if (taskList.size() ==  0){
            return getFeedbackCal(MESSAGE_NOTHING_TO_DELETE, storageConnector.getOpenList(), null);
            
        } else if (taskList.size() ==  1){
            deletedTask = storageConnector.deleteTask(taskList.get(FIRST_INDEX).getTaskIndex());
            String feedbackMessage = String.format(FEEDBACK_DELETE, deletedTask.toString());
            return getFeedbackCal(feedbackMessage, storageConnector.getOpenList(), null);
        } else {
            return getFeedbackList(MESSAGE_WHICH_DELETE, taskList,null);
        }
    }
    
    public Feedback undo() throws NothingToUndoException {
        try {
            if (deletedTask != null){
                storageConnector.addTaskInList(deletedTask.getTaskDescription(), deletedTask.getStartDate(),
                        deletedTask.getEndDate(),  deletedTask.getLocation(),  deletedTask.getRemindDate(),
                        deletedTask.getPriority());
                String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK,deletedTask.toString());
                return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), deletedTask);
            }else{
                throw new NothingToUndoException();
            }
        }catch(IOException e){
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
    
    
    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
    
    
    /*private String deleteSingleTask(ArrayList<Task> taskList, Storage storage) throws IOException {
        String feedback = String.format(FEEDBACK_DELETE, 
                taskList.get(FIRST_INDEX).getTaskDescription());
        storage.deleteTaskFromSearch(FIRST_INDEX);
        return feedback;
    }
    
    private String listTasks(ArrayList<Task> taskList){
        String listed = "Which task would you like to delete?";
        int i = 1;
        for (Task task: taskList){
            listed = listed + "\n" + i + ") " + task.getTaskDescription();
            i++;
        }
        return listed;
    }
    */
}
```
###### Tasker\src\application\logic\DeleteByNum.java
``` java

import java.io.IOException;
import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;

public class DeleteByNum implements UndoableCommand {
    private static final String MESSAGE_DELETE_FAILURE = "We encountered a problem while deleting this task.";
    private static final String MESSAGE_UNDO_FAILURE = "We encountered a problem while undoing.";
    private static final String MESSAGE_DELETE_FEEDBACK = "Deleted Task: %1$s";
    private static final String MESSAGE_UNDO_FEEDBACK = "Re-added: %1$s";
    private static final String MESSAGE_INDEX_PROBLEM = "Please enter a valid number.";
    
    Task deletedTask;
    int numToDelete;
    StorageConnector storageConnector;
    
    DeleteByNum(int numToDelete) {
        this.numToDelete = numToDelete;
    }
    
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks){
        this.storageConnector = storageConnector;
        try {
            int idOfTaskToDelete = tasks.get(numToDelete).getTaskIndex();
            deletedTask = storageConnector.deleteTask(idOfTaskToDelete);
            String feedbackMessage = String.format(MESSAGE_DELETE_FEEDBACK,deletedTask.toString());
            Feedback feedback = new Feedback(feedbackMessage, storageConnector.getOpenList(), null);
            feedback.setCalFlag();
            return feedback;
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_DELETE_FAILURE, storageConnector.getOpenList(), null);
        } catch (IndexOutOfBoundsException e) {
            return getFeedbackCal(MESSAGE_INDEX_PROBLEM, storageConnector.getOpenList(), null);
        }
    }
    
    public Feedback undo(){
        try {
            storageConnector.addTaskInList(deletedTask.getTaskDescription(), deletedTask.getStartDate(),
            deletedTask.getEndDate(),  deletedTask.getLocation(),  deletedTask.getRemindDate(),
            deletedTask.getPriority());
            String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK,deletedTask.toString());
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), deletedTask);
        }catch(IOException e){
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }
    
    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
    
    
    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
   
}
```
###### Tasker\src\application\logic\DoneByName.java
``` java

    
    public Feedback undo() throws NothingToUndoException{
        try {
            if (closedTask != null){
                storageConnector.uncloseTask(closedTask.getTaskIndex());
                String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK,closedTask.toString());
                return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), closedTask);
            }else{
                throw new NothingToUndoException();
            }
        }catch(IOException e){
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }
    
```
###### Tasker\src\application\logic\DoneByName.java
``` java

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
}

```
###### Tasker\src\application\logic\DoneByNum.java
``` java

    
    public Feedback undo() throws NothingToUndoException{
        try {
            storageConnector.uncloseTask(closedTask.getTaskIndex());
            String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK,closedTask.toString());
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), closedTask);
        }catch(IOException e){
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

```
###### Tasker\src\application\logic\DoneByNum.java
``` java

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
    
    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
    
}
```
###### Tasker\src\application\logic\Feedback.java
``` java

import java.util.ArrayList;
import java.util.logging.Logger;

import application.gui.Ui;
import application.storage.Task;



public class Feedback {
    private static final String LOGGER_NAME = "logfile";
    private static final String LIST_FLAG = "list";
    private static final String CAL_FLAG = "cal";
    private static final String HELP_FLAG = "help";
    private static final String STORAGE_FLAG = "storage";

    private String flag; 
    private Task taskToScroll;
    private String feedbackMessage;
    private ArrayList<Task> tasksToDisplay;
    private static Logger logger = Logger.getLogger(LOGGER_NAME);
    
    Feedback(String message, ArrayList<Task> tasks, Task taskToScroll){
        this.feedbackMessage = message;
        this.tasksToDisplay = tasks;
        this.taskToScroll = taskToScroll;
    }
    
    public void setListFlag(){
        flag = LIST_FLAG;
    }
    

    public void setCalFlag(){
        flag = CAL_FLAG;
    }
    

    public void setHelpFlag(){
        flag = HELP_FLAG;
    }

    public void setStorageFlag(){
        flag = STORAGE_FLAG;
    }
    public void display(Ui ui){
        logger.info("feedback object using ui to display itself to user");
        ui.showToUser(feedbackMessage, tasksToDisplay);
    }
    
    public ArrayList<Task> getTasks(){
    	return this.tasksToDisplay;
    }
    
    public String getFlag(){
        return flag;
    }
    
    public Task getIndexToScroll(){
        return taskToScroll;
    }
    
    public String getMessage(){
    	return this.feedbackMessage;
    }
  
}
```
###### Tasker\src\application\logic\History.java
``` java

import java.util.Stack;

public class History {

    private Stack<UndoableCommand> executedCommands;
        private static History instance;
    
    private History(){
        this.executedCommands = new Stack<UndoableCommand>();
    }
    
    public static History getInstance(){
        if (instance == null){
            instance = new History();
        }
        return instance;
    }
    
    
    
    public void add(Command cmd){
        if(cmd instanceof UndoableCommand){
            UndoableCommand cmd_undoable = (UndoableCommand) cmd;
            executedCommands.add(cmd_undoable);
        }
    }
    
    public Feedback undo(){
        try{
            UndoableCommand cmd = executedCommands.pop();
            Feedback feedback = cmd.undo();
            return feedback;
        } catch (NothingToUndoException e){
            return undo();
        }
    }
    
    
    
}
```
###### Tasker\src\application\logic\Home.java
``` java

import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;

public class Home implements Command{

    private static final String MESSAGE_BACK_HOME = "You are back home!";
    
    @Override
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
        return getFeedbackCal(MESSAGE_BACK_HOME, storageConnector.getOpenList(), null);
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
}
```
###### Tasker\src\application\logic\ListDisplay.java
``` java

import java.util.ArrayList;

import application.storage.Task;

public class ListDisplay implements Command {

    private static final String MESSAGE_LIST = "Here are your tasks.";
    
    @Override
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
        Feedback feedback = new Feedback(MESSAGE_LIST, storageConnector.getOpenList(),null);
        feedback.setListFlag();
        return feedback;
    }

}
```
###### Tasker\src\application\logic\Logic.java
``` java

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.FileHandler;
import java.util.logging.Logger;

import application.gui.Cli;
import application.gui.Ui;
import application.logger.LoggerFormat;
import application.storage.Storage;
import application.storage.Task;



public class Logic {

    private static final String MESSAGE_LOAD_ERROR = "There was some problem loading the app. "
            + "Please restart. We regret the inconvenience.";
    private static final String MESSAGE_ERROR = "There was some problem processing your request. "
            + "Please check your input format.";
    private static final String MESSAGE_NO_DESCRIPTION = "You must enter a task description.";
    private static final String LOGGER_NAME = "logfile";
    

	private Parser parser = new Parser();
	private StorageConnector storageConnector = new StorageConnector();
	//private Ui ui;
	private static Logger logger = Logger.getLogger(LOGGER_NAME);
	//private GUI guiHandler = new GUI();
	private History history = History.getInstance();
	private ArrayList<Task> tasksOnScreen;
	/*
	public static void main(String[] args) throws IOException{
	    initializeLogger();
	    logger.info("Initialising Logic");
        Logic tasker = new Logic();
	    try{
	        logger.info("Setting Environment");
            tasker.tasksOnScreen = tasker.setEnvironment();
            logger.info("Printing welcome message.");
            tasker.ui.printWelcomeMessage(tasker.tasksOnScreen);
            logger.info("Starting execution loop");
            tasker.executeCommandsUntilExit();
	    }catch(IOException e){
	        logger.info("Printing file input output error.");
	        tasker.ui.showError(MESSAGE_LOAD_ERROR);
        }
	}

    private static void initializeLogger() throws IOException {
        FileHandler fileHandler = new FileHandler("logfile.txt", true);
        LoggerFormat formatter = new LoggerFormat();
	    fileHandler.setFormatter(formatter);
	    logger.setUseParentHandlers(false);
	    logger.addHandler(fileHandler);
    }
	
	private void executeCommandsUntilExit(){
	    while(true){
	        try{
	            logger.info("Getting command from user");
	            String userCommand = ui.getCommand();
	            logger.info("Parsing command: " + userCommand);
	            Command cmd = parser.interpretCommand(userCommand);
	            logger.info("executing above parsed command");
                Feedback feedback = cmd.execute(storageConnector, tasksOnScreen);
                logger.info("displaying feedback");
                history.add(cmd);
                tasksOnScreen = feedback.getTasks();
                feedback.display(ui);
                //storage.saveFile();
	        }catch(NoDescriptionException e){
	            ui.showError(MESSAGE_NO_DESCRIPTION);
	        }catch(Exception e){
                ui.showError(MESSAGE_ERROR);
            }
	    }
	}

	*/
	private ArrayList<Task> setEnvironment() throws IOException{
	    logger.info("Checking if file exists");
	    checkIfFileExists();
	    logger.info("Loading tasks");
        return loadDataFile();
    }
/*
	public void startDirectoryPrompt(String file) throws IOException {
		storageConnector.setDirectory(file);
		loadDataFile();
	}
*/

```
###### Tasker\src\application\logic\LogicFacade.java
``` java

import java.io.IOException;
import java.util.ArrayList;

import application.storage.Task;

public class LogicFacade {
    private Logic logic = new Logic();
    
    public boolean checkIfFileExists() throws IOException{
        return logic.checkIfFileExists();
    }
    
    public ArrayList<Task> loadDataFile() throws IOException{
        return logic.loadDataFile();
    }
    
    public void setDirectory(String filePath) throws IOException{
        logic.setDirectory(filePath);
    }
    
    public Feedback executeCommand(String command,  ArrayList<Task> tasksOnScreen)throws NoDescriptionException {
        return logic.executeCommand(command, tasksOnScreen);
    }
}
```
###### Tasker\src\application\logic\NoDescriptionException.java
``` java


public class NoDescriptionException extends Exception {

    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public NoDescriptionException() {
        super();
    }
}
```
###### Tasker\src\application\logic\NotDateException.java
``` java

public class NotDateException extends Exception{

    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public NotDateException() {
        super();
    }
    
}
```
###### Tasker\src\application\logic\NothingToUndoException.java
``` java

public class NothingToUndoException extends Exception {

    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public NothingToUndoException() {
        super();
    }
}
```
###### Tasker\src\application\logic\Parser.java
``` java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;

import org.apache.commons.lang.ArrayUtils;
import org.joda.time.LocalDateTime;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;
import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Collections;

/**
 * This is the class which takes in a userInput and interprets it. If user input
 * is not erroneous, it returns a command object which contains all the
 * information of the user input and also holds information on how to carry out
 * the request of the user.
 * 
 * @author Pratyush
 *
 */

```
###### Tasker\src\application\logic\Parser.java
``` java



public class Parser {
	private static final String LOGGER_NAME = "logfile";
	private static final String MESSAGE_NULL_ERROR = "command cannot be null";
	private static final String KEYWORD_ADD = "add";
	private static final String KEYWORD_SEARCH = "search";
	private static final String KEYWORD_HOME = "home";
	private static final String KEYWORD_DELETE = "delete";
	private static final String KEYWORD_UPDATE = "update";
	private static final String KEYWORD_DONE = "done";
	private static final String KEYWORD_UNDO = "undo";
	private static final String KEYWORD_HELP = "help";
	private static final String KEYWORD_LIST_DISPLAY = "list";
    private static final String KEYWORD_STORAGE = "storage";
	private static final String KEYWORD_EXIT = "exit";
	private static final String EMPTY = "";

    private static final String[] DATE_MARKERS_START = {"from"};
    private static final String[] DATE_MARKERS_END = {"to", "till"};
    private static final String[] DATE_MARKERS_DEADLINE = {"by"};
	private static final String[] DATE_MARKERS_FULL_DAY_EVENT = {"on"};
	private static final String[] DATE_MARKERS_REMIND = {"remind"};
	private static final String[] LOCATION_MARKERS = {"at", "in"};
	private static final String[] PRIORITY_MARKERS = {"priority"};
    
	private static final String PRIORITY_HIGH = "high";
    private static final String PRIORITY_MEDIUM = "medium";
    private static final String PRIORITY_LOW = "low";
    private static final String[] PRIORITY_LEVELS = {PRIORITY_HIGH,PRIORITY_MEDIUM,PRIORITY_LOW};
    
    public static final int DEFAULT_EVENT_DURATION = 2;
    private static final int ARGUMENT_NUMBER = 4;
	private static final int DESC_POS = 0;
	private static final int DATE_POS = 1;
	private static final int LOC_POS = 2;
	private static final int PRI_POS = 3;
    private static final int ARRAY_INDEXING_OFFSET = 1;

	private static final boolean WITH_KEYWORD = true; // For add function. Since
														// we accept no keyword.

	private static Logger logger = Logger.getLogger(LOGGER_NAME);

	private PrettyTimeParser dateParser = new PrettyTimeParser();

	public Parser(){
	    dateParser.parse("2 hours before midnight day after tomorrow");
	}
	
	public Command interpretCommand(String userCommand)
			throws NoDescriptionException /* throws Exception */ {
		logger.info("Checking for error in user command: " + userCommand);
		checkForError(userCommand);
		logger.info("Splitting command into array of its words");
		String[] inputArgs = userCommand.trim().split("\\s+");
		logger.info("Getting command key word");
		String commandKeyword = inputArgs[0]; // Always going to be zero so
												// inputing magic number for now
		logger.info("Converting to command object: " + commandKeyword);
		Command command = convertToCommand(commandKeyword, inputArgs);
		logger.info("Returning command object");
		return command;
	}

	public Command convertToCommand(String keyword, String[] args) throws NoDescriptionException {
		Command command;

		switch (keyword.toLowerCase()) {
		case KEYWORD_ADD:
			logger.info("Making add command object");
			command = initializeAdd(args, WITH_KEYWORD);
			break;

		case KEYWORD_SEARCH:
			logger.info("Making search command object");
			command = initializeSearch(args);
			break;

		case KEYWORD_HOME:
			command = processHomeInput(args);
			break;

		case KEYWORD_LIST_DISPLAY:
            command = processListInput(args);
            break;

			
		case KEYWORD_DELETE:
			logger.info("Making delete command object");
			command = initializeDelete(args);
			break;

		case KEYWORD_UPDATE:
			logger.info("Making update command object");
			command = initializeUpdate(args);
			break;

		case KEYWORD_DONE:
			logger.info("Making done command object");
			command = initializeDone(args);
			break;

		case KEYWORD_UNDO:
			command = initializeUndo();
			break;
		/*
		 * case KEYWORD_HELP : command = initializeHelp(); break;
		 */
		case KEYWORD_STORAGE:
			command = initializeStorageLocation(args);
			break;

		case KEYWORD_EXIT:
			logger.info("Making exit command object");
			command = initializeExit();
			break;

		default:
			logger.info("Making add command object");
			command = initializeAdd(args, !WITH_KEYWORD);
			break;
		}
		logger.info("Returning command object");
		return command;

	}

	private Command processHomeInput(String[] args) throws NoDescriptionException {
		Command command;
		if (args.length == 1) {
			logger.info("Making home command object");
			command = initializeHome();
		} else {
			logger.info("Making add command object");
			command = initializeAdd(args, !WITH_KEYWORD);
		}
		return command;
	}

	private Command processListInput(String[] args) throws NoDescriptionException {
        Command command;
        if (args.length == 1) {
            logger.info("Making list command object");
            command = initializeListDisplay();
        } else {
            logger.info("Making add command object");
            command = initializeAdd(args, !WITH_KEYWORD);
        }
        return command;
    }

	private Command initializeAdd(String[] args, boolean isWithKeyWord) throws NoDescriptionException {
		args = removeKeyWordIfReq(args, isWithKeyWord);
		int dateStartIndex = getDateStartIndex(args);
		int locationStartIndex = getLastIndex(LOCATION_MARKERS, args);
		int priorityIndex = getLastIndex(PRIORITY_MARKERS, args);
		priorityIndex = fixPriorityIndex(priorityIndex, args);
		String[] segments = getSegments(dateStartIndex, locationStartIndex, priorityIndex, args);
		Calendar[] dates = parseDates(segments);
		if (segments[DESC_POS].equals(EMPTY)) {
			throw new NoDescriptionException();
		}
		Calendar[] datesFixed = fixDatesForAdd(dates);
		Calendar remindDate = convertToCalendar(createEmptyDate());
		Command command = new Add(segments[DESC_POS], datesFixed[0], datesFixed[1], segments[LOC_POS], remindDate, segments[PRI_POS]);
		return command;
	}

	private String[] removeKeyWordIfReq(String[] args, boolean isWithKeyWord) {
		if (isWithKeyWord) {
			return (String[]) ArrayUtils.remove(args, 0);
		}
		return args;
	}

	private Command initializeSearch(String[] args) {
		args = (String[]) ArrayUtils.remove(args, 0);
		Command command = getAppropSearchCommand(args);
		System.out.println("Search initialised");
		return command;
	}

	private Command initializeHome() {
		return new Home();
	}
    
	private Command initializeListDisplay() {
        return new ListDisplay();
    }
	
	private Command initializeDelete(String[] args) {
		args = (String[]) ArrayUtils.remove(args, 0);
		try {
			return getAppropDeleteCommand(args);
		} catch (NumberFormatException e) {
			return getCommandDeleteByName(args);
		}
	}

	private Command initializeUpdate(String[] args) {
		args = (String[]) ArrayUtils.remove(args, 0);
		int taskToUpdate = Integer.parseInt(args[0]);
		args = (String[]) ArrayUtils.remove(args, 0);
		int dateStartIndex = getDateStartIndex(args);
		int locationStartIndex = getLastIndex(LOCATION_MARKERS, args);
		int priorityIndex = getLastIndex(PRIORITY_MARKERS, args);
        priorityIndex = fixPriorityIndex(priorityIndex, args);
        String[] segments = getSegments(dateStartIndex, locationStartIndex, priorityIndex, args);
		Calendar[] dates = parseDates(segments);
		dates = fixDatesForUpdate(dates);
		Calendar remindDate = convertToCalendar(createEmptyDate());
		Command command = new Update(taskToUpdate, segments[DESC_POS], dates[0], dates[1], segments[LOC_POS],
				remindDate, segments[PRI_POS]);
		return command;
	}

	private Command initializeDone(String[] args) {
		args = (String[]) ArrayUtils.remove(args, 0);
		try {
			return getAppropDoneCommand(args);
		} catch (NumberFormatException e) {
			return getCommandDoneByName(args);
		}
	}

	private Command initializeUndo() {
		Command command = new Undo();
		return command;
	}

	/*
	 * private Command initializeHelp(){ Command command = new Help (); return
	 * command; }
	 */
        
```
###### Tasker\src\application\logic\ShowDoneTasks.java
``` java

import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;


public class ShowDoneTasks implements Command{

    private static final String MESSAGE_CLOSED = "Here are the tasks you have closed.";
    private static final String MESSAGE_NO_CLOSED = "You have not closed any tasks.";
    
    @Override
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
        ArrayList<Task> tasks = storageConnector.getClosedList();
        return createAppropFeedback(storageConnector, tasks);
    }
    
    private Feedback createAppropFeedback(StorageConnector storageConnector, ArrayList<Task> tasks){
        if (tasks.size() == 0){
            return getFeedbackCal(MESSAGE_NO_CLOSED, storageConnector.getOpenList(), null);
        } else{
            Feedback fb = new Feedback(MESSAGE_CLOSED, tasks, null);
            fb.setListFlag();
            return fb;
        }
    }
    
    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
}
```
###### Tasker\src\application\logic\StorageConnector.java
``` java

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Storage;
import application.storage.Task;



public class StorageConnector {
    Storage storage = new Storage();
    
    public void setDirectory(String filePath) throws IOException{
        storage.setDirectory(filePath);
    }
    
    public void initialise() throws IOException{
        storage.initialise();
    }
    
    public ArrayList<Task> getOpenList(){
        return storage.getOpenList();
    }
    
    public boolean directoryExists() throws IOException{
        return storage.directoryExists();
    }
    
    public Task addTaskInList(String description, Calendar startDateTime
            ,Calendar endDateTime, String location, Calendar remindDate,String priority) throws IOException{
        return storage.addTaskInList(description, startDateTime, endDateTime, location, remindDate, priority);
    }
    
    public Task deleteTask(int index) throws IOException{
        return storage.deleteTask(index);
    }
    
    public ArrayList<Task> searchTaskByName(String taskToDelete){
        return storage.searchTaskByName(taskToDelete);
    }
    
    public Task uncloseTask(int index) throws IOException{
        return storage.uncloseTask(index);
    }
    
    public Task closeTask(int index) throws IOException{
        return storage.closeTask(index);
    }
    
    public ArrayList<Task> searchTaskByDate(Calendar date){
        return storage.searchTaskByDate(date);
    }
    
    public ArrayList<Task> searchTaskByPriority(String priority) {
        return storage.searchTaskByPriority(priority);
    }
    
    public ArrayList<Task> searchTaskOnDate(Calendar date){
        return storage.searchTaskOnDate(date);
    }
    
    public ArrayList<Task> getClosedList(){
        return storage.getCloseList();
    }
    
    public ArrayList<Task> updateTask(int idTaskToDelete, String description, 
            Calendar startDateTime, Calendar endDateTime
            ,String location
            , Calendar remindDate, String priority) throws IOException, CloneNotSupportedException{
        return storage.updateTask(idTaskToDelete, description, 
                startDateTime, endDateTime
                ,location
                , remindDate, priority);
    }
    
}
```
###### Tasker\src\application\logic\Undo.java
``` java

import java.util.ArrayList;
import java.util.EmptyStackException;

import application.storage.Storage;
import application.storage.Task;


public class Undo implements Command {
    private static final String MESSAGE_NOTHING_TO_UNDO = "There are no commands left to undo!";
    
    
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks){
        try{
            History history = History.getInstance();
            return history.undo();
        }catch(EmptyStackException e){
            return getFeedbackCal(MESSAGE_NOTHING_TO_UNDO, storageConnector.getOpenList(), null);
        }
    }
    
    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
}
```
###### Tasker\src\application\logic\UndoableCommand.java
``` java

import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;



public interface UndoableCommand extends Command {
    @Override 
    Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks);
    Feedback undo() throws NothingToUndoException;
}
```
###### Tasker\src\application\logic\Update.java
``` java

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Storage;
import application.storage.Task;



public class Update implements UndoableCommand{
    public static final int NOT_FOUND = -1;
    public static final int INDEX_TASK_POSITION = 0;
    public static final int INDEX_UPDATED_TASK = 1;
    public static final int INDEX_ORIGINAL_TASK = 0;
    public static final int ARRAY_INDEXING_OFFSET = 1;
    public static final String EMPTY = "";
    private static final String MESSAGE_UPDATE_ERROR = 
            "We encountered an error while updating the task. Sorry for the inconvenience.";    
    private static final String MESSAGE_UPDATE_FEEDBACK = 
            "Updated Task: %1$s";    
    private static final String MESSAGE_UNDO_FEEDBACK = 
            "Reverted: %1$s";  
    private static final String MESSAGE_UNDO_FAILURE = "We encountered an error while undoing.";
            
    
    Task origTask;
    Task updatedTask;
    StorageConnector storageConnector;
    
    private int taskPosition = -1;
    private String description = EMPTY;
    private Calendar startDateTime;
    private Calendar endDateTime;
    private String location = EMPTY;
    private Calendar remindDate;
    private String priority = EMPTY;
    
    Update(int taskPosition, String description, Calendar start, Calendar end, String location, Calendar remindDate, String priority){
        this.taskPosition = taskPosition - ARRAY_INDEXING_OFFSET;
        this.description = description;
        this.startDateTime = start;
        this.endDateTime = end;
        this.location = location;
        this.remindDate = remindDate;
        this.priority = priority;
    }
  
   
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks){
        try{
            this.storageConnector = storageConnector;
            
            int idTaskToDelete = tasks.get(taskPosition).getTaskIndex();
            ArrayList<Task> returnedTasks = storageConnector.updateTask(idTaskToDelete, description, 
                    startDateTime, endDateTime
                    ,location
                    , remindDate, priority);
            origTask = returnedTasks.get(INDEX_ORIGINAL_TASK);
            updatedTask = returnedTasks.get(INDEX_UPDATED_TASK);
            String feedbackMessage = String.format(MESSAGE_UPDATE_FEEDBACK, "From: " 
                    + origTask.toString() + "\n" + "To: " + updatedTask.toString());
            //System.out.println("Orig:" + origTask.getStartDate());
            //System.out.println("Updated:" + updatedTask.getStartDate());
            
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), updatedTask);
        } catch (IOException e){
            return getFeedbackCal(MESSAGE_UPDATE_ERROR, storageConnector.getOpenList(), null);
        } catch (CloneNotSupportedException e){
            return getFeedbackCal(MESSAGE_UPDATE_ERROR, storageConnector.getOpenList(), null);
        }
    }
    
    
    public Feedback undo(){
        try {
            Task deletedTask = storageConnector.deleteTask(updatedTask.getTaskIndex());
            Task revertedTask = storageConnector.addTaskInList(origTask.getTaskDescription(), origTask.getStartDate(),
            origTask.getEndDate(),  origTask.getLocation(),  origTask.getRemindDate(),
            origTask.getPriority());
            String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK,"From: " 
                    + deletedTask.toString() + "\n" + "To: " + revertedTask.toString());
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), revertedTask);
        }catch(IOException e){
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }
    
    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
    
    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
    
    
}
```
