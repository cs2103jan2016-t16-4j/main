# A0132632R
###### Fantasktic\bin\application\gui\application.css
``` css

.list-cell{
    -fx-cell-hover-color: #80DEEA;
    -fx-background-color: white;
}

```
###### Fantasktic\src\application\backend\Add.java
``` java

package application.backend;

import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Task;

import java.io.IOException;

/**
 * This class is an Command object which adds a task based on user input. Check
 * Command class documentation for insight on what the public methods do.
 * 
 * @author Pratyush
 *
 */
public class Add implements UndoableCommand {
    public static final int NOT_FOUND = -1;
    public static final String EMPTY = "";
    private static final String MESSAGE_ADD_FEEDBACK = "Added Task: %1$s";
    private static final String MESSAGE_ADD_ERROR = "We encountered an error while adding the task. Sorry for the inconvenience.";

    private static final String MESSAGE_UNDO_FAILURE = "We encountered a problem while undoing.";
    private static final String MESSAGE_UNDO_FEEDBACK = "Unadded: %1$s";

    Task addedTask;
    StorageConnector storageConnector;

    String description = EMPTY;
    Calendar startDateTime;
    Calendar endDateTime;
    String location = EMPTY;
    Calendar remindDate;
    String priority = EMPTY;

    Add(String description, Calendar startDateTime, Calendar endDateTime, String location, Calendar remindDate,
            String priority) throws NoDescriptionException {
        this.description = description;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        this.remindDate = remindDate;
        this.priority = priority;
    }

    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
        try {
            this.storageConnector = storageConnector;
            addedTask = storageConnector.addTaskInList(description, startDateTime, endDateTime, location, remindDate,
                    priority);
            String feedbackMessage = String.format(MESSAGE_ADD_FEEDBACK, addedTask.toString());
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), addedTask);
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_ADD_ERROR, storageConnector.getOpenList(), null);
        }
    }

    public Feedback undo() {
        try {
            storageConnector.deleteTask(addedTask.getTaskIndex());
            String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK, addedTask.toString());
            return getFeedbackCal(feedbackMessage, storageConnector.getOpenList(), null);
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
}
```
###### Fantasktic\src\application\backend\BackendFacade.java
``` java

import java.io.IOException;
import java.util.ArrayList;

import application.storage.Task;

/**
 * This is the facade class for the backend package. This is the class that is
 * accessed by all other packages.
 * 
 * @author Pratyush
 *
 */
public class BackendFacade {
    private Logic logic = new Logic();

    public boolean checkIfFileExists() throws IOException {
        return logic.checkIfFileExists();
    }

    public ArrayList<Task> loadDataFile() throws IOException {
        return logic.loadDataFile();
    }

    public void setDirectory(String filePath) throws IOException {
        logic.setDirectory(filePath);
    }

    public ArrayList<Task> getClashes(Task task) {
        return logic.getClashes(task);
    }

    public int getCompletedTaskCount() {
        return logic.getCompletedTaskCount();
    }

    public int getRemainingTaskCount() {
        return logic.getRemainingTaskCount();
    }

    public int getOverdueTaskCount() {
        return logic.getOverdueTaskCount();
    }

    public Feedback executeCommand(String command, ArrayList<Task> tasksOnScreen) throws NoDescriptionException {
        return logic.executeCommand(command, tasksOnScreen);
    }
}
```
###### Fantasktic\src\application\backend\BackendUnitTest.java
``` java
import application.storage.Storage;
import application.storage.StorageStubForBackend;
import application.storage.Task;

import static org.junit.Assert.assertEquals;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

/**
 * This class is a test driver for unit testing the backend package.
 * 
 * @author Pratyush
 *
 */
public class BackendUnitTest {
    private static final int SIZE = 10;

    private Storage storage = new StorageStubForBackend(SIZE);
    private StorageConnector storageConnector = new StorageConnector(storage);
    private Logic logic = new Logic(storageConnector);

    @Test
    public void addTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("play tennis from 5 pm to 6 pm tomorrow", tasksOnScreen);
        assertEquals("play tennis", fb.getTaskToScrollTo().getTaskDescription());
        Feedback fb2 = logic.executeCommand("add football coaching from 2 pm tomorrow", tasksOnScreen);
        assertEquals("football coaching", fb2.getTaskToScrollTo().getTaskDescription());
        Feedback fb3 = logic.executeCommand("add football coaching from now to then at NUS -d from 2 pm tomorrow",
                tasksOnScreen);
        assertEquals("football coaching from now to then at NUS", fb3.getTaskToScrollTo().getTaskDescription());
    }

    @Test
    public void addTestForDate() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("cs2103 lecture from 4 pm to 6 pm 15th april", tasksOnScreen);
        assertIfDateMatches(fb.getTaskToScrollTo(), "15/04/2016 4:00 PM", "15/04/2016 6:00 PM");
        Feedback fb2 = logic.executeCommand("cs2103 lecture from 15/04/2016 4 pm to 6 pm ", tasksOnScreen);
        assertIfDateMatches(fb2.getTaskToScrollTo(), "15/04/2016 4:00 PM", "15/04/2016 6:00 PM");
        Feedback fb3 = logic.executeCommand("read moby dick", tasksOnScreen);
        assertIfDateMatches(fb3.getTaskToScrollTo(), "", "");
        Feedback fb4 = logic.executeCommand("submit cs2103 project by 11th april 11:59 pm", tasksOnScreen);
        assertIfDateMatches(fb4.getTaskToScrollTo(), "", "11/04/2016 11:59 PM");
    }

    private void assertIfDateMatches(Task task, String startDate, String endDate) {
        Calendar start = getDate(startDate);
        Calendar end = getDate(endDate);
        assertEquals(start, task.getStartDate());
        assertEquals(end, task.getEndDate());
    }

    private Calendar getDate(String date) {
        DateFormat df = new SimpleDateFormat("dd/MM/yyyy hh:mm aaa");
        try {
            Date dateObj = df.parse(date);
            Calendar calDate = Calendar.getInstance();
            calDate.setTime(dateObj);
            return calDate;
        } catch (ParseException e) {
            return null;
        }
    }

    // Testing via equivalence partitioning
    @Test
    public void deleteTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("delete 1", tasksOnScreen);
        assertEquals("Deleted Task: " + tasksOnScreen.get(0).toString(), fb.getMessage());
        Feedback fb1 = logic.executeCommand("delete 0", tasksOnScreen);
        assertEquals("Please enter a valid number.", fb1.getMessage());
        Feedback fb2 = logic.executeCommand("delete 5", tasksOnScreen);
        assertEquals("Deleted Task: " + tasksOnScreen.get(4).toString(), fb2.getMessage());
        Feedback fb3 = logic.executeCommand("delete " + SIZE, tasksOnScreen);
        assertEquals("Deleted Task: " + tasksOnScreen.get(9).toString(), fb3.getMessage());
        Feedback fb4 = logic.executeCommand("delete " + (SIZE + 1), tasksOnScreen);
        assertEquals("Please enter a valid number.", fb4.getMessage());
    }

    @Test
    public void updateTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("update 0 hello", tasksOnScreen);
        assertEquals("Please enter a valid task number.", fb.getMessage());
        Feedback fb2 = logic.executeCommand("update 1 play", tasksOnScreen);
        assertEquals("play", fb2.getTaskToScrollTo().getTaskDescription());
        Feedback fb3 = logic.executeCommand("update 4 tennis", tasksOnScreen);
        assertEquals("tennis", fb3.getTaskToScrollTo().getTaskDescription());
        Feedback fb4 = logic.executeCommand("update " + SIZE + " football", tasksOnScreen);
        assertEquals("football", fb4.getTaskToScrollTo().getTaskDescription());
        Feedback fb5 = logic.executeCommand("update " + (SIZE + 1) + " football", tasksOnScreen);
        assertEquals("Please enter a valid task number.", fb5.getMessage());
    }

    @Test
    public void searchByNameTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("search Task 2", tasksOnScreen);
        ArrayList<Task> expectedTasks = new ArrayList<Task>();
        expectedTasks.add(tasksOnScreen.get(1));
        assertEquals(expectedTasks, fb.getTasks());
    }

    @Test
    public void searchByPriorityTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("search priority high", tasksOnScreen);
        ArrayList<Task> expectedTasks = new ArrayList<Task>();
        expectedTasks.add(tasksOnScreen.get(SIZE / 2)); // size/2 is always made
                                                        // to be priority high
                                                        // by the stub
        assertEquals(expectedTasks, fb.getTasks());
    }

    @Test
    public void helpTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("help", tasksOnScreen);
        assertEquals("help", fb.getFlag());
    }

    @Test
    public void summaryTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("summary", tasksOnScreen);
        assertEquals("summary", fb.getFlag());
    }

    public void homeTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("home", tasksOnScreen);
        assertEquals("cal", fb.getFlag());
    }

    @Test
    public void doneTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("done 1", tasksOnScreen);
        assertEquals("Closed Task: " + tasksOnScreen.get(0).toString(), fb.getMessage());
        Feedback fb1 = logic.executeCommand("done 0", tasksOnScreen);
        assertEquals("Please enter a valid number.", fb1.getMessage());
        Feedback fb2 = logic.executeCommand("done 5", tasksOnScreen);
        assertEquals("Closed Task: " + tasksOnScreen.get(4).toString(), fb2.getMessage());
        Feedback fb3 = logic.executeCommand("done " + SIZE, tasksOnScreen);
        assertEquals("Closed Task: " + tasksOnScreen.get(9).toString(), fb3.getMessage());
        Feedback fb4 = logic.executeCommand("done " + (SIZE + 1), tasksOnScreen);
        assertEquals("Please enter a valid number.", fb4.getMessage());
    }

    // deleting and then undoing
    @Test
    public void undoTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("delete 2", tasksOnScreen);
        Task deleted = tasksOnScreen.get(1);
        assertEquals("Deleted Task: " + deleted.toString(), fb.getMessage());
        Feedback fb2 = logic.executeCommand("undo", tasksOnScreen);
        assertEquals(deleted.toString(), fb2.getTaskToScrollTo().toString());
    }

    @Test
    public void viewChangeTest() throws NoDescriptionException {
        ArrayList<Task> tasksOnScreen = storage.getOpenList();
        Feedback fb = logic.executeCommand("view", tasksOnScreen);
        assertEquals("view", fb.getFlag());
    }

}
```
###### Fantasktic\src\application\backend\ChangeStorageLocation.java
``` java
	public Feedback undo() throws NothingToUndoException {
		if (prevLocation == null) {
			throw new NothingToUndoException();
		} else {
			return revertStorageLocation();
		}
	}

	private Feedback revertStorageLocation() {
		try {
			return setStorageLocationToPrevious();
		} catch (IOException e) {
			Feedback feedback = new Feedback(MESSAGE_UNDO_ERROR, storageConnector.getOpenList(), null);
			feedback.setCalFlag();
			return feedback;
		}
	}

	private Feedback setStorageLocationToPrevious() throws IOException {
		storageConnector.setDirectory(prevLocation);
		Feedback feedback = new Feedback(MESSAGE_UNDO_CHANGE + prevLocation, storageConnector.getOpenList(), null);
		feedback.setCalFlag();
		return feedback;
	}
}
```
###### Fantasktic\src\application\backend\Command.java
``` java

import java.util.ArrayList;

import application.storage.Task;

/**
 * This is an interface class for all command objects. This is used to implement
 * a command pattern.
 * 
 * @author Pratyush
 *
 */
public interface Command {

    /**
     * This method is implemented by each command object. Logic can simply call
     * this method to execute that particular command object.
     * 
     * @param storageConnector
     *            The StorageConnector object reference should be passed to this
     *            method.
     * @param tasksOnScreen
     *            An ArrayList of Tasks that are currently being displayed
     *            should be passed to this.
     * @return A feedback object containing the specific information of the
     *         particular execution.
     */
    Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen);

}
```
###### Fantasktic\src\application\backend\DeleteByName.java
``` java

import java.io.IOException;
import java.util.ArrayList;

import application.storage.Task;

/**
 * This class is an UndoableCommand object which deletes a task that the user
 * has specified by name. Check UndoableCommand documentation for insight on
 * what the public methods do.
 * 
 * @author Pratyush
 *
 */
public class DeleteByName implements UndoableCommand {
    private static final int FIRST_INDEX = 0;
    private static final String FEEDBACK_DELETE = "Deleted Task: %1$s";
    private static final String MESSAGE_NOTHING_TO_DELETE = "There is no task with that description.";
    private static final String MESSAGE_CANNOT_DELETE_EMPTY = "Please enter some keywords from, or the number of, the task you want to delete.";
    private static final String MESSAGE_WHICH_DELETE = "Which task would you like to delete?";
    private static final String MESSAGE_DELETE_ERROR = "We encountered some "
            + "problem while deleting this task. We apologise for the inconvenience.";
    private static final String MESSAGE_UNDO_FAILURE = "We encountered a problem while undoing.";
    private static final String MESSAGE_UNDO_FEEDBACK = "Re-added: %1$s";

    String taskToDelete;
    StorageConnector storageConnector;
    Task deletedTask;

    DeleteByName(String taskToDelete) {
        System.out.println("HERE" + taskToDelete);
        this.taskToDelete = taskToDelete;
    }

    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
        try {
            ArrayList<Task> taskList = storageConnector.searchTaskByName(taskToDelete);
            Feedback feedback = takeAction(taskList, storageConnector);
            return feedback;
        } catch (IOException e) {
            Feedback feedback = new Feedback(MESSAGE_DELETE_ERROR, storageConnector.getOpenList(), null);
            feedback.setCalFlag();
            return feedback;
        }
    }

    public Feedback takeAction(ArrayList<Task> taskList, StorageConnector storageConnector) throws IOException {
        assert (taskList != null);
        this.storageConnector = storageConnector;
        System.out.println(taskList.size());
        if (taskToDelete.trim().equalsIgnoreCase("")) {
            return getFeedbackCal(MESSAGE_CANNOT_DELETE_EMPTY, storageConnector.getOpenList(), null);
        }
        return takeActionBasedOnListLength(taskList, storageConnector);
    }

    private Feedback takeActionBasedOnListLength(ArrayList<Task> taskList, StorageConnector storageConnector)
            throws IOException {
        if (taskList.size() == 0) {
            return getFeedbackCal(MESSAGE_NOTHING_TO_DELETE, storageConnector.getOpenList(), null);
        } else if (taskList.size() == 1) {
            deletedTask = storageConnector.deleteTask(taskList.get(FIRST_INDEX).getTaskIndex());
            String feedbackMessage = String.format(FEEDBACK_DELETE, deletedTask.toString());
            return getFeedbackCal(feedbackMessage, storageConnector.getOpenList(), null);
        } else {
            return getFeedbackList(MESSAGE_WHICH_DELETE, taskList, null);
        }
    }

    public Feedback undo() throws NothingToUndoException {
        try {
            if (deletedTask != null) {
                return reAddTask();
            } else {
                throw new NothingToUndoException();
            }
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

    private Feedback reAddTask() throws IOException {
        storageConnector.addTaskInList(deletedTask.getTaskDescription(), deletedTask.getStartDate(),
                deletedTask.getEndDate(), deletedTask.getLocation(), deletedTask.getRemindDate(),
                deletedTask.getPriority());
        String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK, deletedTask.toString());
        return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), deletedTask);
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }

}
```
###### Fantasktic\src\application\backend\DeleteByNum.java
``` java

import java.io.IOException;
import java.util.ArrayList;

import application.storage.Task;

/**
 * This class is an UndoableCommand object which deletes a task that the user
 * has specified by its task number in the list of tasks displayed to him/her. 
 * Check UndoableCommand documentation for insight on what the public methods do.
 * 
 * @author Pratyush
 *
 */
public class DeleteByNum implements UndoableCommand {
    private static final String MESSAGE_DELETE_FAILURE = "We encountered a problem while deleting this task.";
    private static final String MESSAGE_UNDO_FAILURE = "We encountered a problem while undoing.";
    private static final String MESSAGE_DELETE_FEEDBACK = "Deleted Task: %1$s";
    private static final String MESSAGE_UNDO_FEEDBACK = "Re-added: %1$s";
    private static final String MESSAGE_INDEX_PROBLEM = "Please enter a valid number.";

    Task deletedTask;
    int numToDelete;
    StorageConnector storageConnector;

    DeleteByNum(int numToDelete) {
        this.numToDelete = numToDelete;
    }

    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
        this.storageConnector = storageConnector;
        try {
            return deleteTask(storageConnector, tasks);
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_DELETE_FAILURE, storageConnector.getOpenList(), null);
        } catch (IndexOutOfBoundsException e) {
            return getFeedbackCal(MESSAGE_INDEX_PROBLEM, storageConnector.getOpenList(), null);
        }
    }

    private Feedback deleteTask(StorageConnector storageConnector, ArrayList<Task> tasks) throws IOException {
        int idOfTaskToDelete = tasks.get(numToDelete).getTaskIndex();
        deletedTask = storageConnector.deleteTask(idOfTaskToDelete);
        String feedbackMessage = String.format(MESSAGE_DELETE_FEEDBACK, deletedTask.toString());
        Feedback feedback = new Feedback(feedbackMessage, storageConnector.getOpenList(), null);
        feedback.setCalFlag();
        return feedback;
    }

    public Feedback undo() throws NothingToUndoException {
        try {
            raiseExceptionIfNoDeletedTask();
            storageConnector.addTaskInList(deletedTask.getTaskDescription(), deletedTask.getStartDate(),
                                           deletedTask.getEndDate(), deletedTask.getLocation(), 
                                           deletedTask.getRemindDate(), deletedTask.getPriority());
            String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK, deletedTask.toString());
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), deletedTask);
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

    private void raiseExceptionIfNoDeletedTask() throws NothingToUndoException {
        if (deletedTask == null){
            throw new NothingToUndoException();
        }
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }

}
```
###### Fantasktic\src\application\backend\DoneByName.java
``` java

    public Feedback undo() throws NothingToUndoException {
        try {
            if (closedTask != null) {
                storageConnector.uncloseTask(closedTask.getTaskIndex());
                String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK, closedTask.toString());
                return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), closedTask);
            } else {
                throw new NothingToUndoException();
            }
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

```
###### Fantasktic\src\application\backend\DoneByName.java
``` java

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
}

```
###### Fantasktic\src\application\backend\DoneByNum.java
``` java

    public Feedback undo() throws NothingToUndoException {
        try {
            raiseExceptionIfNoClosedTask();
            storageConnector.uncloseTask(closedTask.getTaskIndex());
            String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK, closedTask.toString());
            return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), closedTask);
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

    private void raiseExceptionIfNoClosedTask() throws NothingToUndoException {
        if (closedTask == null){
            throw new NothingToUndoException();
        }
    }

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }

}
```
###### Fantasktic\src\application\backend\Feedback.java
``` java

import java.util.ArrayList;

import application.storage.Task;

/**
 * This class is used to send back feedback from the execution of a command to
 * the logic component, which then sends it back to the GUI, which uses it to
 * display information to the user.
 * 
 * @author Pratyush
 *
 */

public class Feedback {

    // Flags
    private static final String LIST_FLAG = "list";
    private static final String CAL_FLAG = "cal";
    private static final String HELP_FLAG = "help";
    private static final String STORAGE_FLAG = "storage";
    private static final String VIEW_CHANGE_FLAG = "view";
    private static final String SUMMARY_FLAG = "summary";

    // Flags the UI on which view to use
    private String flag;

    // Contains the task to scroll to when displaying all tasks. Can be null if
    // no such task
    private Task taskToScroll;

    // The feedback message you want to display to the user
    private String feedbackMessage;

    // The tasks you want to display to the user
    private ArrayList<Task> tasksToDisplay;

    Feedback(String message, ArrayList<Task> tasks, Task taskToScroll) {
        this.feedbackMessage = message;
        this.tasksToDisplay = tasks;
        this.taskToScroll = taskToScroll;
    }

    public void setListFlag() {
        flag = LIST_FLAG;
    }

    public void setViewChangeFlag() {
        flag = VIEW_CHANGE_FLAG;
    }

    public void setCalFlag() {
        flag = CAL_FLAG;
    }

    public void setSummaryFlag() {
        flag = SUMMARY_FLAG;
    }

    public void setHelpFlag() {
        flag = HELP_FLAG;
    }

    public void setStorageFlag() {
        flag = STORAGE_FLAG;
    }

    public ArrayList<Task> getTasks() {
        return this.tasksToDisplay;
    }

    public String getFlag() {
        return flag;
    }

    public Task getTaskToScrollTo() {
        return taskToScroll;
    }

    public String getMessage() {
        return this.feedbackMessage;
    }

}
```
###### Fantasktic\src\application\backend\History.java
``` java

import java.util.Stack;

/**
 * This class maintains a stack of all previous Undoable Commands since the
 * start of the program. This is a singleton class. The Undo command uses this
 * class to undo the previous command. This is the class that allows multiple
 * undos.
 * 
 * @author Pratyush
 *
 */
public class History {

    private Stack<UndoableCommand> executedCommands;
    private static History instance;

    private History() {
        this.executedCommands = new Stack<UndoableCommand>();
    }

    public static History getInstance() {
        if (instance == null) {
            instance = new History();
        }
        return instance;
    }

    /**
     * This method should be used to add a command object to the history stack.
     * If the command is an Undoable command, it is added, otherwise discarded.
     * 
     * @param cmd The Command object you wish to add.
     */

    public void add(Command cmd) {
        if (cmd instanceof UndoableCommand) {
            UndoableCommand cmd_undoable = (UndoableCommand) cmd;
            executedCommands.add(cmd_undoable);
        }
    }

    /**
     * This method should be used to undo the previous command.
     * 
     * @return A feedback object related to the undoing of that particular
     *         command.
     */
    public Feedback undo() {
        try {
            UndoableCommand cmd = executedCommands.pop();
            Feedback feedback = cmd.undo();
            return feedback;
        } catch (NothingToUndoException e) {
            return undo();
        }
    }

}
```
###### Fantasktic\src\application\backend\Home.java
``` java

import java.util.ArrayList;

import application.storage.Task;

/**
 * This is the class for the Command object which allows users to get back to
 * viewing all tasks. Please check command class documentation for information
 * on public methods.
 * 
 * @author Pratyush
 *
 */
public class Home implements Command {

    private static final String MESSAGE_BACK_HOME = "You are back home!";

    @Override
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
        return getFeedbackCal(MESSAGE_BACK_HOME, storageConnector.getOpenList(), null);
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
}
```
###### Fantasktic\src\application\backend\Logic.java
``` java
/**
 * This class can be thought of as the decision maker for the backend package.
 * 
 * @author Pratyush
 *
 */
public class Logic {

	// Constants
	private static final int START_COUNT = 0;
	private static final int OVERDUE_CHECK_VARIABLE = 0;

	// Initialization
	private Parser parser = new Parser();
	private StorageConnector storageConnector = new StorageConnector();
	private static Logger logger = LoggerHandler.getLog();
	private History history = History.getInstance();

	public Logic() {
	}

	// To enable testing
	protected Logic(StorageConnector storageConnector) {
		this.storageConnector = storageConnector;
	}

	/**
	 * This method should be called to parse and execute user entered commands
	 * (which may be in natural language style).
	 * 
	 * @param command
	 *            A string input of the user command
	 * @param tasksOnScreen
	 *            An ArrayList of the current tasks being displayed
	 * @return A feedback object containing feedback which has been constructed
	 *         based on the execution of that particular command
	 * @throws NoDescriptionException
	 *             This exception is thrown if the Parser encounters that the
	 *             user has not entered a description for a task
	 */

	public Feedback executeCommand(String command, ArrayList<Task> tasksOnScreen) throws NoDescriptionException {
		Feedback feedback;
		Command cmd = parser.interpretCommand(command);
		logger.info("executing above parsed command");
		feedback = cmd.execute(storageConnector, tasksOnScreen);
		logger.info("adding command to history");
		history.add(cmd);
		return feedback;
	}

	/**
	 * This method should be called to get all timing clashes with a particular
	 * task.
	 * 
	 * @param task
	 *            The task you want to check clashes for.
	 * @return A list of tasks that clash with this task, along with the task
	 *         itself.
	 */
	public ArrayList<Task> getClashes(Task task) {
		logger.info("getting all tasks to check for clash");
		ArrayList<Task> openTasks = storageConnector.getOpenList();
		logger.info("initiating arraylist");
		ArrayList<Task> tasksClashing = new ArrayList<Task>();
		logger.info("checking if main task is an event");
		if (!(task instanceof EventTask)) {
			logger.info("main task not event. returning task without checking for clashes.");
			tasksClashing.add(task);
			return tasksClashing;
		}
		return addAllClashingTasksIfEvent(task, openTasks, tasksClashing);
	}

	// Checks all tasks and returns an ArrayList of all the clashing tasks
	private ArrayList<Task> addAllClashingTasksIfEvent(Task task, ArrayList<Task> openTasks,
			ArrayList<Task> tasksClashing) {
		logger.info("task is an event. looping through all tasks to check for clashes.");
		for (Task taskUnderConsideration : openTasks) {
			addIfClashing(tasksClashing, task, taskUnderConsideration);
		}
		return tasksClashing;
	}

	// adds taskUnderConsideration to the ArrayList if it clashes with 'task'
	private void addIfClashing(ArrayList<Task> tasksClashing, Task task, Task taskUnderConsideration) {
		logger.info("checking if task under consideration is an Event Task");
		if (taskUnderConsideration instanceof EventTask) {
			logger.info("Getting dates from task under consideration");
			Calendar startDate = taskUnderConsideration.getStartDate();
			Calendar endDate = taskUnderConsideration.getEndDate();
			logger.info("Checking if clashing");
			if (endDate.compareTo(task.getStartDate()) > 0 && startDate.compareTo(task.getEndDate()) < 0) {
				logger.info("Clashing. Adding to Tree Set");
				tasksClashing.add(taskUnderConsideration);
			}
		}
	}

```
###### Fantasktic\src\application\backend\NoDescriptionException.java
``` java

/**
 * This is an exception to signify that the user has not entered any description
 * for a task s/he wants to add.
 * 
 * @author Pratyush
 *
 */
public class NoDescriptionException extends Exception {

    private static final long serialVersionUID = 1L;

    public NoDescriptionException() {
        super();
    }
}
```
###### Fantasktic\src\application\backend\NotDateException.java
``` java

/**
 * This exception is used to signify that the words following "date keywords"
 * such as "from","to","by", do not represent a date. This is then used to add
 * these words to the description.
 * 
 * @author Pratyush
 *
 */
public class NotDateException extends Exception {

    private static final long serialVersionUID = 1L;

    public NotDateException() {
        super();
    }

}
```
###### Fantasktic\src\application\backend\NothingToUndoException.java
``` java

/**
 * There are certain undoableCommands that, depending on the way they were
 * executed, may not yet have anything to undo. This exception signifies this
 * and enables the History package to skip these command objects.
 * 
 * @author Pratyush
 *
 */
public class NothingToUndoException extends Exception {

    private static final long serialVersionUID = 1L;

    public NothingToUndoException() {
        super();
    }
}
```
###### Fantasktic\src\application\backend\Parser.java
``` java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;

import org.apache.commons.lang.ArrayUtils;
import org.joda.time.LocalDateTime;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;
import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Collections;

import application.logger.LoggerHandler;

/**
 * This class takes in a userInput and interprets it. If user input is not
 * erroneous, it returns a command object which contains all the information of
 * the user input and also holds information on how to carry out the request of
 * the user.
 * 
 * @author Pratyush
 *
 */

public class Parser {

    // Messages
    private static final String MESSAGE_NULL_ERROR = "command cannot be null";

    // Keywords
    private static final String KEYWORD_ADD = "add";
    private static final String KEYWORD_SEARCH = "search";
    private static final String KEYWORD_HOME = "home";
    private static final String KEYWORD_DELETE = "delete";
    private static final String KEYWORD_UPDATE = "update";
    private static final String KEYWORD_DONE = "done";
    private static final String KEYWORD_UNDO = "undo";
    private static final String KEYWORD_HELP = "help";
    private static final String KEYWORD_VIEW_CHANGE = "view";
    private static final String KEYWORD_STORAGE = "storage";
    private static final String KEYWORD_SUMMARY = "summary";
    private static final String KEYWORD_EXIT = "exit";
    private static final String EMPTY = "";

    private static final String SPACE = "\\s+";

    // Input Segment markers
    private static final String[] DATE_MARKERS_START = { "from" };
    private static final String[] DATE_MARKERS_END = { "to", "till" };
    private static final String[] DATE_MARKERS_DEADLINE = { "by" };
    private static final String[] DATE_MARKERS_FULL_DAY_EVENT = { "on" };
    private static final String[] LOCATION_MARKERS = { "at", "in" };
    private static final String[] PRIORITY_MARKERS = { "priority" };
    private static final String UNIX_DATE_MARKER = "-d";
    private static final String UNIX_LOC_MARKER = "-l";
    private static final String UNIX_PRI_MARKER = "-p";
    private static final String[] UNIX_MARKERS = { UNIX_DATE_MARKER, UNIX_LOC_MARKER, UNIX_PRI_MARKER };

    // Priority levels
    private static final String PRIORITY_HIGH = "high";
    private static final String PRIORITY_MEDIUM = "medium";
    private static final String PRIORITY_LOW = "low";
    private static final String[] PRIORITY_LEVELS = { PRIORITY_HIGH, PRIORITY_MEDIUM, PRIORITY_LOW };

    // Indices information for different segments of input
    private static final int NUMBER_INDICES = 3;
    private static final int DATE_IND_POS = 0;
    private static final int LOC_IND_POS = 1;
    private static final int PRI_IND_POS = 2;
    private static final int NOT_PRESENT = -1;

    // certain constants to use while processing input
    public static final int EMPTY_TIME = 001;
    public static final int DEFAULT_EVENT_DURATION_TIME = 2;
    public static final int DEFAULT_EVENT_DURATION_DAY = 1;
    private static final int ARGUMENT_NUMBER = 4; // Number of arguments we
                                                  // accept from user
    private static final int DESC_POS = 0;
    private static final int DATE_POS = 1;
    private static final int LOC_POS = 2;
    private static final int PRI_POS = 3;
    private static final int ARRAY_INDEXING_OFFSET = 1;
    private static final int STORAGE_CHANGE_LIMIT = 2;
    private static final int SECOND_WORD = 1;

    // For add function. Since we accept add without keyword.
    private static final boolean WITH_KEYWORD = true;

    private static Logger logger = LoggerHandler.getLog();
    private PrettyTimeParser dateParser = new PrettyTimeParser();

    public Parser() {
        // Doing a dummy run so that subsequent runs are faster.
        dateParser.parse("2 hours before midnight day after tomorrow");
    }

    /**
     * This method should be used to parse a users input and form a command
     * object from it.
     * 
     * @param userCommand
     *            A string of the user inputed command.
     * @return A Command object created for each specific command
     * @throws NoDescriptionException
     *             This exception is thrown if the user does not enter a task
     *             description while adding.
     */
    public Command interpretCommand(String userCommand)
            throws NoDescriptionException /* throws Exception */ {
        logger.info("Checking for error in user command: " + userCommand);
        checkForError(userCommand);
        logger.info("Splitting command into array of its words");
        String[] inputArgs = userCommand.trim().split(SPACE);
        logger.info("Getting command key word");
        String commandKeyword = inputArgs[0]; // Keyword position always going
                                              // to be 0
        logger.info("Converting to command object: " + commandKeyword);
        Command command = convertToCommand(commandKeyword, inputArgs);
        logger.info("Returning command object");
        return command;
    }

    // Converting to relevant command object using switch case
    public Command convertToCommand(String keyword, String[] args) throws NoDescriptionException {
        Command command;
        switch (keyword.toLowerCase()) {
        case KEYWORD_ADD:
            logger.info("Making add command object");
            command = initializeAdd(args, WITH_KEYWORD);
            break;

        case KEYWORD_SEARCH:
            logger.info("Making search command object");
            command = initializeSearch(args);
            break;

        case KEYWORD_HOME:
            logger.info("Making home command object");
            command = processHomeInput(args);
            break;

        case KEYWORD_VIEW_CHANGE:
            command = processViewInput(args);
            break;

        case KEYWORD_DELETE:
            logger.info("Making delete command object");
            command = initializeDelete(args);
            break;

        case KEYWORD_UPDATE:
            logger.info("Making update command object");
            command = initializeUpdate(args);
            break;

        case KEYWORD_DONE:
            logger.info("Making done command object");
            command = initializeDone(args);
            break;

        case KEYWORD_SUMMARY:
            logger.info("Making summary command object");
            command = initializeSummary();
            break;

        case KEYWORD_UNDO:
            logger.info("Making undo command object");
            command = initializeUndo();
            break;
        case KEYWORD_HELP:
            logger.info("Making help command object");
            command = initializeHelp();
            break;
        case KEYWORD_STORAGE:
            logger.info("Making storage location change command object");
            command = initializeStorageLocation(args);
            break;

        case KEYWORD_EXIT:
            logger.info("Making exit command object");
            command = initializeExit();
            break;

        default:
            logger.info("Making add command object");
            command = initializeAdd(args, !WITH_KEYWORD);
            break;
        }
        logger.info("Returning command object");
        return command;
    }

    /* 
     * Processing "home" input to see if it is truly home command or whether it
     * is simply the beginning of a task description. Making command object
     * accordingly.
     */
    private Command processHomeInput(String[] args) throws NoDescriptionException {
        Command command;
        if (args.length == 1) {
            logger.info("Making home command object");
            command = initializeHome();
        } else {
            logger.info("Making add command object");
            command = initializeAdd(args, !WITH_KEYWORD);
        }
        return command;
    }

    /*
     *  Processing "view" input to see if it is truly view command or whether it
     *  is simply the beginning of a task description. Making command object
     *  accordingly.
     */
    private Command processViewInput(String[] args) throws NoDescriptionException {
        Command command;
        if (args.length == 1) {
            logger.info("Making view command object");
            command = initializeViewChange();
        } else {
            logger.info("Making add command object");
            command = initializeAdd(args, !WITH_KEYWORD);
        }
        return command;
    }

    private Command initializeAdd(String[] args, boolean isWithKeyWord) throws NoDescriptionException {
        args = removeKeyWordIfReq(args, isWithKeyWord);
        Integer[] indices = getIndices(args);
        String[] segments = getSegments(indices[DATE_IND_POS], indices[LOC_IND_POS], 
                                        indices[PRI_IND_POS], args);
        Calendar[] dates = parseDates(segments);
        if (segments[DESC_POS].equals(EMPTY)) {
            throw new NoDescriptionException();
        }
        Calendar[] datesFixed = fixDatesForAdd(dates);
        Calendar remindDate = convertToCalendar(createEmptyDate());
        Command command = new Add(segments[DESC_POS], datesFixed[0], datesFixed[1], 
                                  segments[LOC_POS], remindDate,
                                  segments[PRI_POS]);
        return command;
    }

    private String[] removeKeyWordIfReq(String[] args, boolean isWithKeyWord) {
        if (isWithKeyWord) {
            return (String[]) ArrayUtils.remove(args, 0);
        }
        return args;
    }

    private Command initializeSearch(String[] args) {
        args = (String[]) ArrayUtils.remove(args, 0);
        Command command = getAppropSearchCommand(args);
        return command;
    }

    private Command initializeHome() {
        return new Home();
    }

    private Command initializeViewChange() {
        return new ViewChange();
    }

    private Command initializeDelete(String[] args) {
        args = (String[]) ArrayUtils.remove(args, 0);
        try {
            return getAppropDeleteCommand(args);
        } catch (NumberFormatException e) {
            return getCommandDeleteByName(args);
        }
    }

    private Command initializeUpdate(String[] args) {
        args = (String[]) ArrayUtils.remove(args, 0);
        int taskToUpdate = Integer.parseInt(args[0]);
        args = (String[]) ArrayUtils.remove(args, 0);
        Integer[] indices = getIndices(args);
        String[] segments = getSegments(indices[DATE_IND_POS], indices[LOC_IND_POS], indices[PRI_IND_POS], args);
        Calendar[] dates = parseDates(segments);
        dates = fixDatesForUpdate(dates);
        Calendar remindDate = convertToCalendar(createEmptyDate());
        Command command = new Update(taskToUpdate, segments[DESC_POS], dates[0], dates[1], segments[LOC_POS],
                                     remindDate, segments[PRI_POS]);
        return command;
    }

    private Command initializeDone(String[] args) {
        args = (String[]) ArrayUtils.remove(args, 0);
        try {
            return getAppropDoneCommand(args);
        } catch (NumberFormatException e) {
            return getCommandDoneByName(args);
        }
    }

    private Command initializeUndo() {
        Command command = new Undo();
        return command;
    }

    private Command initializeHelp() {
        Command command = new Help();
        return command;
    }

    private Command initializeSummary() {
        Command command = new Summary();
        return command;
    }

```
###### Fantasktic\src\application\backend\Parser.java
``` java

    private Integer[] getIndices(String[] args) {
        int dateStartIndex = getDateStartIndex(args);
        int locationStartIndex = getLastIndex(LOCATION_MARKERS, args);
        int priorityIndex = getLastIndex(PRIORITY_MARKERS, args);
        priorityIndex = fixPriorityIndex(priorityIndex, args);
        Integer[] indices = new Integer[NUMBER_INDICES];
        indices[DATE_IND_POS] = dateStartIndex;
        indices[LOC_IND_POS] = locationStartIndex;
        indices[PRI_IND_POS] = priorityIndex;
        overrideIfUnixStyleFound(indices, args);
        return indices;
    }

    public void overrideIfUnixStyleFound(Integer[] indices, String[] args) {
        if (getLastIndex(UNIX_MARKERS, args) != NOT_PRESENT) {
            getUnixIndices(indices, args);
        }
    }

    private void getUnixIndices(Integer[] indices, String[] args) {
        for (int i = 0; i < indices.length; i++) {
            indices[i] = NOT_PRESENT;
        }
        List<String> words = Arrays.asList(args);
        getUnixIndices(indices, words);
        if (indices[DATE_IND_POS] != NOT_PRESENT) {
            args[indices[DATE_IND_POS] - 1] = EMPTY; // Setting the unix marker to empty since we dont need it anymore
        }
    }

    private void getUnixIndices(Integer[] indices, List<String> words) {
        indices[DATE_IND_POS] = words.indexOf(UNIX_DATE_MARKER) + 1; // Ignoring the unix marker
        indices[LOC_IND_POS] = words.indexOf(UNIX_LOC_MARKER);
        indices[PRI_IND_POS] = words.indexOf(UNIX_PRI_MARKER);
    }

    private Command getAppropSearchCommand(String[] args) {
        try {
            return getSearchCommand(args);
        } catch (NotDateException e) {
            return getSearchByName(args);
        }

    }

    private Command getSearchCommand(String[] args) throws NotDateException {
        String[] argsForDate = (String[]) ArrayUtils.remove(args, 0);
        if (Arrays.asList(DATE_MARKERS_DEADLINE).contains(args[0].toLowerCase())) {
            return getSearchByDateCommand(argsForDate);
        } else if (Arrays.asList(DATE_MARKERS_FULL_DAY_EVENT).contains(args[0].toLowerCase())) {
            return getSearchOnDateCommand(argsForDate);
        } else if (args.length > 1 && Arrays.asList(PRIORITY_MARKERS).contains(args[0].toLowerCase())
                && Arrays.asList(PRIORITY_LEVELS).contains(args[1].toLowerCase())) {
            return getSearchByPriorityCommand(argsForDate);
        } else
            return getSearchByName(args);
    }

    private Command getSearchByName(String[] args) {
        String taskName = getString(args, 0, args.length - 1);
        Command cmd = new SearchByName(taskName);
        return cmd;
    }

    private Command getSearchOnDateCommand(String[] args) throws NotDateException {
        Calendar date = getDateForSearch(args);
        Command cmd = new SearchOnDate(date);
        return cmd;
    }

    private Command getSearchByDateCommand(String[] args) throws NotDateException {
        Calendar date = getDateForSearch(args);
        Command cmd = new SearchByDate(date);
        return cmd;
    }

    private Command getSearchByPriorityCommand(String[] args) {
        String priority = getString(args, 0, 0);
        Command cmd = new SearchByPriority(priority);
        return cmd;
    }

    private Calendar getDateForSearch(String[] args) throws NotDateException {
        String dateString = getString(args, 0, args.length - 1);
        List<Date> dates1 = dateParser.parse(dateString);
        List<Date> dates2 = dateParser.parse(dateString);
        if (dates1.size() == 0) {
            throw new NotDateException();
        }
        LocalDateTime date = fixDateForSearch(dates1.get(0), dates2.get(0));
        return convertToCalendar(date);
    }

    // If time not specified, setting time to 11:59 PM
    private LocalDateTime fixDateForSearch(Date date1, Date date2) {
        if (date1.equals(date2)) {
            return new LocalDateTime(date1);
        } else {
            LocalDateTime date = new LocalDateTime(date1);
            date = date.withHourOfDay(23);
            date = date.withMinuteOfHour(59);
            date = date.withSecondOfMinute(59);
            return date;
        }
    }

    private Command getAppropDeleteCommand(String[] args) {
        if (args.length == 1) {
            int index = Integer.parseInt(args[0]) - ARRAY_INDEXING_OFFSET;
            Command command = new DeleteByNum(index);
            return command;
        } else {
            return getCommandDeleteByName(args);
        }
    }

    private Command getCommandDeleteByName(String[] args) {
        String taskToDelete = getString(args, 0, args.length - 1);
        Command command = new DeleteByName(taskToDelete);
        return command;
    }

    private Command getAppropDoneCommand(String[] args) {
        if (args.length == 0) {
            return new ShowDoneTasks();
        } else if (args.length == 1) {
            int index = Integer.parseInt(args[0]) - ARRAY_INDEXING_OFFSET;
            Command command = new DoneByNum(index);
            return command;
        } else {
            return getCommandDoneByName(args);
        }
    }

    private Command getCommandDoneByName(String[] args) {
        String taskToDelete = getString(args, 0, args.length - 1);
        Command command = new DoneByName(taskToDelete);
        return command;
    }

    private Calendar[] parseDates(String[] segments) {
        String dateString = segments[DATE_POS];
        dateString = fixDateFormatIfNeeded(dateString);
        String dateTypeKeyword = dateString.split("\\s+")[0];
        List<Date> tempDates1 = dateParser.parse(dateString);
        List<Date> tempDates2 = dateParser.parse(dateString);
        changeSegmentsIfNeeded(segments, tempDates1.size());
        Calendar startDate = getStartDate(dateTypeKeyword, tempDates1, tempDates2);
        Calendar endDate = getEndDate(dateTypeKeyword, tempDates1, tempDates2);
        Calendar[] dates = { startDate, endDate };
        return dates;
    }

    // NLP date parser package only accepts MM/DD/YYYY so fixing format if
    // needed
    private String fixDateFormatIfNeeded(String dateString) {
        String[] parts = dateString.split("\\s+");
        int i = 0;
        for (String part : parts) {
            try {
                changeDateIfInDdMmYyyy(parts, i, part);
            } catch (ParseException e) {
            }
            i++;
        }
        return getString(parts, 0, parts.length - 1);
    }

    // changes date format from dd/mm/yyyy to mm/dd/yyyy if encountered
    private void changeDateIfInDdMmYyyy(String[] parts, int i, String part) throws ParseException {
        DateFormat originalFormat = new SimpleDateFormat("d/M/yyyy");
        DateFormat targetFormat = new SimpleDateFormat("MM/dd/yyyy");
        Date date = originalFormat.parse(part);
        parts[i] = targetFormat.format(date);
    }

    // adding date string to description string if it turns out that date string
    // has no dates
    private void changeSegmentsIfNeeded(String[] segments, int size) {
        if (size == 0) {
            segments[DESC_POS] = segments[DESC_POS].trim() + " " + segments[DATE_POS];
            segments[DESC_POS] = segments[DESC_POS].trim();
        }
    }

    // Getting start date based on which arguments were specified by user
    private Calendar getStartDate(String keyword, List<Date> tempDates1, List<Date> tempDates2) {
        LocalDateTime date;
        if (tempDates1.size() == 0) {
            date = null;
        } else if (tempDates1.size() == 1) {
            date = processSingleDateForStart(keyword, tempDates1, tempDates2);
        } else {
            date = fixTimeInDate(tempDates1.get(0), tempDates2.get(0));
        }
        return convertToCalendar(date);
    }

    private LocalDateTime processSingleDateForStart(String keyword, List<Date> tempDates1, List<Date> tempDates2) {
        LocalDateTime date;
        if (Arrays.asList(DATE_MARKERS_START).indexOf(keyword) != -1) {
            date = fixTimeInDate(tempDates1.get(0), tempDates2.get(0));
        } else if (Arrays.asList(DATE_MARKERS_END).indexOf(keyword) != -1) {
            date = createEmptyDate();
        } else if (Arrays.asList(DATE_MARKERS_FULL_DAY_EVENT).indexOf(keyword) != -1) {
            date = fixTimeInDate(tempDates1.get(0), tempDates2.get(0));
            date = date.withMillisOfDay(0);
        } else {
            date = null;
        }
        return date;
    }

    // Getting end date based on which arguments were specified by user
    private Calendar getEndDate(String keyword, List<Date> tempDates1, List<Date> tempDates2) {
        LocalDateTime date;
        if (tempDates1.size() == 0) {
            date = null;
        } else if (tempDates1.size() == 1) {
            date = processSingleDateForEnd(keyword, tempDates1, tempDates2);
        } else {
            date = fixTimeInDate(tempDates1.get(1), tempDates2.get(1));
        }
        return convertToCalendar(date);
    }

    private LocalDateTime processSingleDateForEnd(String keyword, List<Date> tempDates1, List<Date> tempDates2) {
        LocalDateTime date;
        if (Arrays.asList(DATE_MARKERS_START).indexOf(keyword) != -1) {
            date = createEmptyDate();
        } else if (Arrays.asList(DATE_MARKERS_FULL_DAY_EVENT).indexOf(keyword) != -1) {
            date = fixTimeInDate(tempDates1.get(0), tempDates2.get(0));
            date = date.withTime(23, 59, 59, 999);
        } else {
            date = fixTimeInDate(tempDates1.get(0), tempDates2.get(0));
        }
        return date;
    }

    // fixing dates so that if one of the times in an event was not specified, a
    // default time is used
    private Calendar[] fixDatesForAdd(Calendar[] dates) {
        Calendar startDate = dates[0];
        Calendar endDate = dates[1];
        if (startDate != null) {
            if (startDate.equals(convertToCalendar(createEmptyDate()))) {
                startDate = (Calendar) endDate.clone();
                fixStartDateForAdd(startDate);
            } else if (endDate.equals(convertToCalendar(createEmptyDate()))) {
                endDate = (Calendar) startDate.clone();
                fixEndDateForAdd(endDate);
            }
        }
        Calendar[] fixedDates = { startDate, endDate };
        return fixedDates;
    }

    private void fixEndDateForAdd(Calendar endDate) {
        if (endDate.get(Calendar.MILLISECOND) != EMPTY_TIME) {
            endDate.add(Calendar.HOUR, +DEFAULT_EVENT_DURATION_TIME);
        } else {
            endDate.add(Calendar.DAY_OF_MONTH, +DEFAULT_EVENT_DURATION_DAY);
        }
    }

    private void fixStartDateForAdd(Calendar startDate) {
        if (startDate.get(Calendar.MILLISECOND) != EMPTY_TIME) {
            startDate.add(Calendar.HOUR, -DEFAULT_EVENT_DURATION_TIME);
        } else {
            startDate.add(Calendar.DAY_OF_MONTH, -DEFAULT_EVENT_DURATION_DAY);
        }
    }

    // fixing dates for update so that if no date specified, it is set to empty
    // which can be ignored
    private Calendar[] fixDatesForUpdate(Calendar[] dates) {
        Calendar startDate = dates[0];
        Calendar endDate = dates[1];
        if (endDate == null && startDate == null) {
            endDate = convertToCalendar(createEmptyDate());
            startDate = convertToCalendar(createEmptyDate());
        }
        Calendar[] fixedDates = { startDate, endDate };
        return fixedDates;
    }

    // fixing dates so that unspecified time can be set to empty
    private LocalDateTime fixTimeInDate(Date date1, Date date2) {
        if (date1.equals(date2)) {
            return new LocalDateTime(date1);
        } else {
            LocalDateTime date = new LocalDateTime(date1);
            date = date.withMillisOfDay(1);
            return date;
        }
    }

    private LocalDateTime createEmptyDate() {
        LocalDateTime date = new LocalDateTime();
        date = date.withYear(1);
        date = date.withMillisOfDay(1);
        return date;
    }

    // Convert Joda LocalDateTime object to Calendar object
    private Calendar convertToCalendar(LocalDateTime date) {
        if (date == null) {
            return null;
        }
        Date temp = date.toDate();
        Calendar cal = Calendar.getInstance();
        cal.setTime(temp);
        return cal;
    }

    // Get segments of user input based on keyword indices
    private String[] getSegments(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
        String description = getDescription(dateIndex, locationIndex, priorityIndex, args);
        String date = getDateString(dateIndex, locationIndex, priorityIndex, args);
        String location = getLocationString(dateIndex, locationIndex, priorityIndex, args);
        String priority = getPriority(priorityIndex, args);
        String[] segments = new String[ARGUMENT_NUMBER];
        segments[DESC_POS] = description.trim();
        segments[DATE_POS] = date;
        segments[LOC_POS] = location.trim();
        segments[PRI_POS] = priority.trim();
        return segments;
    }

    private String getPriority(int priorityIndex, String[] args) {
        if (priorityIndex == NOT_PRESENT) {
            return EMPTY;
        } else {
            return args[priorityIndex + 1];
        }
    }

    private String getDescription(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
        String description;
        int end = args.length;
        if (priorityIndex != NOT_PRESENT) {
            end = priorityIndex;
        }
        if (dateIndex == NOT_PRESENT && locationIndex == NOT_PRESENT) {
            description = getString(args, 0, end - 1);
        } else if ((dateIndex < locationIndex || locationIndex == NOT_PRESENT) && dateIndex != NOT_PRESENT) {
            description = getString(args, 0, dateIndex - 1);
        } else {
            description = getString(args, 0, locationIndex - 1);
        }
        return description;
    }

    // makes sure priority is actually specified as an argument and not as part
    // of task description
    private int fixPriorityIndex(int priorityIndex, String[] args) {
        int priorityLevelPosition = priorityIndex + 1;
        List<String> levels = Arrays.asList(PRIORITY_LEVELS);
        if (priorityLevelPosition == args.length) {
            return NOT_PRESENT;
        } else if (!levels.contains(args[priorityLevelPosition].toLowerCase())) {
            return NOT_PRESENT;
        } else {
            return priorityIndex;
        }
    }

    private String getDateString(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
        int end = args.length;
        if (priorityIndex != -1) {
            end = priorityIndex;
        }
        if (dateIndex == -1) {
            return EMPTY;
        } else if (dateIndex < locationIndex) {
            return getString(args, dateIndex, locationIndex - 1);
        } else {
            return getString(args, dateIndex, end - 1);
        }
    }

    private String getLocationString(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
        int end = args.length;
        if (priorityIndex != -1) {
            end = priorityIndex;
        }
        if (locationIndex == -1) {
            return EMPTY;
        } else if (locationIndex < dateIndex) {
            return getString(args, locationIndex + 1, dateIndex - 1);
        } else {
            return getString(args, locationIndex + 1, end - 1);
        }
    }

    private int getDateStartIndex(String[] args) {
        ArrayList<Integer> indices = new ArrayList<Integer>();
        int eventDateIndex = getLastIndex(DATE_MARKERS_START, args);
        if (eventDateIndex == -1) {
            indices.add(getLastIndex(DATE_MARKERS_END, args));
        } else {
            indices.add(eventDateIndex);
        }
        indices.add(getLastIndex(DATE_MARKERS_DEADLINE, args));
        indices.add(getLastIndex(DATE_MARKERS_FULL_DAY_EVENT, args));
        int dateIndex = (int) Collections.max(indices);
        return dateIndex;
    }

    /* 
     * Gets last index of any one of an array of keywords, in an array of users
     * command words
     */
    private static int getLastIndex(String[] keywords, String[] commandWords) {
        int[] positions = new int[keywords.length];
        String[] commandLowerCase = new String[commandWords.length];
        for (int i = 0; i < commandWords.length; i++) {
            commandLowerCase[i] = commandWords[i].toLowerCase();
        }
        for (int i = 0; i < keywords.length; i++) {
            positions[i] = Arrays.asList(commandLowerCase).lastIndexOf(keywords[i].toLowerCase());
        }
        List<Integer> list = Arrays.asList(ArrayUtils.toObject(positions));
        return ((int) Collections.max(list));
    }

    /*
     * Makes a single string from a String[] from start position to end position
     * in the array
     */
    private String getString(String[] args, int start, int end) {
        String string = EMPTY;
        for (int i = start; i <= end; i++) {
            string = string + args[i] + " ";
        }
        return string.trim();
    }

    private void checkForError(String userCommand) /* throws Error */ {
        if (userCommand == null) {
            logger.severe("null user commands");
            throw new Error(MESSAGE_NULL_ERROR);
        }
    }

}
```
###### Fantasktic\src\application\backend\ShowDoneTasks.java
``` java

import java.util.ArrayList;

import application.storage.Task;

/**
 * This class is a Command object which shows the user all his completed tasks. 
 * Check Command class documentation for insight on
 * what the public methods do.
 * 
 * @author Pratyush
 *
 */
public class ShowDoneTasks implements Command{

    private static final String MESSAGE_CLOSED = "Here are the tasks you have closed.";
    private static final String MESSAGE_NO_CLOSED = "You have not closed any tasks.";
    
    @Override
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
        ArrayList<Task> tasks = storageConnector.getClosedList();
        return createAppropFeedback(storageConnector, tasks);
    }
    
    private Feedback createAppropFeedback(StorageConnector storageConnector, ArrayList<Task> tasks){
        if (tasks.size() == 0){
            return getFeedbackCal(MESSAGE_NO_CLOSED, storageConnector.getOpenList(), null);
        } else{
            Feedback fb = new Feedback(MESSAGE_CLOSED, tasks, null);
            fb.setListFlag();
            return fb;
        }
    }
    
    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
}
```
###### Fantasktic\src\application\backend\StorageConnector.java
``` java
/**
 * This class serves as a connector between backend and storage. All requests to
 * storage from the backend package are routed through this class.
 * 
 * @author Pratyush
 *
 */

public class StorageConnector {
    Storage storage = new Storage();

    public StorageConnector() {
    }

    // For testing purposes
    protected StorageConnector(Storage storage) {
        this.storage = storage;
    }

    public String setDirectory(String filePath) throws IOException {
        String prevPath = storage.setDirectory(filePath);
        assert (prevPath != null);
        return prevPath;
    }

    public void initialise() throws IOException {
        storage.initialise();
    }

    public ArrayList<Task> getOpenList() {
        ArrayList<Task> tasks = storage.getOpenList();
        assert (tasks != null);
        return tasks;
    }

    public boolean directoryExists() throws IOException {
        return storage.directoryExists();
    }

    public Task addTaskInList(String description, Calendar startDateTime, 
                              Calendar endDateTime, String location,
                              Calendar remindDate, String priority) throws IOException {
        Task addedTask = storage.addTaskInList(description, startDateTime, endDateTime, location, remindDate, priority);
        assert (addedTask != null);
        return addedTask;
    }

    public Task deleteTask(int index) throws IOException {
        Task deletedTask = storage.deleteTask(index);
        assert (deletedTask != null);
        return deletedTask;
    }

    public ArrayList<Task> searchTaskByName(String taskToDelete) {
        ArrayList<Task> tasks = storage.searchTaskByName(taskToDelete);
        assert (tasks != null);
        return tasks;
    }

    public Task uncloseTask(int index) throws IOException {
        Task task = storage.uncloseTask(index);
        assert (task != null);
        return task;
    }

    public Task closeTask(int index) throws IOException {
        Task task = storage.closeTask(index);
        assert (task != null);
        return task;
    }

    public ArrayList<Task> searchTaskByDate(Calendar date) {
        ArrayList<Task> tasks = storage.searchTaskByDate(date);
        assert (tasks != null);
        return tasks;
    }

    public ArrayList<Task> searchTaskByPriority(String priority) {
        ArrayList<Task> tasks = storage.searchTaskByPriority(priority);
        assert (tasks != null);
        return tasks;
    }

    public ArrayList<Task> searchTaskOnDate(Calendar date) {
        ArrayList<Task> tasks = storage.searchTaskOnDate(date);
        assert (tasks != null);
        return tasks;
    }

    public ArrayList<Task> getClosedList() {
        ArrayList<Task> closedTasks = storage.getCloseList();
        assert (closedTasks != null);
        return closedTasks;
    }

    public ArrayList<Task> updateTask(int idTaskToDelete, String description, 
                                      Calendar startDateTime, Calendar endDateTime, 
                                      String location, Calendar remindDate, String priority)
                                      throws IOException, CloneNotSupportedException {
        ArrayList<Task> tasks = storage.updateTask(idTaskToDelete, description, 
                                                   startDateTime, endDateTime, location,
                                                   remindDate, priority);
        assert (tasks != null);
        return tasks;
    }

}
```
###### Fantasktic\src\application\backend\Undo.java
``` java

import java.util.ArrayList;
import java.util.EmptyStackException;

import application.storage.Task;

/**
 * This class is an Command object which undoes the previous command. Check
 * Command class documentation for insight on what the public methods do.
 * 
 * @author Pratyush
 *
 */
public class Undo implements Command {
    private static final String MESSAGE_NOTHING_TO_UNDO = "There are no commands left to undo!";

    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
        try {
            History history = History.getInstance();
            return history.undo();
        } catch (EmptyStackException e) {
            return getFeedbackCal(MESSAGE_NOTHING_TO_UNDO, storageConnector.getOpenList(), null);
        }
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
}
```
###### Fantasktic\src\application\backend\UndoableCommand.java
``` java

import java.util.ArrayList;

import application.storage.Task;

/**
 * This is an interface class for all UndoableCommand objects. This extends the
 * command object class, and command objects implementing this interface have
 * the added feature of being undoable.
 * 
 * @author Pratyush
 *
 */

public interface UndoableCommand extends Command {

    /**
     * This method is implemented by each command object. Logic can simply call
     * this method to execute that particular command object.
     * 
     * @param storageConnector
     *            The StorageConnector object reference should be passed to this
     *            method.
     * @param tasksOnScreen
     *            An ArrayList of Tasks that are currently being displayed
     *            should be passed to this.
     * @return A feedback object containing the specific information of the
     *         particular execution.
     */
    @Override
    Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks);

    /**
     * This command undoes this particular command object.
     * 
     * @return A feedback object containing the specific information with the
     *         particular undoing of the command.
     * @throws NothingToUndoException
     *             This exception is thrown to signify that this particular
     *             command object does not yet have anything to undo. This
     *             allows the command object to be skipped.
     */
    Feedback undo() throws NothingToUndoException;
}
```
###### Fantasktic\src\application\backend\Update.java
``` java

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Task;

/**
 * This class is an UndoableCommand object which updates a task based on user
 * input. Check UndoableCommand documentation for more insight on what the
 * public methods do.
 * 
 * @author Pratyush
 *
 */

public class Update implements UndoableCommand {
    public static final int NOT_FOUND = -1;
    public static final int INDEX_TASK_POSITION = 0;
    public static final int INDEX_UPDATED_TASK = 1;
    public static final int INDEX_ORIGINAL_TASK = 0;
    public static final int ARRAY_INDEXING_OFFSET = 1;
    public static final String EMPTY = "";
    private static final String MESSAGE_UPDATE_ERROR = "We encountered an error while updating the task. Sorry for the inconvenience.";
    private static final String MESSAGE_UPDATE_FEEDBACK = "Updated Task: %1$s";
    private static final String MESSAGE_UNDO_FEEDBACK = "Reverted: %1$s";
    private static final String MESSAGE_UNDO_FAILURE = "We encountered an error while undoing.";
    private static final String MESSAGE_INDEX_ERROR = "Please enter a valid task number.";

    Task origTask;
    Task updatedTask;
    StorageConnector storageConnector;

    private int taskPosition = -1;
    private String description = EMPTY;
    private Calendar startDateTime;
    private Calendar endDateTime;
    private String location = EMPTY;
    private Calendar remindDate;
    private String priority = EMPTY;

    Update(int taskPosition, String description, Calendar start, Calendar end, String location, Calendar remindDate,
            String priority) {
        this.taskPosition = taskPosition - ARRAY_INDEXING_OFFSET;
        this.description = description;
        this.startDateTime = start;
        this.endDateTime = end;
        this.location = location;
        this.remindDate = remindDate;
        this.priority = priority;
    }

    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
        try {
            return updateTask(storageConnector, tasks);
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_UPDATE_ERROR, storageConnector.getOpenList(), null);
        } catch (CloneNotSupportedException e) {
            return getFeedbackCal(MESSAGE_UPDATE_ERROR, storageConnector.getOpenList(), null);
        } catch (IndexOutOfBoundsException e) {
            return getFeedbackCal(MESSAGE_INDEX_ERROR, storageConnector.getOpenList(), null);
        }
    }

    private Feedback updateTask(StorageConnector storageConnector, ArrayList<Task> tasks)
            throws IOException, CloneNotSupportedException {
        this.storageConnector = storageConnector;
        int idTaskToDelete = tasks.get(taskPosition).getTaskIndex();
        ArrayList<Task> returnedTasks = storageConnector.updateTask(idTaskToDelete, description, 
                                            startDateTime, endDateTime, location, remindDate, 
                                            priority);
        origTask = returnedTasks.get(INDEX_ORIGINAL_TASK);
        updatedTask = returnedTasks.get(INDEX_UPDATED_TASK);
        String feedbackMessage = String.format(MESSAGE_UPDATE_FEEDBACK, "From: " 
                                                + origTask.toString() + "\n" + "To: " 
                                                + updatedTask.toString());
        return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), updatedTask);
    }

    public Feedback undo() {
        try {
            return revertBack();
        } catch (IOException e) {
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        } catch (CloneNotSupportedException e) {
            return getFeedbackCal(MESSAGE_UNDO_FAILURE, storageConnector.getOpenList(), null);
        }
    }

    private Feedback revertBack() throws IOException, CloneNotSupportedException {
        ArrayList<Task> returnedTasks = storageConnector.updateTask(updatedTask.getTaskIndex(),
                                           origTask.getTaskDescription(), origTask.getStartDate(), 
                                           origTask.getEndDate(), origTask.getLocation(),
                                           origTask.getRemindDate(), origTask.getPriority());
        origTask = returnedTasks.get(INDEX_ORIGINAL_TASK);
        updatedTask = returnedTasks.get(INDEX_UPDATED_TASK);
        String feedbackMessage = String.format(MESSAGE_UNDO_FEEDBACK, "From: " 
                                                + origTask.toString() + "\n" + "To: " 
                                                + updatedTask.toString());
        return getFeedbackList(feedbackMessage, storageConnector.getOpenList(), updatedTask);
    }

    private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }

    private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task) {
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }

}
```
###### Fantasktic\src\application\backend\ViewChange.java
``` java

import java.util.ArrayList;

import application.storage.Task;

/**
 * This class is an Command object which allows the user to change his view in
 * the gui.
 * 
 * @author Pratyush
 *
 */
public class ViewChange implements Command {

    private static final String MESSAGE_LIST = "Here are your tasks.";

    @Override
    public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
        Feedback feedback = new Feedback(MESSAGE_LIST, tasksOnScreen, null);
        feedback.setViewChangeFlag();
        return feedback;
    }

}
```
###### Fantasktic\src\application\gui\application.css
``` css

.list-cell{
    -fx-cell-hover-color: #80DEEA;
    -fx-background-color: white;
}

```
###### Fantasktic\src\application\gui\ListItem.java
``` java
	private static final String BACKGROUND_STYLE = "-fx-background-color: %1$s;";
	private static final String FONT_STYLE = "-fx-text-fill: %1$s;";
	private static final String RED = "#EF9A9A";
	private static final String GREEN = "#A5D6A7";
	private static final String BLUE = "#B2EBF2";
	private static final String DARK_RED = "#B71C1C";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	// FXML variables
	@FXML
	public Label listNumber;
	@FXML
	private Label taskName;
	@FXML
	private Label date;
	@FXML
	private Label taskLocation;

	public ListItem(int taskNumber, String name, String date, String location, String taskPriority, int overdueCheck) {
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(LIST_ITEM_FXML_URL));
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
			this.setLabels(taskNumber, name, date, location, taskPriority, overdueCheck);
		} catch (IOException exception) {
			logger.severe(FXML_LOAD_FAILED_MSG);
			try {
				throw new ExceptionHandler(FXML_LOAD_FAILED_MSG);
			} catch (ExceptionHandler e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

	}

	private void setLabels(int taskNumber, String name, String date, String location, String taskPriority,
			int overdueCheck) {
		listNumber.setText(EMPTY + taskNumber);
		setBackground(taskPriority);
		taskName.setText(name.toUpperCase());
		this.date.setText(date.toUpperCase());
		setLocation(location.trim().toUpperCase());
		overdueCheck(overdueCheck);
	}

	private void setLocation(String location) {
		if (!location.equals(EMPTY)) {
			this.taskLocation.setText(location);
		}
	}

```
###### Fantasktic\src\application\gui\MainPage.java
``` java
    // Constructor for MainPage
    public MainPage(ArrayList<Task> taskList, BackendFacade backendFacade) {
        tasksOnScreen = taskList;
        this.backendFacade = backendFacade;
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(MAIN_PAGE_FXML_URL));
        loadFromFxml(fxmlLoader);
        initialize();
        initializeInputArea();
    }

    // Loading elements from FXML
    private void loadFromFxml(FXMLLoader fxmlLoader) {
        try {
            fxmlLoader.setRoot(this);
            fxmlLoader.setController(this);
            fxmlLoader.load();
        } catch (IOException exception) {
            logger.severe(FXML_LOAD_FAILED);
            throw new RuntimeException(exception);
        }
    }

    // Initialising values of elements
    private void initialize() {
        helpLabel.setText(MESSAGE_HELP_INTRO);
        feedbackLabel.setText(MESSAGE_FEEDBACK_INTRO);
        initialiseCalendarList();
        initialiseDisplayList();
        taskToFocus = null;
        initializeHiddenPanel();
        updateViews(tasksOnScreen, taskToFocus);
    }

```
###### Fantasktic\src\application\storage\StorageStubForBackend.java
``` java
import java.util.ArrayList;
import java.util.Calendar;
/**
 * This stub is used for dependency injection needed by the backend package
 * @author Pratyush
 *
 */
public class StorageStubForBackend extends Storage {
    ArrayList<Task> tasks = new ArrayList<Task>();
    private int size;
    public StorageStubForBackend(int size) {
        this.size = size;
        createListForTest(size);
    }
    
    //To create a list for testing. Making logic isolated from actual storage while testing.
    public void createListForTest(int numTasks){
        tasks.clear();
        for (int i = 1; i <= numTasks ; i++){
            Task task = new EventTask("Task " + i , Calendar.getInstance(), Calendar.getInstance(), "Test House", Calendar.getInstance(), "LOW", i);
            task.getStartDate().add(Calendar.HOUR_OF_DAY, 4);
            task.getEndDate().add(Calendar.HOUR_OF_DAY, 4);
            tasks.add(task);
        }
        tasks.get(size/2).setPriority("HIGH");//To test for searchByPriority
    }
    
    @Override
    public ArrayList<Task> getOpenList(){
        createListForTest(size);
        return tasks;
    }
    
    @Override
    public Task addTaskInList(String description, Calendar startDateTime
            ,Calendar endDateTime, String location, Calendar remindDate,String priority){
        createListForTest(size);
        Task task;
        if (startDateTime == null && endDateTime == null){
            task = new FloatingTask(description, location, remindDate, priority, tasks.size() + 1);
        } else if (startDateTime == null){
            task = new DeadlineTask(description,endDateTime, location, remindDate, priority, tasks.size() + 1);
        } else{
            task = new EventTask(description, startDateTime,endDateTime,location,remindDate, priority, tasks.size() + 1);
        }
        return task;
    }
    
    @Override
    public Task deleteTask(int index){
        createListForTest(size);
        return getTaskById(index);
    }
    
    @Override
    public Task closeTask(int index){
        createListForTest(size);
        return getTaskById(index);
    }
    
    @Override
    public ArrayList<Task> updateTask(int idTaskToDelete, String description, 
            Calendar startDateTime, Calendar endDateTime
            ,String location
            , Calendar remindDate, String priority){
        createListForTest(size);
        Task task = getTaskById(idTaskToDelete);
        task.setTaskDescription(description);
        ArrayList<Task> tasksFromUpdate = new ArrayList<Task>();
        tasksFromUpdate.add(task);
        tasksFromUpdate.add(task);
        return tasksFromUpdate;
    }
    
    @Override
    public ArrayList<Task> searchTaskByName(String name){
        createListForTest(size);
        ArrayList<Task> matches = new ArrayList<Task>();
        for (Task task: tasks){
            if (task.getTaskDescription().contains(name)){
                matches.add(task);
            }
        }
        return matches;
    }
    
    @Override
    public ArrayList<Task> searchTaskByPriority(String priority){
        createListForTest(size);
        ArrayList<Task> matches = new ArrayList<Task>();
        for (Task task: tasks){
            if (task.getPriority().equalsIgnoreCase(priority)){
                matches.add(task);
            }
        }
        return matches;
    }
    
    private Task getTaskById(int id){
        for (Task task: tasks){
            if (task.getTaskIndex() == id){
                return task;
            }
        }
        return new EventTask("NO MATCH FOUND", Calendar.getInstance(), Calendar.getInstance(), "Could not find", Calendar.getInstance(), "", -1);
    }
}
```
