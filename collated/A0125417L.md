# A0125417L
###### Fantasktic\bin\application\gui\application.css
``` css

.list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button, 
.list-view .scroll-bar:vertical .increment-arrow,
.list-view .scroll-bar:vertical .decrement-arrow,
.list-view .scroll-bar:vertical .increment-button,
.list-view .scroll-bar:vertical .decrement-button{
    -fx-padding:0.0;
}

.data0.chart-pie { 
	-fx-pie-color: #C8E6C9;
}

.data1.chart-pie { 
	-fx-pie-color: #B2EBF2;
}

.data2.chart-pie { 
	-fx-pie-color: #B71C1C;
}

.displayList .list-cell:filled:selected:focused {
    -fx-background-color: #00acc1;
    -fx-text-fill: white;
}

.displayList .list-cell:filled:selected{
    -fx-background-color: #F44336;
    -fx-text-fill: white;
}

.calendarItem .list-cell:filled:selected:focused {
    -fx-background-color: #00acc1;
    -fx-text-fill: white;
}

.calendarItem .list-cell:filled:selected{
    -fx-background-color: #F44336;
    -fx-text-fill: white;
}
```
###### Fantasktic\src\application\backend\ChangeStorageLocation.java
``` java
package application.backend;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Logger;
import application.gui.ExceptionHandler;
import application.logger.LoggerHandler;
import application.storage.Task;

/*
 * Checks if URL exists and change directory or sends back a flag for gui to prompt user with a directory prompt
 */

public class ChangeStorageLocation implements UndoableCommand {

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	// Logger Messages
	private static final String ENTER_CHANGE_STORAGE_LOGGER_MSG = "Executing change storage function";

	// Exception Messages
	private static final String CHANGE_DIRECTORY_EXCEPTION_MESSAGE = "Failed to change directory";

	// Formatting
	private static final String BACKSLASHS = "\\\\";
	private static final String SLASH = "/";
	private static final String EMPTY_STRING = "";
	private static final String BACKSLASH = "\\";

	// Messages
	private static final String MESSAGE_STORAGE_URL_NOT_FOUND = "Storage Location Invalid: Opening Directory Chooser";
	private static final String MESSAGE_STORAGE_NO_INPUT = "No Location Input: Opening Directory Chooser";
	private static final String MESSAGE_STORAGE_URL_FOUND = "Storage Location Changed To: ";

	private static final String MESSAGE_UNDO_CHANGE = "Reverted Storage Location To: ";
	private static final String MESSAGE_UNDO_ERROR = "We encountered some problem undoing the storage change.";

	// Variables
	private String arguments;
	private String prevLocation;
	private StorageConnector storageConnector;

	ChangeStorageLocation(String arguments) {
		this.arguments = arguments;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
		logger.info(ENTER_CHANGE_STORAGE_LOGGER_MSG);
		this.storageConnector = storageConnector;
		Feedback feedback = null;
		feedback = checkUrlInput(storageConnector, tasksOnScreen, feedback);
		return feedback;
	}

	/*
	 * Check if user has input a directory or not
	 */
	private Feedback checkUrlInput(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen,
			Feedback feedback) {
		if (arguments != EMPTY_STRING) {
			arguments = arguments.replaceAll(SLASH, BACKSLASHS);
			feedback = checkUrlExist(storageConnector, tasksOnScreen, feedback);
		} else {
			assert (arguments == EMPTY_STRING);
			feedback = noInput(tasksOnScreen);
		}
		return feedback;
	}

	/*
	 * Checks if the input is an actual file directory
	 */
	private Feedback checkUrlExist(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen,
			Feedback feedback) {
		if (new File(arguments).isDirectory()) {
			feedback = validDirectoryFound(storageConnector, tasksOnScreen, feedback);
		} else {
			assert (!new File(arguments).isDirectory());
			feedback = invalidDirectoryFound(tasksOnScreen);
		}
		return feedback;
	}

	/*
	 * If input is a valid directory, execute the change storage functions
	 */
	private Feedback validDirectoryFound(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen,
			Feedback feedback) {
		try {
			prevLocation = storageConnector.setDirectory(arguments + BACKSLASH);
			feedback = validDirectoryFound(tasksOnScreen);
		} catch (IOException e) {
			try {
				logger.severe(CHANGE_DIRECTORY_EXCEPTION_MESSAGE);
				throw new ExceptionHandler(CHANGE_DIRECTORY_EXCEPTION_MESSAGE);
			} catch (ExceptionHandler e1) {
				e1.printStackTrace();
			}
		}
		return feedback;
	}

	/*
	 * Create feedback when user did not input a directory path
	 */
	private Feedback noInput(ArrayList<Task> tasksOnScreen) {
		Feedback feedback;
		feedback = new Feedback(MESSAGE_STORAGE_NO_INPUT, tasksOnScreen, null);
		feedback.setStorageFlag();
		return feedback;
	}

	/*
	 * Create feedback when user inputs an invalid directory path
	 */
	private Feedback invalidDirectoryFound(ArrayList<Task> tasksOnScreen) {
		Feedback feedback;
		feedback = new Feedback(MESSAGE_STORAGE_URL_NOT_FOUND, tasksOnScreen, null);
		feedback.setStorageFlag();
		return feedback;
	}

	/*
	 * Create feedback when user inputs a valid directory path
	 */
	private Feedback validDirectoryFound(ArrayList<Task> tasksOnScreen) {
		Feedback feedback;
		feedback = new Feedback(MESSAGE_STORAGE_URL_FOUND + arguments + BACKSLASH, tasksOnScreen, null);
		feedback.setCalFlag();
		return feedback;
	}

```
###### Fantasktic\src\application\backend\Exit.java
``` java
package application.backend;

import java.util.ArrayList;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import application.storage.Task;

/*
 * Exits Program
 */

public class Exit implements Command {

	// Logger Messages
	private static final String LOGGER_EXIT_MSG = "Exiting through exit command";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		logger.info(LOGGER_EXIT_MSG);
		System.exit(0);
		return null;
	}
}
```
###### Fantasktic\src\application\backend\Logic.java
``` java
	/*
	 * Sets directory of files
	 */
	public void setDirectory(String file) throws IOException {
		storageConnector.setDirectory(file);
	}

	/*
	 * Load current tasks
	 */
	public ArrayList<Task> loadDataFile() throws IOException {
		storageConnector.initialise();
		return storageConnector.getOpenList();
	}

	/*
	 * if false means user first time starting program
	 */
	public boolean checkIfFileExists() throws IOException {
		return storageConnector.directoryExists();
	}

	/*
	 * Returns number of completed tasks
	 */
	public int getCompletedTaskCount() {
		return storageConnector.getClosedList().size();
	}

	/*
	 * Returns number of remaining tasks
	 */
	public int getRemainingTaskCount() {
		int remainingTask = storageConnector.getOpenList().size() - getOverdueTaskCount();
		return remainingTask;
	}

	/*
	 * Returns number of overdue tasks
	 */
	public int getOverdueTaskCount() {
		int overdueCount = START_COUNT;
		ArrayList<Task> taskList = storageConnector.getOpenList();
		Calendar cal = Calendar.getInstance();
		overdueCount = countOverdue(overdueCount, taskList, cal);
		return overdueCount;
	}

	/*
	 * Counts number of overdue tasks
	 */
	private int countOverdue(int overdueCount, ArrayList<Task> taskList, Calendar cal) {
		for (Task task : taskList) {
			if (!(task instanceof EventTask)) {
				overdueCount = checkOverdueNonEventTask(overdueCount, cal, task);
			} else {
				overdueCount = checkEventTaskOverdue(overdueCount, cal, task);
			}
		}
		return overdueCount;
	}

	/*
	 * Get overdue count for non event tasks
	 */
	private int checkOverdueNonEventTask(int overdueCount, Calendar cal, Task task) {
		if (task.getEndDate() != null) {
			if (task.getEndDate().getTime().compareTo(cal.getTime()) < OVERDUE_CHECK_VARIABLE) {
				overdueCount++;
			}
		}
		return overdueCount;
	}

	/*
	 * Get overdue count for event tasks
	 */
	private int checkEventTaskOverdue(int overdueCount, Calendar cal, Task task) {
		assert (task instanceof EventTask);
		if (task.getStartDate() != null) {
			if (task.getStartDate().getTime().compareTo(cal.getTime()) < OVERDUE_CHECK_VARIABLE) {
				overdueCount++;
			}
		}
		return overdueCount;
	}
}
```
###### Fantasktic\src\application\backend\LogicStorageIntegrationTester.java
``` java
package application.backend;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import java.io.IOException;
import java.util.ArrayList;
import org.junit.Before;
import org.junit.Test;
import application.storage.Task;

/**
 * 
 * Integration Test starting from Logic all the way to storage. Delete all data
 * in TaskerData.txt or run the gui and delete all data before testing
 *
 */

public class LogicStorageIntegrationTester {
	// Constants
	private static final int EMPTY = 0;

	// Initialization
	private Logic logic = new Logic();

	public ArrayList<Task> initilaiseLoad() throws IOException {
		return logic.loadDataFile();
	}

	@Before
	@Test
	public void beforeTestLoad() throws IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		assertTrue(tasklist.size() >= EMPTY);
	}

	@Test
	public void testAddDelete() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dota from 18 december 1pm to 2pm at home", tasklist);
		assertEquals("Added Task: \"play dota 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority low\"",
				fb.getMessage());
		assertEquals("play dota", tasklist.get(0).getTaskDescription());
		assertEquals("home", tasklist.get(0).getLocation());
		assertEquals("Sun Dec 18 13:00:00 SGT 2016", tasklist.get(0).getStartDate().getTime().toString());
		assertEquals("Sun Dec 18 14:00:00 SGT 2016", tasklist.get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("delete 1", fb.getTasks());
		assertEquals("Deleted Task: \"play dota 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority low\"",
				fb.getMessage());
	}

	@Test
	public void testAddUndo() throws IOException, NoDescriptionException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dota from 18 december 1pm to 2pm at home", tasklist);
		assertEquals("Added Task: \"play dota 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority low\"",
				fb.getMessage());
		fb = logic.executeCommand("delete 1", fb.getTasks());
		assertTrue(fb.getTasks().size() == 0);
		fb = logic.executeCommand("undo", fb.getTasks());
		assertTrue(fb.getTasks().size() == 1);
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testDeleteUndo() throws IOException, NoDescriptionException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dota from 18 december 1pm to 2pm at home", tasklist);
		assertEquals("Added Task: \"play dota 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority low\"",
				fb.getMessage());
		fb = logic.executeCommand("undo", fb.getTasks());
		assertTrue(fb.getTasks().size() == 0);
	}

	@Test
	public void testDeleteFail() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dota from 18 december 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("delete 0", fb.getTasks());
		assertEquals("Please enter a valid number.", fb.getMessage());
		assertTrue(tasklist.size() == 1);
		logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testSearch() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dota from 18 december 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", fb.getTasks());
		fb = logic.executeCommand("search dota", fb.getTasks());
		assertEquals(fb.getMessage(), "Here are the results of your search! Use home command to view all tasks!");
		assertTrue(fb.getTasks().size() == 1);
		assertEquals("play dota", fb.getTasks().get(0).getTaskDescription());
		assertEquals("home", fb.getTasks().get(0).getLocation());
		assertEquals("Sun Dec 18 13:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Sun Dec 18 14:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("search by 30/6/2016", fb.getTasks());
		assertTrue(fb.getTasks().size() == 1);
		fb = logic.executeCommand("search on 30/6/2016", fb.getTasks());
		assertEquals(fb.getMessage(), "Search Not Found");
		fb = logic.executeCommand("delete 1", fb.getTasks());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testSearchBy() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dota from 18 december 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", fb.getTasks());
		fb = logic.executeCommand("search by 28/12/2016", fb.getTasks());
		assertTrue(fb.getTasks().size() == 2);
		assertEquals("play dota", fb.getTasks().get(1).getTaskDescription());
		assertEquals("home", fb.getTasks().get(1).getLocation());
		assertEquals("Sun Dec 18 13:00:00 SGT 2016", fb.getTasks().get(1).getStartDate().getTime().toString());
		assertEquals("Sun Dec 18 14:00:00 SGT 2016", fb.getTasks().get(1).getEndDate().getTime().toString());
		assertEquals("play dot", fb.getTasks().get(0).getTaskDescription());
		assertEquals("home", fb.getTasks().get(0).getLocation());
		assertEquals("Fri Apr 01 13:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Fri Apr 01 14:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("delete 1", fb.getTasks());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testSearchOn() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dota from 18 december 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", fb.getTasks());
		fb = logic.executeCommand("search dota", fb.getTasks());
		fb = logic.executeCommand("search on 30/6/2016", fb.getTasks());
		assertEquals(fb.getMessage(), "Search Not Found");
		fb = logic.executeCommand("search on 18 december", fb.getTasks());
		assertTrue(fb.getTasks().size() == 1);
		fb = logic.executeCommand("delete 1", fb.getTasks());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testUpdate() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("update 1 play dota", fb.getTasks());
		assertEquals("Updated Task: From: \"play dot 1 Apr 2016 1:00 PM to 2:00 PM, at home. Priority high\""
				+ "\nTo: \"play dota 1 Apr 2016 1:00 PM to 2:00 PM, at home. Priority high\"", fb.getMessage());
		assertEquals("play dota", fb.getTasks().get(0).getTaskDescription());
		assertEquals("home", fb.getTasks().get(0).getLocation());
		assertEquals("Fri Apr 01 13:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Fri Apr 01 14:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testUpdatePriority() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dot from 18 dec 1pm to 2pm at home", tasklist);
		assertEquals("low", fb.getTasks().get(0).getPriority());
		fb = logic.executeCommand("update 1 priority high", fb.getTasks());
		assertEquals("Updated Task: From: \"play dot 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority low\""
				+ "\nTo: \"play dot 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority high\"", fb.getMessage());
		assertEquals("play dot", fb.getTasks().get(0).getTaskDescription());
		assertEquals("home", fb.getTasks().get(0).getLocation());
		assertEquals("Sun Dec 18 13:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Sun Dec 18 14:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		assertEquals("high", fb.getTasks().get(0).getPriority());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testUpdateDate() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dot from 18 dec 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("update 1 from 19 dec 2pm to 3pm", fb.getTasks());
		assertEquals("Updated Task: From: \"play dot 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority low\""
				+ "\nTo: \"play dot 19 Dec 2016 2:00 PM to 3:00 PM, at home. Priority low\"", fb.getMessage());
		assertEquals("play dot", fb.getTasks().get(0).getTaskDescription());
		assertEquals("home", fb.getTasks().get(0).getLocation());
		assertEquals("Mon Dec 19 14:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Mon Dec 19 15:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testUpdateLocation() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dot from 18 dec 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("update 1 at nus", fb.getTasks());
		assertEquals("Updated Task: From: \"play dot 18 Dec 2016 1:00 PM to 2:00 PM, at home. Priority low\""
				+ "\nTo: \"play dot 18 Dec 2016 1:00 PM to 2:00 PM, at nus. Priority low\"", fb.getMessage());
		assertEquals("play dot", fb.getTasks().get(0).getTaskDescription());
		assertEquals("nus", fb.getTasks().get(0).getLocation());
		assertEquals("Sun Dec 18 13:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Sun Dec 18 14:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testUpdateUndo() throws IOException, NoDescriptionException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("update 1 play dota", fb.getTasks());
		assertEquals("Updated Task: From: \"play dot 1 Apr 2016 1:00 PM to 2:00 PM, at home. Priority high\""
				+ "\nTo: \"play dota 1 Apr 2016 1:00 PM to 2:00 PM, at home. Priority high\"", fb.getMessage());
		assertEquals("play dota", fb.getTasks().get(0).getTaskDescription());
		assertEquals("home", fb.getTasks().get(0).getLocation());
		assertEquals("Fri Apr 01 13:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Fri Apr 01 14:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("undo", fb.getTasks());
		assertEquals("play dot", fb.getTasks().get(0).getTaskDescription());
		assertEquals("home", fb.getTasks().get(0).getLocation());
		assertEquals("Fri Apr 01 13:00:00 SGT 2016", fb.getTasks().get(0).getStartDate().getTime().toString());
		assertEquals("Fri Apr 01 14:00:00 SGT 2016", fb.getTasks().get(0).getEndDate().getTime().toString());
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}

	@Test
	public void testDone() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("done 1", fb.getTasks());
		assertTrue(fb.getTasks().size() == 0);
	}

	@Test
	public void testDoneUndo() throws IOException, NoDescriptionException {
		ArrayList<Task> tasklist = initilaiseLoad();
		Feedback fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("done 1", fb.getTasks());
		assertTrue(fb.getTasks().size() == 0);
		fb = logic.executeCommand("undo", fb.getTasks());
		assertTrue(fb.getTasks().size() == 1);
		fb = logic.executeCommand("delete 1", fb.getTasks());
	}
}
```
###### Fantasktic\src\application\backend\Parser.java
``` java
    /* 
     * Requests the logic to call for new storage location from the GUI then sends the data to Storage
     */
    private Command initializeStorageLocation(String[] args) {
        Command command = null;
        if (args.length == STORAGE_CHANGE_LIMIT) {
            command = new ChangeStorageLocation(args[SECOND_WORD]);
        } else {
            assert (args.length != STORAGE_CHANGE_LIMIT);
            command = new ChangeStorageLocation(EMPTY);
        }
        return command;
    }

    /* 
     * Requests the logic to call for exit command
     */
    private Command initializeExit() {
        Command command = new Exit();
        return command;
    }

```
###### Fantasktic\src\application\backend\SearchByDate.java
``` java
package application.backend;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import application.storage.Task;

/**
 * 
 * Class to search by date
 *
 */

public class SearchByDate implements Command {

	// Logger Messages
	private static final String EXECUTE_SEARCH_BY_DATE_LOGGER_MSG = "Executing search by date function";

	// Constants
	private static final int EMPTY = 0;

	// Messages
	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search! Use home command to view all tasks!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	// Variables
	private Calendar date;
	private ArrayList<Task> taskList;

	SearchByDate(Calendar date) {
		this.date = date;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		logger.info(EXECUTE_SEARCH_BY_DATE_LOGGER_MSG);
		taskList = storageConnector.searchTaskByDate(date);
		return checkIfListEmpty(storageConnector);
	}

	/*
	 * Check if list is empty
	 */
	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList.size() != EMPTY) {
			return searchFound(MESSAGE_SEARCH_RESULTS, taskList, null);
		} else {
			assert (taskList.size() == EMPTY);
			return searchNotFound(storageConnector);
		}
	}

	/*
	 * Create feedback message for search not found
	 */
	private Feedback searchNotFound(StorageConnector storageConnector) {
		Feedback fb = new Feedback(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(), null);
		fb.setCalFlag();
		return fb;
	}

	/*
	 * Create feedback message for search found
	 */
	private Feedback searchFound(String message, ArrayList<Task> tasks, Task task) {
		Feedback fb = new Feedback(message, tasks, task);
		fb.setListFlag();
		return fb;
	}
}
```
###### Fantasktic\src\application\backend\SearchByName.java
``` java
package application.backend;

import java.util.ArrayList;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import application.storage.Task;

/**
 * 
 * Class to search by name
 *
 */

public class SearchByName implements Command {

	// Logger Messages
	private static final String EXECUTE_SEARCH_BY_NAME_LOGGER_MSG = "Executing search by name function";

	// Constants
	private static final int EMPTY = 0;

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	// Messages
	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search! Use home command to view all tasks!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";

	// Variables
	private String taskName;
	private ArrayList<Task> taskList;

	SearchByName(String taskName) {
		this.taskName = taskName;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		logger.info(EXECUTE_SEARCH_BY_NAME_LOGGER_MSG);
		taskList = storageConnector.searchTaskByName(taskName);
		return checkIfListEmpty(storageConnector);
	}

	/*
	 *  Check if list is empty
	 */
	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList.size() != EMPTY) {
			return searchFound(MESSAGE_SEARCH_RESULTS, taskList, null);
		} else {
			assert (taskList.size() == EMPTY);
			return searchNotFound(storageConnector);
		}
	}

	/*
	 *  Create feedback message for search not found
	 */
	private Feedback searchNotFound(StorageConnector storageConnector) {
		Feedback fb = new Feedback(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(), null);
		fb.setCalFlag();
		return fb;
	}

	/*
	 *  Create feedback message for search found
	 */
	private Feedback searchFound(String message, ArrayList<Task> tasks, Task task) {
		Feedback fb = new Feedback(message, tasks, task);
		fb.setListFlag();
		return fb;
	}
}
```
###### Fantasktic\src\application\backend\SearchByPriority.java
``` java
package application.backend;

import java.util.ArrayList;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import application.storage.Task;

/**
 * 
 * Class to search by priority
 *
 */

public class SearchByPriority implements Command {

	// Logger Messages
	private static final String EXECUTE_SEARCH_BY_PRIORITY_LOGGER_MSG = "Executing search by priority function";

	// Messages
	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search! Use home command to view all tasks!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	// Variables
	private String priority;
	private ArrayList<Task> taskList;

	SearchByPriority(String priority) {
		this.priority = priority;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		logger.info(EXECUTE_SEARCH_BY_PRIORITY_LOGGER_MSG);
		taskList = storageConnector.searchTaskByPriority(priority);
		return checkIfListEmpty(storageConnector);
	}

	/*
	 * Check if list is empty
	 */
	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList != null) {
			return searchFound(MESSAGE_SEARCH_RESULTS, taskList, null);
		} else {
			assert (taskList == null);
			return searchNotFound(storageConnector);
		}
	}

	/*
	 * Create feedback message for search not found
	 */
	private Feedback searchNotFound(StorageConnector storageConnector) {
		Feedback fb = new Feedback(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(), null);
		fb.setCalFlag();
		return fb;
	}

	/*
	 * Create feedback message for search found
	 */
	private Feedback searchFound(String message, ArrayList<Task> tasks, Task task) {
		Feedback fb = new Feedback(message, tasks, task);
		fb.setListFlag();
		return fb;
	}

}
```
###### Fantasktic\src\application\backend\SearchOnDate.java
``` java
package application.backend;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import application.storage.Task;

/**
 * 
 * Class to search on date
 *
 */

public class SearchOnDate implements Command {

	// Logger Messages
	private static final String EXECUTE_SEARCH_ON_DATE_LOGGER_MSG = "Executing search on date function";

	// Constants
	private static final int EMPTY = 0;

	// Messages
	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search! Use home command to view all tasks!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();
	private Calendar date;

	// Variables
	private ArrayList<Task> taskList;

	SearchOnDate(Calendar date) {
		this.date = date;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		logger.info(EXECUTE_SEARCH_ON_DATE_LOGGER_MSG);
		taskList = storageConnector.searchTaskOnDate(date);
		return checkIfListEmpty(storageConnector);
	}

	/*
	 * Check if list is empty
	 */
	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList.size() != EMPTY) {
			return searchFound();
		} else {
			assert (taskList.size() == EMPTY);
			return searchNotFound(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(), null);
		}
	}

	/*
	 * Create feedback message for search found
	 */
	private Feedback searchFound() {
		Feedback fb = new Feedback(MESSAGE_SEARCH_RESULTS, taskList, null);
		fb.setListFlag();
		return fb;
	}

	/*
	 * Create feedback message for search not found
	 */
	private Feedback searchNotFound(String message, ArrayList<Task> tasks, Task task) {
		Feedback fb = new Feedback(message, tasks, task);
		fb.setCalFlag();
		return fb;
	}
}
```
###### Fantasktic\src\application\gui\application.css
``` css

.list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button, 
.list-view .scroll-bar:vertical .increment-arrow,
.list-view .scroll-bar:vertical .decrement-arrow,
.list-view .scroll-bar:vertical .increment-button,
.list-view .scroll-bar:vertical .decrement-button{
    -fx-padding:0.0;
}

.data0.chart-pie { 
	-fx-pie-color: #C8E6C9;
}

.data1.chart-pie { 
	-fx-pie-color: #B2EBF2;
}

.data2.chart-pie { 
	-fx-pie-color: #B71C1C;
}

.displayList .list-cell:filled:selected:focused {
    -fx-background-color: #00acc1;
    -fx-text-fill: white;
}

.displayList .list-cell:filled:selected{
    -fx-background-color: #F44336;
    -fx-text-fill: white;
}

.calendarItem .list-cell:filled:selected:focused {
    -fx-background-color: #00acc1;
    -fx-text-fill: white;
}

.calendarItem .list-cell:filled:selected{
    -fx-background-color: #F44336;
    -fx-text-fill: white;
}
```
###### Fantasktic\src\application\gui\CalendarItem.java
``` java
package application.gui;

import java.io.IOException;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.shape.Rectangle;

/*
 * Creates a calendar item box for each task
 */

public class CalendarItem extends AnchorPane {

	// Exception Messages
	private static final String FXML_LOAD_FAIL_MSG = "Failed to load calendar item fxml file";

	// Constants
	private static final String LOW = "low";
	private static final String MEDIUM = "medium";
	private static final String HIGH = "high";
	private static final int overdueCheckVariable = 0;
	private static final String CALENDAR_ITEM_FXML_URL = "CalendarItem.fxml";
	private static final String EMPTY = "";

	// Formatting
	private static final String RED = "#EF9A9A";
	private static final String GREEN = "#A5D6A7";
	private static final String BLUE = "#B2EBF2";
	private static final String BACKGROUND_COLOR = "-fx-fill: %1$s;";
	private static final String FONT_STYLE = "-fx-text-fill: %1$s;";
	private static final String DARK_RED = "#B71C1C";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	// FXML variables
	@FXML
	private Label taskName;
	@FXML
	private Label date;
	@FXML
	private Label locationLabel;
	@FXML
	private Rectangle rectangle;
	@FXML
	private Label indexLabel;

	public CalendarItem(String name, String date, String location, String priority, int overdueCheck, int index) {
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(CALENDAR_ITEM_FXML_URL));
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
			this.setLabels(name, date, location, priority, overdueCheck, index);
		} catch (IOException exception) {
			logger.severe(FXML_LOAD_FAIL_MSG);
			throw new RuntimeException(exception);
		}

	}

	/*
	 *  Sets all labels for the calendar item
	 */
	private void setLabels(String name, String date, String location, String priority, int overdueCheck, int index) {
		this.taskName.setText(name.toUpperCase());
		this.date.setText(date.toUpperCase());
		this.indexLabel.setText(EMPTY + index);
		setLocation(location.trim().toUpperCase());
		setPriorityColor(priority);
		overdueCheck(overdueCheck);
	}

	/*
	 *  Checks if task is overdue
	 */
	private void overdueCheck(int overdueCheck) {
		if (overdueCheck < overdueCheckVariable) {
			setOverdueFormat();
		}
	}

	/*
	 *  Formats for overdue tasks
	 */
	private void setOverdueFormat() {
		rectangle.setStyle(String.format(BACKGROUND_COLOR, DARK_RED));
		this.date.setStyle(this.date.getStyle() + String.format(FONT_STYLE, DARK_RED));
	}

	/*
	 *  Sets the color of the rectangle by priority
	 */
	private void setPriorityColor(String priority) {
		switch (priority) {
		case HIGH:
			rectangle.setStyle(String.format(BACKGROUND_COLOR, RED));
			break;
		case MEDIUM:
			rectangle.setStyle(String.format(BACKGROUND_COLOR, BLUE));
			break;
		case LOW:
			rectangle.setStyle(String.format(BACKGROUND_COLOR, GREEN));
			break;
		default:
			rectangle.setStyle(String.format(BACKGROUND_COLOR, GREEN));
			break;
		}

	}

	/*
	 *  Sets the location labels accordingly
	 */
	private void setLocation(String location) {
		if (!location.equals(EMPTY)) {
			this.locationLabel.setText(location);
		} else {
			assert (location.equals(EMPTY));
			this.locationLabel.setText(EMPTY);
		}
	}

}
```
###### Fantasktic\src\application\gui\DateObject.java
``` java
package application.gui;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import application.storage.EventTask;
import application.storage.Task;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.HBox;
import javafx.util.Callback;

/*
 * Creates a date object item that holds all tasks on the same date
 */

public class DateObject extends HBox {
	// Constants
	private static final int NOT_OVERDUE_VARIABLE = 0;
	private static final String DATE_OBJECT_FXML_URL = "DateObject.fxml";
	private static final String UNDATED_TEXT = "UNDATED";
	public static final String EMPTY = "";
	public static final int OFFSET = 1;

	// Error Messages
	private static final String FXML_LOAD_FAIL_MSG = "Failed to load date object fxml file";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	// FXML Variables
	@FXML
	public Label dateLabel;
	@FXML
	public ListView<Task> listViewItem;
	@FXML
	public HBox dateObject;

	public DateObject(String date, ArrayList<Task> taskList, ArrayList<Task> wholeList) {
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(DATE_OBJECT_FXML_URL));
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
			this.setLabels(date);
			setCellFactoryDateItems(wholeList);
			updateListView(taskList);
		} catch (IOException exception) {
			logger.severe(FXML_LOAD_FAIL_MSG);
			throw new RuntimeException(exception);
		}

	}

	/*
	 *  Setup cell factory
	 */
	private void setCellFactoryDateItems(ArrayList<Task> wholeList) {
		this.listViewItem.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
			public ListCell<Task> call(ListView<Task> param) {
				ListCell<Task> cell = new ListCell<Task>() {
					@Override
					public void updateItem(Task item, boolean empty) {
						super.updateItem(item, empty);
						
						if (item != null) {
							int overdueCheck = checkIfOverdue(item);
							CalendarItem calItem = new CalendarItem(item.getTaskDescription(), item.durationToString(),
									item.getLocation(), item.getPriority(), overdueCheck,
									wholeList.indexOf(item) + OFFSET);
							setGraphic(calItem);
						} else {
							assert (item == null);
							setGraphic(null);
						}
					}
				};
				return cell;
			}
		});
	}

	/*
	 * Check if the items are overdue
	 */
	private int checkIfOverdue(Task item) {
		Calendar cal = Calendar.getInstance();
		int overdueCheck = NOT_OVERDUE_VARIABLE;
		if (!(item instanceof EventTask)) {
			overdueCheck = checkNonEventTaskOverdue(item, cal, overdueCheck);
		} else {
			overdueCheck = checkEventTaskOverdue(item, cal, overdueCheck);
		}
		return overdueCheck;
	}

	/*
	 * Check if non event task is overdue
	 */
	private int checkNonEventTaskOverdue(Task item, Calendar cal, int overdueCheck) {
		if (item.getEndDate() != null) {
			overdueCheck = item.getEndDate().getTime().compareTo(cal.getTime());
		}
		return overdueCheck;
	}

	/*
	 * Check if event task is overdue
	 */
	private int checkEventTaskOverdue(Task item, Calendar cal, int overdueCheck) {
		assert (item instanceof EventTask);
		if (item.getStartDate() != null) {
			overdueCheck = item.getStartDate().getTime().compareTo(cal.getTime());
		}
		return overdueCheck;
	}

	/*
	 * Update List View
	 */
	private void updateListView(ArrayList<Task> taskList) {
		ObservableList<Task> list = makeDisplayList(taskList);
		this.listViewItem.setItems(list);
	}

	/*
	 * Adds items to be displayed
	 */
	private ObservableList<Task> makeDisplayList(ArrayList<Task> taskList) {
		ObservableList<Task> displayList = FXCollections.observableArrayList();
		for (Task task : taskList) {
			displayList.add(task);
		}
		return displayList;
	}

	/*
	 * Set date labels
	 */
	private void setLabels(String date) {
		if (date != null) {
			this.dateLabel.setText(date.toUpperCase());
		} else {
			assert (date == null);
			this.dateLabel.setText(UNDATED_TEXT);
		}
	}

	/*
	 * Returns HBox
	 */
	public HBox getHbox() {
		return this.dateObject;
	}

}
```
###### Fantasktic\src\application\gui\ExceptionHandler.java
``` java
package application.gui;

public class ExceptionHandler extends Exception {

	/**
	 *  GUI Exception Handler
	 */
	private static final long serialVersionUID = -1126588698588471265L;

	public ExceptionHandler(String message) {
		super(message);
	}

}
```
###### Fantasktic\src\application\gui\Fantasktic.java
``` java
package application.gui;

import java.awt.AWTException;
import java.awt.MenuItem;
import java.awt.PopupMenu;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import application.backend.BackendFacade;
import application.storage.Task;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;

/*
 * This class sets the scene and startup for Fantasktic
 */

public class Fantasktic extends Application {

	// Logger Messages
	private static final String CLOSE_CLICK_TRAY_LOGGER_MSG = "Clicked close on system tray icon";
	private static final String SHOW_CLICK_TRAY_LOGGER_MSG = "Clicked show on system tray icon";
	private static final String GUI_SETUP = "Setting up gui";

	// Error Messages
	private static final String LOAD_LOGO_FAIL_MSG = "Failed to load logo";
	private static final String GUI_LOAD_FAIL_MSG = "Failed to load GUI";

	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	private static final String ROBOT_GIF_URL = "robot.gif";
	private static final String APPLICATION_NAME = "Fantasktic";
	private static final String EMPTY_STRING = "";
	private static final String BACKSLASH = "\\";
	private static final String CSS_URL = "application/gui/application.css";
	private static final String LOGO_URL = "robot.jpg";
	private static final String DIRECTORY_CHOOSER_TITLE = "Pick Where To Store Tasks";
	private static final String CURRENT_DIRECTORY = "user.dir";
	private static final String SYSTEM_TRAY_HINT = "Fantasktic is still running in the background.";
	private static final String SHOW_MENU_TEXT = "Show";
	private static final String EXIT_MENU_TEXT = "Exit";

	// Variables
	private TrayIcon trayIcon;
	private BackendFacade backendFacade;
	private ArrayList<Task> taskList;

	public static void main(String[] args) {
		launch(args);
	}

	@Override
	public void start(Stage primaryStage) throws ExceptionHandler {
		logger.info(GUI_SETUP);
		try {
			setEnvironment();
			initializeSaveDirectory(primaryStage);
			MainPage page = new MainPage(taskList, backendFacade);
			Platform.setImplicitExit(false);
			Scene scene = new Scene(page);
			scene.getStylesheets().clear();
			scene.getStylesheets().add(CSS_URL);
			primaryStage.setScene(scene);
			customiseGUIMenuBar(primaryStage);
			primaryStage.setResizable(false);
			primaryStage.show();
			createTrayIcon(primaryStage);
		} catch (IOException e) {
			e.printStackTrace();
			logger.severe(GUI_LOAD_FAIL_MSG);
			throw new ExceptionHandler(GUI_LOAD_FAIL_MSG);
		}
	}

	/*
	 * Customises the top bar of the GUI
	 */
	private void customiseGUIMenuBar(Stage primaryStage) {
		setProgramName(primaryStage);
		setProgramLogo(primaryStage);
	}

	/*
	 * Set program name
	 */
	private void setProgramName(Stage primaryStage) {
		primaryStage.setTitle(APPLICATION_NAME);
	}

	/*
	 * Set program logo
	 */
	private void setProgramLogo(Stage primaryStage) {
		primaryStage.getIcons().add(new Image(ResourceLoader.load(LOGO_URL)));
	}

	private void setEnvironment() {
		this.backendFacade = new BackendFacade();
	}

	/*
	 * Checks if user has used the program at least once if not prompt to save
	 * file
	 */
	private void initializeSaveDirectory(Stage primaryStage) throws IOException {
		if (!backendFacade.checkIfFileExists()) {
			DirectoryChooser dirChooser = new DirectoryChooser();
			configureDirectoryChooser(dirChooser);
			directoryPrompt(primaryStage, dirChooser);
			taskList = backendFacade.loadDataFile();
		} else {
			taskList = backendFacade.loadDataFile();
		}
	}

	/*
	 * Does the directory prompt then sends the data to logic accordingly
	 */
	public void directoryPrompt(Stage primaryStage, DirectoryChooser dirChooser) throws IOException {
		final File selectedDirectory = dirChooser.showDialog(primaryStage);
		if (selectedDirectory != null) {
			backendFacade.setDirectory(selectedDirectory.getPath().toString() + BACKSLASH);
		} else {
			backendFacade.setDirectory(EMPTY_STRING);
		}
	}

	/*
	 * Configuration for directory chooser
	 */
	private void configureDirectoryChooser(final DirectoryChooser dirChooser) {
		dirChooser.setTitle(DIRECTORY_CHOOSER_TITLE);
		dirChooser.setInitialDirectory(new File(System.getProperty(CURRENT_DIRECTORY)));
	}

	/*
	 * Create Tray Icon
	 */
	public void createTrayIcon(Stage primaryStage) {
		if (SystemTray.isSupported()) {
			SystemTray tray = SystemTray.getSystemTray();
			setToTray(primaryStage);
			ActionListener showListener = showApplication(primaryStage);
			ActionListener closeListener = closeTray();
			PopupMenu popup = popupMenuConfiguration(closeListener, showListener);
			trayIconConfiguration(showListener, popup);
			
			try {
				tray.add(trayIcon);
			} catch (AWTException e) {
				logger.severe(LOAD_LOGO_FAIL_MSG);
			}
		}
	}

	/*
	 * Configuration for Tray Icon
	 */
	private void trayIconConfiguration(ActionListener showListener, PopupMenu popup) {
		java.awt.Image image = Toolkit.getDefaultToolkit()
				.getImage(getClass().getClassLoader().getResource((ROBOT_GIF_URL)));
		trayIcon = new TrayIcon(image, APPLICATION_NAME, popup);
		trayIcon.setImageAutoSize(true);
		trayIcon.addActionListener(showListener);
	}

	/*
	 * Show Application Menu
	 */
	private ActionListener showApplication(Stage primaryStage) {
		ActionListener showListener = new ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						logger.info(SHOW_CLICK_TRAY_LOGGER_MSG);
						primaryStage.show();
						primaryStage.setIconified(false);
					}
				});
			}
		};
		return showListener;
	}

	/*
	 * Close Menu
	 */
	private ActionListener closeTray() {
		ActionListener closeListener = new ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				logger.info(CLOSE_CLICK_TRAY_LOGGER_MSG);
				System.exit(0);
			}
		};
		return closeListener;
	}

	/*
	 * Minimize to tray
	 */
	private void setToTray(Stage primaryStage) {
		primaryStage.setOnCloseRequest(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent t) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						if (SystemTray.isSupported()) {
							primaryStage.hide();
							showProgramIsMinimizedMsg();
						} else {
							System.exit(0);
						}
					}
				});
			}
		});
	}

	/*
	 * create a popup menu for right clicking system tray icon
	 */
	private PopupMenu popupMenuConfiguration(final ActionListener closeListener, ActionListener showListener) {
		PopupMenu popup = new PopupMenu();
		addShowMenuToPopup(showListener, popup);
		addExitMenuToPopup(closeListener, popup);
		return popup;
	}

	/*
	 * Adds exit selection to the right click menu of the system tray
	 */
	private void addExitMenuToPopup(final ActionListener closeListener, PopupMenu popup) {
		MenuItem closeItem = new MenuItem(EXIT_MENU_TEXT);
		closeItem.addActionListener(closeListener);
		popup.add(closeItem);
	}

	/*
	 * Adds show selection to the right click menu of the system tray
	 */
	private void addShowMenuToPopup(ActionListener showListener, PopupMenu popup) {
		MenuItem showItem = new MenuItem(SHOW_MENU_TEXT);
		showItem.addActionListener(showListener);
		popup.add(showItem);
	}

	/*
	 * Message when minimized
	 */
	public void showProgramIsMinimizedMsg() {
		trayIcon.displayMessage(APPLICATION_NAME, SYSTEM_TRAY_HINT, TrayIcon.MessageType.INFO);
	}

}
```
###### Fantasktic\src\application\gui\ListItem.java
``` java
package application.gui;

import java.io.IOException;
import java.util.logging.Logger;
import application.logger.LoggerHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;

/*
 * Creates an item for each task
 */

public class ListItem extends HBox {

	// Error Messages
	private static final String FXML_LOAD_FAILED_MSG = "Failed to load list item fxml file";

	// Constants
	private static final String LIST_ITEM_FXML_URL = "ListItem.fxml";
	private static final String EMPTY = "";
	private static final String LOW = "low";
	private static final String MEDIUM = "medium";
	private static final String HIGH = "high";
	private static final int overdueCheckVariable = 0;

	// Formatting
```
###### Fantasktic\src\application\gui\ListItem.java
``` java

	/*
	 * Checks if the task is overdue
	 */
	private void overdueCheck(int overdueCheck) {
		if (overdueCheck < overdueCheckVariable) {
			setOverdueItems();
		}
	}

	/*
	 * Formats list item accordingly to overdue format
	 */
	private void setOverdueItems() {
		listNumber.setStyle(String.format(BACKGROUND_STYLE, DARK_RED));
		this.date.setStyle(this.date.getStyle() + String.format(FONT_STYLE, DARK_RED));
	}

	/*
	 * Set color of background color of number according to priority
	 */
	private void setBackground(String priority) {
		switch (priority) {
		case HIGH:
			listNumber.setStyle(String.format(BACKGROUND_STYLE, RED));
			break;
		case MEDIUM:
			listNumber.setStyle(String.format(BACKGROUND_STYLE, BLUE));
			break;
		case LOW:
			listNumber.setStyle(String.format(BACKGROUND_STYLE, GREEN));
			break;
		default:
			listNumber.setStyle(String.format(BACKGROUND_STYLE, GREEN));
			break;
		}

	}
}
```
###### Fantasktic\src\application\gui\MainPage.java
``` java
package application.gui;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Optional;
import java.util.logging.Logger;
import org.controlsfx.control.Notifications;
import application.logger.LoggerHandler;
import application.backend.Feedback;
import application.backend.NoDescriptionException;
import application.backend.BackendFacade;
import application.storage.EventTask;
import application.storage.FloatingTask;
import application.storage.Task;
import javafx.animation.TranslateTransition;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Side;
import javafx.scene.chart.PieChart;
import javafx.scene.control.ChoiceDialog;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SelectionMode;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.StackPane;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.util.Callback;
import javafx.util.Duration;

/*
 * Holds the main page of the gui that runs most of the program
 * 
 */

public class MainPage extends AnchorPane {

    // Constants
    private static final String SUMMARY_TEXT = "summary";
    private static final String VIEW_TEXT = "view";
    private static final String SU_TEXT = "su";
    private static final String ST_TEXT = "st";
    private static final String HOME_TEXT = "home";
    private static final String HO_TEXT = "ho";
    private static final String HE_TEXT = "he";
    private static final int FIRST_WORD = 0;
    private static final int ONE_LETTER = 1;
    private static final int TWO_LETTERS = 2;
    private static final String STORAGE_TEXT = "storage";
    private static final String SEARCH_TEXT = "search";
    private static final String SE_TEXT = "se";
    private static final String S_TEXT = "s";
    private static final String EXIT_TEXT = "exit";
    private static final String E_TEXT = "e";
    private static final String UPDATE_TEXT = "update";
    private static final String UNDO_TEXT = "undo";
    private static final String UN_TEXT = "un";
    private static final String UP_TEXT = "up";
    private static final String U_TEXT = "u";
    private static final String DELETE_TEXT = "delete";
    private static final String DONE_TEXT = "done";
    private static final String DO_TEXT = "do";
    private static final String DE_TEXT = "de";
    private static final String D_TEXT = "d";
    private static final String H_TEXT = "h";
    private static final String A_TEXT = "a";
    private static final String V_TEXT = "v";
    private static final String HELP_TEXT = "help";
    private static final String MAIN_PAGE_FXML_URL = "MainPage.fxml";
    private static final String LIST_FLAG = "list";
    private static final String CAL_FLAG = "cal";
    private static final String HELP_FLAG = HELP_TEXT;
    private static final String STORAGE_FLAG = STORAGE_TEXT;
    private static final String VIEW_CHANGE_FLAG = VIEW_TEXT;
    private static final String SUMMARY_FLAG = SUMMARY_TEXT;
    private static final String SPACE = " ";
    private static final String EMPTY_STRING = "";
    private static final String LOCATION_PREFIX = "AT";
    private static final String DIRECTORY_CHOOSER_TITLE = "Pick Where To Store Tasks";
    private static final String CURRENT_DIRECTORY = "user.dir";
    private static final int TASK_NUM_OFFSET = 1;
    private static final String OVERDUE_TASKS_TEXT = "Overdue Tasks";
    private static final String REMAINING_TASKS_TEXT = "Remaining Tasks";
    private static final String COMPLETED_TASKS_TEXT = "Completed Tasks";
    private static final String NO_DATES_TEXT = "No Dates Set";
    private static final String NO_START_DATE_TEXT = "No Start Date Set";
    private static final String NO_END_DATE_TEXT = "No End Date Set";
    private static final String REMINDER_TEXT = "Reminder";
    private static final int EMPTY = 0;
    private static final int STARTPOSITION = 0;
    private static final int OFFSET = 1;
    private static final int NEXT = 1;
    private static final int START = 0;
    private static final int previous = 1;
    private static final int BOX_HEIGHT = 580;
    private static final int BOX_WIDTH = 1070;
    private static final int TRANSITION_TIME = 350;
    private static final int overdueCheckVariable = 0;
    private static final int STACK_PANE_FIRST_CHILD = 0;
    private static final int CLASH_DETECTION_VARIABLE = 1;

    // Initialization
    private static Logger logger = LoggerHandler.getLog();

    // Formats
    private static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("dd MMM yyyy");

    // Messages
    private static final String CLASH_NOTIFICATION_MSG = "Please Note The Highlighted Clashes";
    private static final String CLASH_NOTIFICATION_TITLE = "Clash has been detected";
    private static final String ADD_HINT_MESSAGE = "To add: [task description] from [start] to [end] at [location] priority [priority]";
    private static final String HELP_HINT_MESSAGE = "To get help: help";
    private static final String DELETE_HINT_MESSAGE = "To delete: delete [task description/number]";
    private static final String SEARCH_HINT_MESSAGE = "To search: search [task description/priority [level]/by [date]/on [date]]";
    private static final String EXIT_HINT_MESSAGE = "To exit: exit";
    private static final String HOME_HINT_MESSAGE = "To go back home and view all tasks: home";
    private static final String UPDATE_HINT_MESSAGE = "To update: update [task number] [new task description"
            + "/priority [level]/from [start] to [end]/at [location]] ";
    private static final String UNDO_HINT_MESSAGE = "To undo: undo";
    private static final String STORAGE_HINT_MESSAGE = "To change storage: storage [url]";
    private static final String SUMMARY_HINT_MESSAGE = "To view an overview of tasks: summary";
    private static final String DONE_HINT_MESSAGE = "To mark task as complete: done [task number]";
    private static final String VIEW_HINT_MESSAGE = "To Toggle Views: view";
    private static final String MESSAGE_HELP_INTRO = "Start typing and we'll help you out!";
    private static final String MESSAGE_FEEDBACK_INTRO = "We'll give you feedback on your commands here.";
    private static final String MESSAGE_ERROR = "There was some problem processing your request. "
            + "Please check your input format.";
    private static final String ADD_HINT_INPUT = "[desc] from [start date] to [end date] at [location] priority [priority]";
    private static final String DELETE_HINT_INPUT = "delete [task description/number]";
    private static final String UPDATE_HINT_INPUT = "update [task number] [new task desc]";
    private static final String DONE_HINT_INPUT = "Done [task number]";
    private static final String SEARCH_HINT_INPUT = "search [task decription/priority [level]/[task description] by [date]]";
    private static final String UNDO_HINT_INPUT = "Undo";
    private static final String STORAGE_HINT_INPUT = "Storage";
    private static final String EXIT_HINT_INPUT = "Exit";

    // Error Messages
    private static final String FXML_LOAD_FAILED = "Failed to load ListView FXML file";
    private static final String DIRECTORY_NOT_CHANGED_MESSAGE = "Directory Not Changed";

    // Variables
    private static int pointer = START;
    private Task taskToFocus;
    private String checkFlag;
    private String text = EMPTY_STRING;
    private static ArrayList<String> commands = new ArrayList<String>();
    private ArrayList<Task> tasksOnScreen;
    private BackendFacade backendFacade;
    TranslateTransition openPanel;
    TranslateTransition closePanel;

    // FXML Variables
    @FXML
    public Label feedbackLabel;
    @FXML
    private Label helpLabel;
    @FXML
    private TextField textInputArea;
    @FXML
    private StackPane stackPane;
    @FXML
    private ListView<Task> displayList;
    @FXML
    private ListView<ArrayList<Task>> calendarList;
    @FXML
    private AnchorPane hiddenMenu;
    @FXML
    private Label overdueLabel;
    @FXML
    private Label completedLabel;
    @FXML
    private Label remainingLabel;
    @FXML
    private PieChart pieChart;

```
###### Fantasktic\src\application\gui\MainPage.java
``` java

    /*
     * Setup hidden panel
     */
    private void initializeHiddenPanel() {
        openPanel = new TranslateTransition(new Duration(TRANSITION_TIME), hiddenMenu);
        openPanel.setToX(STARTPOSITION);
        closePanel = new TranslateTransition(new Duration(TRANSITION_TIME), hiddenMenu);
    }

    /*
     * Setup cell factory for task list view
     */
    private void initialiseDisplayList() {
        displayList.setPrefSize(BOX_WIDTH, BOX_HEIGHT);
        this.displayList.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
            public ListCell<Task> call(ListView<Task> param) {
                ListCell<Task> cell = new ListCell<Task>() {
                    @Override
                    public void updateItem(Task item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null) {
                            Calendar cal = Calendar.getInstance();
                            int overdueCheck = checkIfOverdue(item, cal);
                            int taskNumber = this.getIndex() + TASK_NUM_OFFSET;
                            String taskDescription = item.getTaskDescription();
                            String taskDuration = item.durationToString();
                            String taskLocation = getLocationString(item);
                            String taskPriority = item.getPriority();
                            ListItem listViewItem = new ListItem(taskNumber, taskDescription, taskDuration,
                                    taskLocation, taskPriority, overdueCheck);
                            setGraphic(listViewItem);
                        } else {
                            assert (item == null);
                            setGraphic(null);
                        }
                    }
                };
                return cell;
            }
        });
    }

    /*
     * Setup cell factory for calendar view
     */
    private void initialiseCalendarList() {
        calendarList.setPrefSize(BOX_WIDTH, BOX_HEIGHT);
        this.calendarList.setCellFactory(new Callback<ListView<ArrayList<Task>>, ListCell<ArrayList<Task>>>() {
            public ListCell<ArrayList<Task>> call(ListView<ArrayList<Task>> param) {
                ListCell<ArrayList<Task>> cell = new ListCell<ArrayList<Task>>() {
                    @Override
                    public void updateItem(ArrayList<Task> item, boolean empty) {
                        super.updateItem(item, empty);

                        if (item != null) {
                            String date = setDate(item);
                            DateObject listViewItem = new DateObject(date, item, tasksOnScreen);
                            setGraphic(listViewItem.getHbox());
                        } else {
                            assert (item == null);
                            setGraphic(null);
                        }
                    }
                };
                return cell;
            }
        });
    }

    /*
     * Set date accordingly
     */
    private String setDate(ArrayList<Task> item) {
        String date = null;
        if (item.get(START).getEndDate() != null) {
            date = FORMAT_DATE.format(item.get(START).getEndDate().getTime());
        }
        return date;
    }

    /*
     * Check if task is overdue
     */
    private int checkIfOverdue(Task item, Calendar cal) {
        int overdueCheck = overdueCheckVariable;
        if (!(item instanceof EventTask)) {
            overdueCheck = checkNonEventTaskOverdue(item, cal, overdueCheck);
        } else {
            overdueCheck = checkEventTaskOverdue(item, cal, overdueCheck);
        }
        return overdueCheck;
    }

    /*
     * Check if non event task is overdue
     */
    private int checkNonEventTaskOverdue(Task item, Calendar cal, int overdueCheck) {
        if (item.getEndDate() != null) {
            overdueCheck = item.getEndDate().getTime().compareTo(cal.getTime());
        }
        return overdueCheck;
    }

    /*
     * Check if event task is overdue
     */
    private int checkEventTaskOverdue(Task item, Calendar cal, int overdueCheck) {
        assert (item instanceof EventTask);
        if (item.getStartDate() != null) {
            overdueCheck = item.getStartDate().getTime().compareTo(cal.getTime());
        }
        return overdueCheck;
    }

    /*
     * Format for the location section of task list view
     */
    private String getLocationString(Task task) {
        String location = task.getLocation();
        if (location.trim().equals(EMPTY_STRING)) {
            return EMPTY_STRING;
        } else {
            assert (!location.trim().equals(EMPTY_STRING));
            return (LOCATION_PREFIX + SPACE + location);
        }
    }

    /*
     * Set the data for the calendar view
     */
    private ArrayList<ArrayList<Task>> getDateArray(ArrayList<Task> taskList) {
        String tempoDate = null;
        ArrayList<ArrayList<Task>> dateArray = new ArrayList<ArrayList<Task>>();
        ArrayList<Task> temporaryList = new ArrayList<Task>();
        for (int i = START; i < taskList.size(); i++) {
            checkIfNonFloatingTask(taskList, tempoDate, dateArray, temporaryList, i);
            temporaryList = checkIfReachedFloatingTask(taskList, tempoDate, dateArray, temporaryList, i);
            tempoDate = setTempoDate(taskList, i);
        }
        checkTemporaryListBeforeAdd(dateArray, temporaryList);
        return dateArray;
    }

    /*
     * If non floating task, check if previous task date is the same or not
     * 
     * If its the same, add to that task list else add the task list to the list
     * of task lists, create a new task list and add to the new task list
     */
    private void checkIfNonFloatingTask(ArrayList<Task> taskList, String tempoDate,
            ArrayList<ArrayList<Task>> dateArray, ArrayList<Task> temporaryList, int i) {
        if (!(taskList.get(i) instanceof FloatingTask) && tempoDate != null) {
            if (tempoDate.equals(FORMAT_DATE.format(taskList.get(i).getEndDate().getTime()))) {
                temporaryList.add(taskList.get(i));
            } else {
                assert (!tempoDate.equals(FORMAT_DATE.format(taskList.get(i).getEndDate().getTime())));
                dateArray.add(temporaryList);
                temporaryList = new ArrayList<Task>();
                temporaryList.add(taskList.get(i));
            }
        }

        if (!(taskList.get(i) instanceof FloatingTask) && tempoDate == null) {
            temporaryList.add(taskList.get(i));
        }
    }

    /*
     * As floating tasks are at the end of the list, checks if the temporary
     * date is a non floating task date and current task is a floating task
     * 
     * If they are then, create a new temporary list to add floating task else
     * continue adding floating task to the list if temporary date is of
     * floating task
     */
    private ArrayList<Task> checkIfReachedFloatingTask(ArrayList<Task> taskList, String tempoDate,
            ArrayList<ArrayList<Task>> dateArray, ArrayList<Task> temporaryList, int i) {
        if ((taskList.get(i) instanceof FloatingTask) && tempoDate != null) {
            dateArray.add(temporaryList);
            temporaryList = new ArrayList<Task>();
            temporaryList.add(taskList.get(i));
        }

        if ((taskList.get(i) instanceof FloatingTask) && tempoDate == null) {
            temporaryList.add(taskList.get(i));
        }
        return temporaryList;
    }

    /*
     * Checks if the temporary list is empty before adding to prevent null
     * pointer later on when showing the calendar view
     */
    private void checkTemporaryListBeforeAdd(ArrayList<ArrayList<Task>> dateArray, ArrayList<Task> temporaryList) {
        if (temporaryList.size() != EMPTY) {
            dateArray.add(temporaryList);
        }
    }

    /*
     * Set temporary date for checking if date is the same as previously checked
     * date
     */
    private String setTempoDate(ArrayList<Task> taskList, int i) {
        String tempoDate;
        if (!(taskList.get(i) instanceof FloatingTask)) {
            tempoDate = FORMAT_DATE.format(taskList.get(i).getEndDate().getTime());
        } else {
            assert ((taskList.get(i) instanceof FloatingTask));
            tempoDate = null;
        }
        return tempoDate;
    }

    /*
     * Method that calls other methods to update the data
     */
    private void updateViews(ArrayList<Task> taskList, Task taskToFocus) {
        ArrayList<Task> clashList = null;
        clashList = getClashList(taskToFocus, clashList);
        updateCalendarList(taskList, taskToFocus);
        updateDisplayList(taskList, clashList, taskToFocus);
        updateSummary();
    }

    private ArrayList<Task> getClashList(Task taskToFocus, ArrayList<Task> clashList) {
        if (taskToFocus != null) {
            clashList = backendFacade.getClashes(taskToFocus);
        }
        return clashList;
    }

    /*
     * Update the side panel
     */
    private void updateSummary() {
        setSummaryLabels();
        setPieChart();

    }

    /*
     * Setup Labels for summary panel
     */
    private void setSummaryLabels() {
        completedLabel.setText(String.valueOf(backendFacade.getCompletedTaskCount()));
        remainingLabel.setText(String.valueOf(backendFacade.getRemainingTaskCount()));
        overdueLabel.setText(String.valueOf(backendFacade.getOverdueTaskCount()));
    }

    /*
     * Setup pie chart for summary panel
     */
    private void setPieChart() {
        ObservableList<PieChart.Data> pieChartData = FXCollections.observableArrayList(
                new PieChart.Data(COMPLETED_TASKS_TEXT, backendFacade.getCompletedTaskCount()),
                new PieChart.Data(REMAINING_TASKS_TEXT, backendFacade.getRemainingTaskCount()),
                new PieChart.Data(OVERDUE_TASKS_TEXT, backendFacade.getOverdueTaskCount()));
        pieChart.setData(pieChartData);
        pieChart.setLabelsVisible(false);
        pieChart.setLegendSide(Side.BOTTOM);
    }

    /*
     * Notification behavior for adding or updating tasks
     */
    private void notifyUser(Task taskToFocus) {
        String text = null;
        if (taskToFocus != null) {
            text = noEndDateNotificationSetting(taskToFocus, text);
            text = noStartDateNotificationSetting(taskToFocus, text);
            text = floatingTaskNotificationSetting(taskToFocus, text);
            showNotification(text);
        }
    }

    /*
     * Show notifications
     */
    private void showNotification(String text) {
        if (text != null) {
            String title = REMINDER_TEXT;
            Notifications.create().title(title).text(text).showInformation();
        }
    }

    /*
     * Set floating task notification details
     */
    private String floatingTaskNotificationSetting(Task taskToFocus, String text) {
        if (taskToFocus.getStartDate() == null && taskToFocus.getEndDate() == null) {
            text = NO_DATES_TEXT;
        }
        return text;
    }

    /*
     * Set no start date notification details
     */
    private String noStartDateNotificationSetting(Task taskToFocus, String text) {
        if (taskToFocus.getStartDate() == null) {
            text = NO_START_DATE_TEXT;
        }
        return text;
    }

    /*
     * Set no end date notification details
     */
    private String noEndDateNotificationSetting(Task taskToFocus, String text) {
        if (taskToFocus.getEndDate() == null) {
            text = NO_END_DATE_TEXT;
        }
        return text;
    }

    /*
     * Updates data of the task view
     */
    private void updateDisplayList(ArrayList<Task> taskList, ArrayList<Task> clashList, Task taskToFocus2) {
        this.displayList.getItems().clear();
        if (taskList.size() != EMPTY) {
            ObservableList<Task> list = makeDisplayList(taskList);
            this.displayList.setItems(list);
            selectAllClashItems(clashList, taskToFocus);
        }
    }

    /*
     * Selects all clash items in red and/or the task that has been added or
     * updated blue
     */
    private void selectAllClashItems(ArrayList<Task> clashList, Task taskToFocus) {
        if (clashList != null) {
            notifyIfClash(clashList);
            this.displayList.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
            for (Task task : clashList) {
                if (!task.equals(taskToFocus)) {
                    this.displayList.getSelectionModel().select(task);
                }
            }
            this.displayList.getSelectionModel().select(taskToFocus);
            this.displayList.scrollTo(taskToFocus);
        }
    }

    /*
     * Notify users if there is a clash or not
     */
    private void notifyIfClash(ArrayList<Task> clashList) {
        if (clashList.size() > CLASH_DETECTION_VARIABLE) {
            Notifications.create().title(CLASH_NOTIFICATION_TITLE).text(CLASH_NOTIFICATION_MSG).showInformation();
        }
    }

    /*
     * Updates data of the calendar view
     */
    private void updateCalendarList(ArrayList<Task> taskList, Task taskToFocus) {
        this.calendarList.getItems().clear();
        if (taskList.size() != EMPTY) {
            ArrayList<ArrayList<Task>> dateArray = new ArrayList<ArrayList<Task>>();
            dateArray = getDateArray(taskList);
            ObservableList<ArrayList<Task>> calList = makeCalendarList(dateArray);
            this.calendarList.setItems(calList);
        }
    }

    private ObservableList<ArrayList<Task>> makeCalendarList(ArrayList<ArrayList<Task>> taskList) {
        ObservableList<ArrayList<Task>> calendarList = FXCollections.observableArrayList();
        for (ArrayList<Task> task : taskList) {
            calendarList.add(task);
        }
        return calendarList;

    }

    private ObservableList<Task> makeDisplayList(ArrayList<Task> taskList) {
        ObservableList<Task> displayList = FXCollections.observableArrayList();
        for (Task task : taskList) {
            displayList.add(task);
        }
        return displayList;
    }

    /*
     * Sets behavior of the text area
     */
    public void initializeInputArea() {
        textInputArea.setOnKeyPressed(new EventHandler<KeyEvent>() {

            public void handle(KeyEvent ke) {
                if (ke.getCode().equals(KeyCode.ENTER)) {
                    executeCommands();
                }

                if (ke.getCode().equals(KeyCode.UP)) {
                    previousRecentlyUsedCommands();
                }

                if (ke.getCode().equals(KeyCode.DOWN)) {
                    nextRecentlyUsedCommand();
                }
            }
        });
        textInputArea.textProperty().addListener(new ChangeListener<String>() {
            @Override
            public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
                getHints(oldValue, newValue, helpLabel);
            }
        });

    }

    /*
     * Execute commands on enter key pressed at text area
     */
    private void executeCommands() {
        try {
            text = textInputArea.getText();
            commands.add(text);
            Feedback feedback = backendFacade.executeCommand(text, tasksOnScreen);
            tasksOnScreen = feedback.getTasks();
            taskToFocus = feedback.getTaskToScrollTo();
            notifyUser(taskToFocus);
            updateViews(tasksOnScreen, taskToFocus);
            checkFlag = feedback.getFlag();
            feedbackLabel.setText(feedback.getMessage());
            doFlagCommand(checkFlag, feedback);
            if (checkFlag != HELP_FLAG) {
                textInputArea.clear();
            }
            closePanel();
        } catch (Exception e) {
            feedbackLabel.setText(MESSAGE_ERROR);
        }
    }

    /*
     * Previous recently used commands upon up pressed in the text area
     */
    private void previousRecentlyUsedCommands() {
        // if used commands list is not empty
        if (!commands.isEmpty()) {
            checkPointerPosition();
            // if pointer is not at the front end
            if (pointer != START) {
                textInputArea.setText(commands.get(pointer - previous));
            }
        }
    }

    /*
     * Next recently used commands upon down pressed in the text area
     */
    private void nextRecentlyUsedCommand() {
        if (!commands.isEmpty()) {
            checkPointerPosition();
            // if pointer is not at the end
            if (pointer != commands.size() - OFFSET) {
                textInputArea.setText(commands.get(pointer + NEXT));
            }
        }
    }

    /*
     * Check pointer position for recently used commands
     */
    private void checkPointerPosition() {
        if (!commands.contains(textInputArea.getText())) {
            pointer = commands.size();
        } else {
            assert (commands.contains(textInputArea.getText()));
            pointer = commands.indexOf(textInputArea.getText());
        }
    }

    /*
     * Do flag command
     */
    private void doFlagCommand(String checkFlag, Feedback feedback) throws IOException {
        switch (checkFlag) {
        case STORAGE_FLAG:
            promptStorage(feedback);
            break;
        case CAL_FLAG:
            calendarList.toFront();
            break;
        case HELP_FLAG:
            helpFunction();
            break;
        case LIST_FLAG:
            displayList.toFront();
            break;
        case VIEW_CHANGE_FLAG:
            switchViews();
            break;
        case SUMMARY_FLAG:
            toggleHiddenPanel();
            break;
        }
    }

    /*
     * Toggle hidden panel
     */
    private void toggleHiddenPanel() {
        if (hiddenMenu.getTranslateX() != STARTPOSITION) {
            openPanel.play();
        } else {
            assert (hiddenMenu.getTranslateX() == STARTPOSITION);
            closePanel.setToX(+(hiddenMenu.getWidth()));
            closePanel.play();
        }
    }

    /*
     * Close hidden panel
     */
    private void closePanel() {
        if (hiddenMenu.getTranslateX() != STARTPOSITION) {
            openPanel.play();
        }
    }

    /*
     * Toggle Views
     */
    private void switchViews() {
        if (stackPane.getChildren().get(STACK_PANE_FIRST_CHILD).equals(displayList)) {
            displayList.toFront();
        } else {
            assert (!stackPane.getChildren().get(STACK_PANE_FIRST_CHILD).equals(displayList));
            calendarList.toFront();
        }
    }

    /*
     * Prompt for directory change
     */
    public void directoryPrompt(Stage primaryStage, DirectoryChooser dirChooser) throws IOException {
        final File selectedDirectory = dirChooser.showDialog(primaryStage);
        if (selectedDirectory != null) {
            try {
                Feedback feedback = backendFacade
                        .executeCommand(STORAGE_TEXT + SPACE + selectedDirectory.getPath().toString(), tasksOnScreen);
                feedbackLabel.setText(feedback.getMessage());
            } catch (NoDescriptionException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } else {
            assert (selectedDirectory == null);
            backendFacade.setDirectory(EMPTY_STRING);
            feedbackLabel.setText(DIRECTORY_NOT_CHANGED_MESSAGE);
        }
    }

    /*
     * Setup for directory change
     */
    private void promptStorage(Feedback feedback) throws IOException {
        DirectoryChooser dirChooser = new DirectoryChooser();
        configureDirectoryChooser(dirChooser);
        Stage stage = new Stage();
        directoryPrompt(stage, dirChooser);
    }

    /*
     * Configure directory change dialog
     */
    private void configureDirectoryChooser(final DirectoryChooser dirChooser) {
        dirChooser.setTitle(DIRECTORY_CHOOSER_TITLE);
        dirChooser.setInitialDirectory(new File(System.getProperty(CURRENT_DIRECTORY)));
    }

    /*
     * Update hint label
     */
    private void getHints(String oldValue, String newValue, Label helpLabel) {
        String newLetter = EMPTY_STRING;
        String oldWord = EMPTY_STRING;
        String newWord = EMPTY_STRING;

        if (!oldValue.isEmpty() && oldValue != null) {
            oldWord = getFirstWord(oldValue);
        }

        if (!newValue.isEmpty() && newValue != null) {
            newWord = getFirstWord(newValue);
            newLetter = getFirstLetter(newValue);
        }

        if (newWord == null) {
            return;
        }

        if (newWord.equals(oldWord)) {
            return;
        } else {
            assert (!newWord.equals(oldWord));
            switch (newLetter.toLowerCase()) {
            case A_TEXT:
                checkA(helpLabel);
                break;
            case H_TEXT:
                checkH(newValue, helpLabel, newWord);
                break;
            case D_TEXT:
                checkD(newValue, helpLabel, newWord);
                break;
            case U_TEXT:
                checkU(newValue, helpLabel, newWord);
                break;
            case E_TEXT:
                checkE(newValue, helpLabel, newWord);
                break;
            case S_TEXT:
                checkS(newValue, helpLabel, newWord);
                break;
            case V_TEXT:
                checkV(newValue, helpLabel, newWord);
                break;
            default:
                checkA(helpLabel);
                break;
            }
        }
    }

    /*
     * Checks for change in v to switch between view and default hints
     */
    private void checkV(String newValue, Label helpLabel, String newWord) {
        checkString(newValue, helpLabel, newWord, VIEW_HINT_MESSAGE, VIEW_TEXT);
    }

    /*
     * Checks for change in s to switch between search, storage, summary and
     * default hints
     */
    private void checkS(String newValue, Label helpLabel, String newWord) {
        helpLabel.setText(SEARCH_HINT_MESSAGE);
        if (!newValue.isEmpty() && newValue.length() > S_TEXT.length()) {
            if (getTwoLetters(newValue).equalsIgnoreCase(SE_TEXT)) {
                checkString(newValue, helpLabel, newWord, SEARCH_HINT_MESSAGE, SEARCH_TEXT);
            } else if (getTwoLetters(newValue).equalsIgnoreCase(ST_TEXT)) {
                checkString(newValue, helpLabel, newWord, STORAGE_HINT_MESSAGE, STORAGE_TEXT);
            } else if (getTwoLetters(newValue).equalsIgnoreCase(SU_TEXT)) {
                checkString(newValue, helpLabel, newWord, SUMMARY_HINT_MESSAGE, SUMMARY_TEXT);
            } else {
                checkA(helpLabel);
            }
        }
    }

    /*
     * Checks for change in e to switch between exit and default hints
     */
    private void checkE(String newValue, Label helpLabel, String newWord) {
        checkString(newValue, helpLabel, newWord, EXIT_HINT_MESSAGE, EXIT_TEXT);
    }

    /*
     * Checks for change in u to switch between update, undo and default hints
     */
    private void checkU(String newValue, Label helpLabel, String newWord) {
        helpLabel.setText(UPDATE_HINT_MESSAGE);
        if (!newValue.isEmpty() && newValue.length() > U_TEXT.length()) {
            if (getTwoLetters(newValue).equalsIgnoreCase(UN_TEXT)) {
                checkString(newValue, helpLabel, newWord, UNDO_HINT_MESSAGE, UNDO_TEXT);
            } else if (getTwoLetters(newValue).equalsIgnoreCase(UP_TEXT)) {
                checkString(newValue, helpLabel, newWord, UPDATE_HINT_MESSAGE, UPDATE_TEXT);
            } else {
                checkA(helpLabel);
            }
        }
    }

    /*
     * Checks for change in d to switch between done, delete and default hints
     */
    private void checkD(String newValue, Label helpLabel, String newWord) {
        helpLabel.setText(DELETE_HINT_MESSAGE);
        if (!newValue.isEmpty() && newValue.length() > D_TEXT.length()) {
            if (getTwoLetters(newValue).equalsIgnoreCase(DO_TEXT)) {
                checkString(newValue, helpLabel, newWord, DONE_HINT_MESSAGE, DONE_TEXT);
            } else if (getTwoLetters(newValue).equalsIgnoreCase(DE_TEXT)) {
                checkString(newValue, helpLabel, newWord, DELETE_HINT_MESSAGE, DELETE_TEXT);
            } else {
                checkA(helpLabel);
            }
        }
    }

    /*
     * Default hint
     */
    private void checkA(Label helpLabel) {
        helpLabel.setText(ADD_HINT_MESSAGE);
    }

    /*
     * Checks for change in h to switch between
     */
    private void checkH(String newValue, Label helpLabel, String newWord) {
        helpLabel.setText(HELP_HINT_MESSAGE);
        if (!newValue.isEmpty() && newValue.length() > H_TEXT.length()) {
            if (getTwoLetters(newValue).equalsIgnoreCase(HE_TEXT)) {
                checkString(newValue, helpLabel, newWord, HELP_HINT_MESSAGE, HELP_TEXT);
            } else if (getTwoLetters(newValue).equalsIgnoreCase(HO_TEXT)) {
                checkString(newValue, helpLabel, newWord, HOME_HINT_MESSAGE, HOME_TEXT);
            } else {
                checkA(helpLabel);
            }
        }
    }

    /*
     * Checks the string and sets hint message accordingly
     */
    private void checkString(String newValue, Label helpLabel, String newWord, String message, String command) {
        helpLabel.setText(message);
        if (!newValue.isEmpty() && newValue.length() >= command.length()) {
            defaultText(helpLabel, newWord, command);
        }
    }

    /*
     * Checks if label is correct else, set default label
     */
    private void defaultText(Label helpLabel, String newWord, String check) {
        if (!newWord.equalsIgnoreCase(check)) {
            checkA(helpLabel);
        }
    }

    private String getFirstLetter(String input) {
        String firstLetter = input.substring(START, ONE_LETTER);
        return firstLetter;
    }

    private String getFirstWord(String input) {
        String[] inputArgs = input.trim().split(SPACE);
        String firstWord = inputArgs[FIRST_WORD];
        return firstWord;
    }

    private String getTwoLetters(String input) {
        String secondLetter = input.substring(START, TWO_LETTERS);
        return secondLetter;
    }

```
###### Fantasktic\src\application\gui\ResourceLoader.java
``` java
package application.gui;

import java.io.InputStream;
import java.util.logging.Logger;
import javax.annotation.Resource;
import application.logger.LoggerHandler;

/*
 * Fixes problem of unable to get certain images and jar file unable to run due to missing image
 */

public class ResourceLoader {
	
	// Constants
	private static final String LOADING_RESOURCE_LOGGER_MSG = "Loading Resource";
	private static final String SLASH = "/";
	
	// Initialization
	private static Logger logger = LoggerHandler.getLog();

	public static InputStream load(String path) {
		logger.info(LOADING_RESOURCE_LOGGER_MSG);
		InputStream input = ResourceLoader.class.getResourceAsStream(path);
		if (input == null) {
			input = Resource.class.getResourceAsStream(SLASH + path);
		}
		return input;
	}
}
```
###### Fantasktic\src\application\logger\LoggerException.java
``` java
package application.logger;

/*
 * Handles exceptions of logger package
 */

public class LoggerException extends Exception {
	
	private static final long serialVersionUID = -3499023272346800696L;

	public LoggerException(String message) {
		super(message);
	}

}
```
###### Fantasktic\src\application\logger\LoggerFormat.java
``` java
package application.logger;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.Handler;
import java.util.logging.LogRecord;

/*
 * Formats the log
 */

public class LoggerFormat extends Formatter {

	// Text Constants
	private static final String HEADER = " Start ";
	private static final String TAIL = "  End  ";
	private static final String PADDING = " ---------------------- ";
	private static final String SEPARATOR = " - ";
	private static final String NEXT_LINE = "\n";

	// Formatting Constants
	private static final String NUMBER_OF_LETTERS = "%-7s";
	private static final String DATE_FORMAT = "dd.MM.yyyy hh:mm:ss";
	private static final DateFormat DF = new SimpleDateFormat(DATE_FORMAT);

	@Override
	public String format(LogRecord log) {
		String date = DF.format(new Date(log.getMillis()));
		String className = log.getSourceClassName();
		String methodName = log.getSourceMethodName();
		String level = String.format(NUMBER_OF_LETTERS, log.getLevel().toString());
		String message = formatMessage(log);
		String logMessage = getMessage(date, className, methodName, level, message);
		return logMessage;
	}

	/*
	 *  Sets each message of the log
	 */
	private String getMessage(String date, String className, String methodName, String level, String message) {
		String logMessage = date + SEPARATOR + level + SEPARATOR + className + SEPARATOR + methodName + SEPARATOR
				+ message + NEXT_LINE;
		return logMessage;
	}

	public String getHead(Handler handler) {
		String logHead = PADDING + HEADER + new Date() + PADDING + NEXT_LINE;
		return logHead;
	}

	public String getTail(Handler handler) {
		String logTail = PADDING + TAIL + new Date() + PADDING + NEXT_LINE;
		return logTail;
	}

}
```
###### Fantasktic\src\application\logger\LoggerHandler.java
``` java
package application.logger;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Logger;

public class LoggerHandler {

	// Exception Message
	private static final String INITIALISE_LOGGER_EXCEPTION_MSG = "Failed to initialise Logger";

	// Static logger for all classes
	private static Logger log;

	// Logger File Name Constants
	private static final String LOGGER_NAME = "logfile";
	private static final String LOGGER_FILE_NAME = "logfile.txt";

	public static Logger getLog() {
		if (log == null) {
			initialiseLogger();
		}
		return log;
	}

	private static void initialiseLogger() {
		log = Logger.getLogger(LOGGER_NAME);
		FileHandler fileHandler;
		try {
			fileHandler = new FileHandler(LOGGER_FILE_NAME, true);
			LoggerFormat formatter = new LoggerFormat();
			fileHandler.setFormatter(formatter);
			log.addHandler(fileHandler);
		} catch (SecurityException | IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			try {
				throw new LoggerException(INITIALISE_LOGGER_EXCEPTION_MSG);
			} catch (LoggerException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

	}
}
```
