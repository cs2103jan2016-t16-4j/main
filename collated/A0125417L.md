# A0125417L
###### Tasker\bin\application\gui\application.css
``` css
.list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button, 
.list-view .scroll-bar:vertical .increment-arrow,
.list-view .scroll-bar:vertical .decrement-arrow,
.list-view .scroll-bar:vertical .increment-button,
.list-view .scroll-bar:vertical .decrement-button{
    -fx-padding:0.0;
}
```
###### Tasker\bin\application\gui\application.css
``` css

```
###### Tasker\bin\application\gui\CalendarItem.fxml
``` fxml

<?import javafx.scene.effect.*?>
<?import javafx.scene.text.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.shape.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.shape.Rectangle?>

```
###### Tasker\bin\application\gui\CalendarItem.fxml
``` fxml

<fx:root maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="178.0" prefWidth="274.0" style="-fx-border-insets: 0; -fx-border-color: black; -fx-background-radius: 0; -fx-border-width: 0;" type="AnchorPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
      <Rectangle arcHeight="5.0" arcWidth="5.0" fill="WHITE" height="178.0" stroke="TRANSPARENT" strokeType="INSIDE" strokeWidth="0.0" style="-fx-background-radius: 0;" width="274.0">
         <effect>
            <DropShadow color="#000000b9" offsetY="5.0" />
         </effect>
      </Rectangle>
		<Rectangle fx:id="rectangle" arcWidth="5.0" fill="#ff1f1f" height="41.0" layoutY="142.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0" style="-fx-border-width: 0; -fx-background-radius: 0;" width="274.0" />
		<Label fx:id="taskName" alignment="TOP_LEFT" layoutX="14.0" layoutY="14.0" prefHeight="41.0" prefWidth="244.0" textFill="#757474">
         <font>
            <Font size="22.0" />
         </font></Label>
		<Label fx:id="date" layoutX="14.0" layoutY="62.0" prefHeight="27.0" prefWidth="244.0" textFill="#757474" />
		<Label fx:id="locationLabel" layoutX="14.0" layoutY="107.0" prefHeight="27.0" prefWidth="244.0" textFill="#757474" />
      <Label fx:id="indexLabel" alignment="CENTER" layoutX="112.0" layoutY="149.0" prefHeight="27.0" prefWidth="53.0" text="1" textAlignment="CENTER" textFill="WHITE">
         <font>
            <Font name="System Bold" size="18.0" />
         </font>
      </Label>
	</children>
	<padding>
		<Insets right="50.0" />
	</padding>
</fx:root>
```
###### Tasker\bin\application\gui\DateObject.fxml
``` fxml

<?import javafx.scene.shape.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Font?>

```
###### Tasker\bin\application\gui\DateObject.fxml
``` fxml

<fx:root fx:id="dateObject" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="199.0" prefWidth="1053.0" type="HBox" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
      <AnchorPane prefHeight="200.0" prefWidth="200.0">
         <children>
      		<ListView fx:id="listViewItem" layoutX="50.0" orientation="HORIZONTAL" prefHeight="199.0" prefWidth="1012.0" style="-fx-background-insets: 0; -fx-border-color: transparent;" />
            <Line endX="1050.0" endY="198.0" startX="15.0" startY="198.0" stroke="#575454" strokeWidth="0.5" />
            <Label fx:id="dateLabel" alignment="CENTER" contentDisplay="CENTER" layoutX="-69.0" layoutY="82.0" prefHeight="35.0" prefWidth="190.0" rotate="-90.0" text="Label" textAlignment="CENTER" textFill="#757474">
               <font>
                  <Font size="24.0" />
               </font>
            </Label>
         </children>
      </AnchorPane>
	</children>
</fx:root>
```
###### Tasker\bin\application\gui\ListView.fxml
``` fxml
		<StackPane fx:id="stackPane" layoutX="23.0" layoutY="184.0"
			prefHeight="579.0" prefWidth="1066.0" style="-fx-background-insets: 0;">
			<children>
				<ListView fx:id="displayList" prefHeight="575.0" prefWidth="1066.0"
					style="-fx-background-insets: 0;" />
				<ListView fx:id="calendarList" prefHeight="575.0"
					prefWidth="1066.0" style="-fx-background-insets: 0;" />
			</children>
		</StackPane>
```
###### Tasker\bin\application\gui\ListView.fxml
``` fxml
	</children>
	<effect>
		<DropShadow />
	</effect>
</fx:root>
```
###### Tasker\src\application\gui\application.css
``` css
.list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button, 
.list-view .scroll-bar:vertical .increment-arrow,
.list-view .scroll-bar:vertical .decrement-arrow,
.list-view .scroll-bar:vertical .increment-button,
.list-view .scroll-bar:vertical .decrement-button{
    -fx-padding:0.0;
}
```
###### Tasker\src\application\gui\application.css
``` css

```
###### Tasker\src\application\gui\CalendarItem.fxml
``` fxml

<?import javafx.scene.effect.*?>
<?import javafx.scene.text.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.shape.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.shape.Rectangle?>

```
###### Tasker\src\application\gui\CalendarItem.fxml
``` fxml

<fx:root maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="178.0" prefWidth="274.0" style="-fx-border-insets: 0; -fx-border-color: black; -fx-background-radius: 0; -fx-border-width: 0;" type="AnchorPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
      <Rectangle arcHeight="5.0" arcWidth="5.0" fill="WHITE" height="178.0" stroke="TRANSPARENT" strokeType="INSIDE" strokeWidth="0.0" style="-fx-background-radius: 0;" width="274.0">
         <effect>
            <DropShadow color="#000000b9" offsetY="5.0" />
         </effect>
      </Rectangle>
		<Rectangle fx:id="rectangle" arcWidth="5.0" fill="#ff1f1f" height="41.0" layoutY="142.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0" style="-fx-border-width: 0; -fx-background-radius: 0;" width="274.0" />
		<Label fx:id="taskName" alignment="TOP_LEFT" layoutX="14.0" layoutY="14.0" prefHeight="41.0" prefWidth="244.0" textFill="#757474">
         <font>
            <Font size="22.0" />
         </font></Label>
		<Label fx:id="date" layoutX="14.0" layoutY="62.0" prefHeight="27.0" prefWidth="244.0" textFill="#757474" />
		<Label fx:id="locationLabel" layoutX="14.0" layoutY="107.0" prefHeight="27.0" prefWidth="244.0" textFill="#757474" />
      <Label fx:id="indexLabel" alignment="CENTER" layoutX="112.0" layoutY="149.0" prefHeight="27.0" prefWidth="53.0" text="1" textAlignment="CENTER" textFill="WHITE">
         <font>
            <Font name="System Bold" size="18.0" />
         </font>
      </Label>
	</children>
	<padding>
		<Insets right="50.0" />
	</padding>
</fx:root>
```
###### Tasker\src\application\gui\CalendarItem.java
``` java
package application.gui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.shape.Rectangle;

public class CalendarItem extends AnchorPane {
	public static final String EMPTY = "";
	public static final String RED = "#EF9A9A";
	public static final String GREEN = "#A5D6A7";
	public static final String BLUE = "#B2EBF2";
	public static final String BACKGROUND_COLOR = "-fx-fill: %1$s;";
	public static final String FONT_STYLE = "-fx-text-fill: %1$s;";
	public static final String DARK_RED = "#B71C1C";

	@FXML
	private Label taskName;
	@FXML
	private Label date;
	@FXML
	private Label locationLabel;
	@FXML
	private Rectangle rectangle;
	@FXML
	private Label indexLabel;

	public CalendarItem(String name, String date, String location, String priority, int overdueCheck, int index) {
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("CalendarItem.fxml"));
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
			this.setLabels(name, date, location, priority, overdueCheck, index);

		} catch (IOException exception) {
			System.out.println("Could not load");
			throw new RuntimeException(exception);
		}

	}

	private void setLabels(String name, String date, String location, String priority, int overdueCheck, int index) {
		this.taskName.setText(name.toUpperCase());
		this.date.setText(date.toUpperCase());
		this.indexLabel.setText(EMPTY + index);
		setLocation(location.trim().toUpperCase());
		setPriorityColor(priority);
		overdueCheck(overdueCheck);
	}

	private void overdueCheck(int overdueCheck) {
		if (overdueCheck < 0) {
			rectangle.setStyle(String.format(BACKGROUND_COLOR, DARK_RED));
			this.date.setStyle(this.date.getStyle() + String.format(FONT_STYLE, DARK_RED));
		}
	}

	private void setPriorityColor(String priority) {
		switch (priority) {
		case "high":
			rectangle.setStyle(String.format(BACKGROUND_COLOR, RED));
			break;
		case "medium":
			rectangle.setStyle(String.format(BACKGROUND_COLOR, BLUE));
			break;
		case "low":
			rectangle.setStyle(String.format(BACKGROUND_COLOR, GREEN));
			break;
		default:
			rectangle.setStyle(String.format(BACKGROUND_COLOR, GREEN));
			break;
		}

	}

	private void setLocation(String location) {
		if (!location.equals(EMPTY)) {
			this.locationLabel.setText(location);
		} else {
			this.locationLabel.setText(EMPTY);
		}
	}

}
```
###### Tasker\src\application\gui\CalendarItem.java
``` java

```
###### Tasker\src\application\gui\CalendarViewPage.java
``` java
package application.gui;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Timer;
import java.util.TimerTask;

import org.controlsfx.control.Notifications;

import application.logic.Feedback;
import application.logic.Logic;
import application.storage.Task;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.StackPane;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.util.Callback;

public class CalendarViewPage extends AnchorPane {
	private ArrayList<Task> tasksOnScreen;
	private Logic logic;

	private static final String SPACE = " ";
	private static final String EMPTY_STRING = "";
	private static final String LOCATION_PREFIX = "AT";
	private static final String BACKSLASH = "\\";
	private static final String DIRECTORY_CHOOSER_TITLE = "Pick Where To Store Tasks";
	private static final String CURRENT_DIRECTORY = "user.dir";
	private static final int TASK_NUM_OFFSET = 1;
	private static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("dd MMM yyyy");
	private static final SimpleDateFormat FORMAT_YEAR = new SimpleDateFormat("yyyy");
	private static final SimpleDateFormat FORMAT_COMPARE_DATE = new SimpleDateFormat("dd/MM/yyyy HH:mm");
	private static final String LIST_FLAG = "list";
	private static final String CAL_FLAG = "cal";
	private static final String HELP_FLAG = "help";
	private static final String STORAGE_FLAG = "storage";

	// Messages
	private static final String ADD_HINT_MESSAGE = "To add: [task description] from [start] to [end] at [location]";
	private static final String HELP_HINT_MESSAGE = "To get help: help";
	private static final String DELETE_HINT_MESSAGE = "To delete: delete [task description/number]";
	private static final String SEARCH_HINT_MESSAGE = "To search: search [task decription/priority [level]/[task description] by [date]]";
	private static final String EXIT_HINT_MESSAGE = "To exit: exit";
	private static final String UPDATE_HINT_MESSAGE = "To update: update [task number] [new task desc]";
	private static final String UNDO_HINT_MESSAGE = "To undo: undo";
	private static final String STORAGE_HINT_MESSAGE = "To change storage: storage";
	private static final String DONE_HINT_MESSAGE = "To mark task as complete: done [task number]";
	private static final String MESSAGE_STORAGE_URL_NOT_FOUND = "Storage Location Invalid: Opening Directory Chooser";
	private static final String MESSAGE_HELP_INTRO = "Start typing and we'll help you out!";
	private static final String MESSAGE_FEEDBACK_INTRO = "We'll give you feedback on your commands here.";

	private static final String MESSAGE_ERROR = "There was some problem processing your request. "
			+ "Please check your input format.";

	String text = EMPTY_STRING;
	private static ArrayList<String> commands = new ArrayList<String>();
	private static int pointer = 0;
	private Task taskToFocus;
	private String checkFlag;

	@FXML
	public Label feedbackLabel;
	@FXML
	private Label helpLabel;
	@FXML
	private TextField textInputArea;
	@FXML
	private StackPane stackPane;
	@FXML
	private ListView<Task> displayList;
	@FXML
	private ListView<ArrayList<Task>> calendarList;

	public CalendarViewPage(ArrayList<Task> taskList, Logic logic) {
		tasksOnScreen = taskList;
		this.logic = logic;
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("ListView.fxml"));
		loadFromFxml(fxmlLoader);
		initialize();
		initializeInputArea();
	}

	private void loadFromFxml(FXMLLoader fxmlLoader) {
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
		} catch (IOException exception) {
			System.out.println("Could not load");
			throw new RuntimeException(exception);
		}
	}

	private void initialize() {
		helpLabel.setText(MESSAGE_HELP_INTRO);
		feedbackLabel.setText(MESSAGE_FEEDBACK_INTRO);
		initialiseCalendarList();
		initialiseDisplayList();
		taskToFocus = null;
		updateViews(tasksOnScreen, taskToFocus);
	}

	private void initialiseDisplayList() {
		displayList.setPrefSize(1070, 580);
		this.displayList.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
			public ListCell<Task> call(ListView<Task> param) {
				ListCell<Task> cell = new ListCell<Task>() {
					@Override
					public void updateItem(Task item, boolean empty) {
						super.updateItem(item, empty);
						if (item != null) {
							Calendar cal = Calendar.getInstance();
							int overdueCheck = 0;
							if (item.getEndDate() != null) {
								overdueCheck = item.getEndDate().getTime().compareTo(cal.getTime());
							}
							int taskNumber = this.getIndex() + TASK_NUM_OFFSET;
							String taskDescription = item.getTaskDescription();
							String taskDuration = item.durationToString();
							String taskLocation = getLocationString(item);
							String taskPriority = item.getPriority();
							ListItem listViewItem = new ListItem(taskNumber, taskDescription, taskDuration,
									taskLocation, taskPriority, overdueCheck);
							setGraphic(listViewItem);
						} else {
							setGraphic(null);
						}
					}
				};

				return cell;
			}
		});
	}

	private void initialiseCalendarList() {
		calendarList.setPrefSize(1070, 580);
		this.calendarList.setCellFactory(new Callback<ListView<ArrayList<Task>>, ListCell<ArrayList<Task>>>() {
			public ListCell<ArrayList<Task>> call(ListView<ArrayList<Task>> param) {
				ListCell<ArrayList<Task>> cell = new ListCell<ArrayList<Task>>() {
					@Override
					public void updateItem(ArrayList<Task> item, boolean empty) {
						super.updateItem(item, empty);
						if (item != null) {
							int index = this.getIndex() + 1;
							DateObject listViewItem = new DateObject(
									FORMAT_DATE.format(item.get(0).getEndDate().getTime()), item, index);
							index = index + item.size();
							setGraphic(listViewItem.getHbox());
						} else {
							setGraphic(null);
						}
					}
				};

				return cell;
			}
		});
	}

	private String getLocationString(Task task) {
		String location = task.getLocation();
		if (location.trim().equals(EMPTY_STRING)) {
			return EMPTY_STRING;
		} else {
			return (LOCATION_PREFIX + SPACE + location);
		}
	}

	private ArrayList<ArrayList<Task>> getDateArray(ArrayList<Task> taskList) {
		String tempoDate = null;
		ArrayList<ArrayList<Task>> dateArray = new ArrayList<ArrayList<Task>>();
		ArrayList<Task> temporaryList = new ArrayList<Task>();
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getEndDate() != null && tempoDate == null) {
				tempoDate = FORMAT_DATE.format(taskList.get(i).getEndDate().getTime());
			}

		}
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getEndDate() != null && tempoDate != null) {
				if (tempoDate.equals(FORMAT_DATE.format(taskList.get(i).getEndDate().getTime()))) {
					temporaryList.add(taskList.get(i));
				} else {
					dateArray.add(temporaryList);
					temporaryList = new ArrayList<Task>();
					temporaryList.add(taskList.get(i));
					tempoDate = FORMAT_DATE.format(taskList.get(i).getEndDate().getTime());
				}
			}
		}
		if (temporaryList.size() != 0) {
			dateArray.add(temporaryList);
		}
		return dateArray;
	}

	private void updateViews(ArrayList<Task> taskList, Task taskToFocus) {
		// Timer timer = new Timer();
		// timer.schedule(new TimerTask() {
		// public void run() {
		// Calendar cal = Calendar.getInstance();
		// System.out.println(FORMAT_COMPARE_DATE.format(cal.getTime()));
		// for (int x = 0; x < taskList.size(); x++) {
		// System.out.println(FORMAT_COMPARE_DATE.format(taskList.get(x).getEndDate().getTime())
		// .compareTo(FORMAT_COMPARE_DATE.format(cal.getTime())));
		// if
		// (FORMAT_COMPARE_DATE.format(taskList.get(x).getEndDate().getTime())
		// .compareTo(FORMAT_COMPARE_DATE.format(cal.getTime())) == 0) {
		// System.out.println("Task Overdue");
		// updateViews(taskList);
		// }
		// }
		//
		// }
		// }, 0, 60 * 250);
		updateCalendarList(taskList);
		updateDisplayList(taskList, taskToFocus);
	}

	private void notifyUser(Task taskToFocus) {
		String title = null;
		String text = null;
		if (taskToFocus != null) {
			if (taskToFocus.getEndDate() == null) {
				title = "Reminder";
				text = "No End Date Set";
			}
			if (taskToFocus.getStartDate() == null) {
				title = "Reminder";
				text = "No Start Date Set";
			}
			if (taskToFocus.getStartDate() == null && taskToFocus.getEndDate() == null) {
				title = "Reminder";
				text = "No Dates Set";
			}
			if (title != null && text != null) {
				Notifications.create().title(title).text(text).showInformation();
			}
		}
	}

	private void updateDisplayList(ArrayList<Task> taskList, Task taskToFocus) {
		this.displayList.getItems().clear();
		if (taskList.size() != 0) {
			ObservableList<Task> list = makeDisplayList(taskList);
			this.displayList.setItems(list);
			if (taskToFocus != null) {
				this.displayList.scrollTo(taskToFocus);
			}
		}
	}

	private void updateCalendarList(ArrayList<Task> taskList) {
		this.calendarList.getItems().clear();
		if (taskList.size() != 0) {
			ArrayList<ArrayList<Task>> dateArray = new ArrayList<ArrayList<Task>>();
			dateArray = getDateArray(taskList);
			ObservableList<ArrayList<Task>> calList = makeCalendarList(dateArray);
			this.calendarList.setItems(calList);
		}
	}

	private ObservableList<ArrayList<Task>> makeCalendarList(ArrayList<ArrayList<Task>> taskList) {
		ObservableList<ArrayList<Task>> calendarList = FXCollections.observableArrayList();
		for (ArrayList<Task> task : taskList) {
			calendarList.add(task);
		}
		return calendarList;

	}

	private ObservableList<Task> makeDisplayList(ArrayList<Task> taskList) {
		ObservableList<Task> displayList = FXCollections.observableArrayList();
		for (Task task : taskList) {
			displayList.add(task);
		}
		return displayList;
	}

	public void initializeInputArea() {
		textInputArea.setOnKeyPressed(new EventHandler<KeyEvent>() {

			public void handle(KeyEvent ke) {
				if (ke.getCode().equals(KeyCode.ENTER)) {
					try {
						text = textInputArea.getText();
						commands.add(text);
						if (!text.equalsIgnoreCase("view")) {
							Feedback feedback = logic.executeCommand(text, tasksOnScreen);
							System.out.println(feedback.getMessage());
							tasksOnScreen = feedback.getTasks();
							taskToFocus = feedback.getIndexToScroll();
							notifyUser(taskToFocus);
							updateViews(tasksOnScreen, taskToFocus);
							checkFlag = feedback.getFlag();
							feedbackLabel.setText(feedback.getMessage());
							doFlagCommand(checkFlag, feedback);
						} else {
							switchViews();
						}
						textInputArea.clear();
					} catch (Exception e) {
					    e.printStackTrace(System.out);
					    feedbackLabel.setText(MESSAGE_ERROR);
					}
				}
				if (ke.getCode().equals(KeyCode.UP)) {
					// if used commands list is not empty
					if (!commands.isEmpty()) {
						if (!commands.contains(textInputArea.getText())) {
							pointer = commands.size();
						} else {
							pointer = commands.indexOf(textInputArea.getText());
						}
						// if pointer is not at the front end
						if (pointer != 0) {
							textInputArea.setText(commands.get(pointer - 1));
						}
					}
				}
				if (ke.getCode().equals(KeyCode.DOWN)) {
					if (!commands.isEmpty()) {
						if (!commands.contains(textInputArea.getText())) {
							pointer = commands.size();
						} else {
							pointer = commands.indexOf(textInputArea.getText());
						}
						// if pointer is not at the end
						if (pointer != commands.size() - 1) {
							textInputArea.setText(commands.get(pointer + 1));
						}
					}
				}
			}
		});
		textInputArea.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				getHints(oldValue, newValue, helpLabel);
			}
		});

	}

	private void doFlagCommand(String checkFlag, Feedback feedback) throws IOException {
		switch (checkFlag) {
		case STORAGE_FLAG:
			promptStorage(feedback);
			break;
		case CAL_FLAG:
			calendarList.toFront();
			break;
		case HELP_FLAG:

			break;
		case LIST_FLAG:
			displayList.toFront();
			break;
		}
	}

	private void promptStorage(Feedback feedback) throws IOException {
		if (feedback.getMessage().equals(MESSAGE_STORAGE_URL_NOT_FOUND)) {
			DirectoryChooser dirChooser = new DirectoryChooser();
			configureDirectoryChooser(dirChooser);
			Stage stage = new Stage();
			directoryPrompt(stage, dirChooser);
		}
	}

	private void switchViews() {
		if (stackPane.getChildren().get(0).equals(displayList)) {
			displayList.toFront();
		} else {
			calendarList.toFront();
		}
	}

	public void directoryPrompt(Stage primaryStage, DirectoryChooser dirChooser) throws IOException {
		final File selectedDirectory = dirChooser.showDialog(primaryStage);
		if (selectedDirectory != null) {
			logic.setDirectory(selectedDirectory.getPath().toString() + BACKSLASH);
			feedbackLabel.setText("Directory Changed: " + selectedDirectory.getPath().toString() + BACKSLASH);
		} else {
			logic.setDirectory(EMPTY_STRING);
			feedbackLabel.setText("Directory Not Changed!");
		}
	}

	private void configureDirectoryChooser(final DirectoryChooser dirChooser) {
		dirChooser.setTitle(DIRECTORY_CHOOSER_TITLE);
		dirChooser.setInitialDirectory(new File(System.getProperty(CURRENT_DIRECTORY)));
	}

	private void getHints(String oldValue, String newValue, Label helpLabel) {
		String newLetter = EMPTY_STRING;
		String oldWord = EMPTY_STRING;
		String newWord = EMPTY_STRING;

		if (!oldValue.isEmpty() && oldValue != null) {
			oldWord = getFirstWord(oldValue);
		}
		if (!newValue.isEmpty() && newValue != null) {
			newWord = getFirstWord(newValue);
			newLetter = getFirstLetter(newValue);
		}

		if (newWord == null) {
			return;
		}

		if (newWord.equals(oldWord)) {
			return;
		} else {
			switch (newLetter.toLowerCase()) {
			case "a":
				helpLabel.setText(ADD_HINT_MESSAGE);
				break;
			case "h":
				helpLabel.setText(HELP_HINT_MESSAGE);
				if (!newValue.isEmpty() && newValue.length() >= 4) {
					if (!newWord.equalsIgnoreCase("help")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "d":
				if (!newValue.isEmpty() && newValue.length() > 1) {
					if (getSecondLetter(newValue).equalsIgnoreCase("do")) {
						helpLabel.setText(DONE_HINT_MESSAGE);
						if (!newValue.isEmpty() && newValue.length() >= 4) {
							if (!newWord.equalsIgnoreCase("done")) {
								helpLabel.setText(ADD_HINT_MESSAGE);
							}
						}
					}
				} else {
					helpLabel.setText(DELETE_HINT_MESSAGE);
				}
				if (!newValue.isEmpty() && newValue.length() >= 6) {
					if (!newWord.equalsIgnoreCase("delete")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "u":
				if (!newValue.isEmpty() && newValue.length() > 1) {
					if (getSecondLetter(newValue).equalsIgnoreCase("un")) {
						helpLabel.setText(UNDO_HINT_MESSAGE);
						if (!newValue.isEmpty() && newValue.length() >= 4) {
							if (!newWord.equalsIgnoreCase("undo")) {
								helpLabel.setText(ADD_HINT_MESSAGE);
							}
						}
					}
				} else {
					helpLabel.setText(UPDATE_HINT_MESSAGE);
				}
				if (!newValue.isEmpty() && newValue.length() >= 6) {
					if (!newWord.equalsIgnoreCase("update")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "e":
				helpLabel.setText(EXIT_HINT_MESSAGE);
				if (!newValue.isEmpty() && newValue.length() >= 4) {
					if (!newWord.equalsIgnoreCase("exit")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "s":
				if (!newValue.isEmpty() && newValue.length() > 1) {
					if (getSecondLetter(newValue).equalsIgnoreCase("se")) {
						helpLabel.setText(SEARCH_HINT_MESSAGE);
						if (!newValue.isEmpty() && newValue.length() >= 6) {
							if (!newWord.equalsIgnoreCase("search")) {
								helpLabel.setText(ADD_HINT_MESSAGE);
							}
						}
					}
				} else {
					helpLabel.setText(STORAGE_HINT_MESSAGE);

				}
				if (!newValue.isEmpty() && newValue.length() >= 7) {
					if (!newWord.equalsIgnoreCase("storage")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			default:
				helpLabel.setText(ADD_HINT_MESSAGE);
				break;
			}
		}
	}

	private String getFirstLetter(String input) {
		String firstLetter = input.substring(0, 1);
		return firstLetter;
	}

	private String getFirstWord(String input) {
		String[] inputArgs = input.trim().split(SPACE);
		String firstWord = inputArgs[0];
		return firstWord;
	}

	private String getSecondLetter(String input) {
		String secondLetter = input.substring(0, 2);
		return secondLetter;
	}
}
```
###### Tasker\src\application\gui\CalendarViewPage.java
``` java

```
###### Tasker\src\application\gui\Cell.java
``` java
package application.gui;

import javafx.geometry.Insets;
import javafx.scene.control.Label;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;

/**
 * 
 * @author Shawn
 *
 */

public class Cell {

	HBox taskBox = new HBox();

	Label taskNumberLabel;
	Label taskDescriptionLabel;
	Label taskDurationLabel;
	Label taskLocationLabel;

	// Constants
	private static final int RANDOM_COLOR_INDEX = 3;
	private static final String BLACK_BORDER_FX = "-fx-border-color: black; ";
	private static final String RED_BG_FX = "-fx-background-color: indianred; ";
	private static final String BLUE_BG_FX = "-fx-background-color: blue; ";
	private static final String GREEN_BG_FX = "-fx-background-color: green; ";
	private static final String WHITE_TEXT_FILL_FX = "-fx-text-fill: white; ";

	public Cell(int number, String description, String duration, String location) {

		// Color Randomizer
		int color = number % RANDOM_COLOR_INDEX;

		// Set the text of the individual tasks details
		taskNumberLabel = new Label(Integer.toString(number));
		taskDescriptionLabel = new Label(description);
		taskDurationLabel = new Label(duration);
		taskLocationLabel = new Label(location);

		// Set the padding of the individual tasks details
		taskNumberLabel.setPadding(new Insets(30, 30, 30, 30));
		taskDescriptionLabel.setPadding(new Insets(30, 30, 30, 30));
		taskDurationLabel.setPadding(new Insets(30, 30, 30, 30));
		taskLocationLabel.setPadding(new Insets(30, 30, 30, 30));

		// Set the size of the individual tasks details
		taskNumberLabel.setPrefSize(20, 100);
		taskDescriptionLabel.setPrefSize(500, 100);
		taskDurationLabel.setPrefSize(350, 100);
		taskLocationLabel.setPrefSize(200, 100);

		// Set the word wrap of the individual tasks details
		taskNumberLabel.setWrapText(true);
		taskDescriptionLabel.setWrapText(true);
		taskDurationLabel.setWrapText(true);
		taskLocationLabel.setWrapText(true);

		// Set the properties of the individual tasks details
		switch (color) {
		case 0:
			taskNumberLabel.styleProperty().set(RED_BG_FX + WHITE_TEXT_FILL_FX);
			break;
		case 1:
			taskNumberLabel.styleProperty().set(BLUE_BG_FX + WHITE_TEXT_FILL_FX);
			break;
		case 2:
			taskNumberLabel.styleProperty().set(GREEN_BG_FX + WHITE_TEXT_FILL_FX);
			break;
		}

		// Add the details to the box for a full task
		taskBox.getChildren().addAll(taskNumberLabel, taskDescriptionLabel, taskDurationLabel, taskLocationLabel);
		DropShadow dropShadow = new DropShadow();
		dropShadow.setRadius(5.0);
		dropShadow.setOffsetX(3.0);
		dropShadow.setOffsetY(3.0);
		dropShadow.setColor(Color.color(0.4, 0.5, 0.5));
		taskBox.setEffect(dropShadow);
		taskBox.styleProperty().set(BLACK_BORDER_FX);
	}

	public HBox getHBox() {
		return taskBox;
	}

}
```
###### Tasker\src\application\gui\Cell.java
``` java

```
###### Tasker\src\application\gui\DateObject.fxml
``` fxml

<?import javafx.scene.shape.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Font?>

```
###### Tasker\src\application\gui\DateObject.fxml
``` fxml

<fx:root fx:id="dateObject" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="199.0" prefWidth="1053.0" type="HBox" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<children>
      <AnchorPane prefHeight="200.0" prefWidth="200.0">
         <children>
      		<ListView fx:id="listViewItem" layoutX="50.0" orientation="HORIZONTAL" prefHeight="199.0" prefWidth="1012.0" style="-fx-background-insets: 0; -fx-border-color: transparent;" />
            <Line endX="1050.0" endY="198.0" startX="15.0" startY="198.0" stroke="#575454" strokeWidth="0.5" />
            <Label fx:id="dateLabel" alignment="CENTER" contentDisplay="CENTER" layoutX="-69.0" layoutY="82.0" prefHeight="35.0" prefWidth="190.0" rotate="-90.0" text="Label" textAlignment="CENTER" textFill="#757474">
               <font>
                  <Font size="24.0" />
               </font>
            </Label>
         </children>
      </AnchorPane>
	</children>
</fx:root>
```
###### Tasker\src\application\gui\DateObject.java
``` java
package application.gui;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Task;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.HBox;
import javafx.util.Callback;

public class DateObject extends HBox {
	public static final String EMPTY = "";

	@FXML
	public Label dateLabel;
	@FXML
	public ListView<Task> listViewItem;
	@FXML
	public HBox dateObject;

	public DateObject(String date, ArrayList<Task> taskList, int index) {
		FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("DateObject.fxml"));
		try {
			fxmlLoader.setRoot(this);
			fxmlLoader.setController(this);
			fxmlLoader.load();
			this.setLabels(date);
			ObservableList<Task> list = FXCollections.observableArrayList();
			this.listViewItem.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
				public ListCell<Task> call(ListView<Task> param) {
					ListCell<Task> cell = new ListCell<Task>() {
						@Override
						public void updateItem(Task item, boolean empty) {
							super.updateItem(item, empty);
							if (item != null) {
								int currentIndex = index + this.getIndex();
								Calendar cal = Calendar.getInstance();
								int overdueCheck = 0;
								if (item.getEndDate() != null) {
									overdueCheck = item.getEndDate().getTime().compareTo(cal.getTime());
								}
								CalendarItem calItem = new CalendarItem(item.getTaskDescription(),
										item.durationToString(), item.getLocation(), item.getPriority(), overdueCheck,
										currentIndex);
								setGraphic(calItem);
							} else {
								setGraphic(null);
							}
						}
					};

					return cell;
				}
			});
			updateListView(taskList);
		} catch (IOException exception) {
			System.out.println("Could not load");
			throw new RuntimeException(exception);
		}

	}

	private void updateListView(ArrayList<Task> taskList) {
		ObservableList<Task> list = makeDisplayList(taskList);
		this.listViewItem.setItems(list);
	}

	private ObservableList<Task> makeDisplayList(ArrayList<Task> taskList) {
		ObservableList<Task> displayList = FXCollections.observableArrayList();
		for (Task task : taskList) {
			displayList.add(task);
		}
		return displayList;
	}

	private void setLabels(String date) {
		this.dateLabel.setText(date.toUpperCase());
	}

	public HBox getHbox() {
		return this.dateObject;
	}

}
```
###### Tasker\src\application\gui\DateObject.java
``` java

```
###### Tasker\src\application\gui\ExceptionHandler.java
``` java
package application.gui;

public class ExceptionHandler extends Exception {

	public ExceptionHandler(String message) {
		super(message);
	}

}
```
###### Tasker\src\application\gui\ExceptionHandler.java
``` java

```
###### Tasker\src\application\gui\GuiMain.java
``` java
package application.gui;

import java.awt.AWTException;
import java.awt.MenuItem;
import java.awt.PopupMenu;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.FileHandler;
import java.util.logging.Logger;

import application.logger.LoggerFormat;
import application.logic.Logic;
import application.storage.Task;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;

public class GuiMain extends Application {
	private static final String APPLICATION_NAME = "Tasker";
	private static final String EMPTY_STRING = "";
	private static final String SPACE = "\\s+";
	private static final String BACKSLASH = "\\";
	private static final String CSS_URL = "application/gui/application.css";
	private static final String LOGO_URL = "robot.jpg";
	private TrayIcon trayIcon;

	private static final String DIRECTORY_CHOOSER_TITLE = "Pick Where To Store Tasks";
	private static final String CURRENT_DIRECTORY = "user.dir";
	private static final String LOGGER_NAME = "logfile";
	private static final String ERROR_LOGGER_INIT = "There was a problem trying to initialise logger.";

	private static final String SYSTEM_TRAY_HINT = "Tasker is still running in the background.";

	private static final String SHOW_MENU_TEXT = "Show";
	private static final String EXIT_MENU_TEXT = "Exit";

	private Logic logic;
	private Logger logger;
	private ArrayList<Task> taskList;

	public static void main(String[] args) {
		launch(args);
	}

	@Override
	public void start(Stage primaryStage) throws ExceptionHandler {
		try {
			setEnvironment();
			initializeSaveDirectory(primaryStage);
			CalendarViewPage page = new CalendarViewPage(taskList, logic);
			Platform.setImplicitExit(false);
			Scene scene = new Scene(page);
			scene.getStylesheets().clear();
			scene.getStylesheets().add(CSS_URL);
			primaryStage.setScene(scene);
			customiseGUIMenuBar(primaryStage);
			primaryStage.setResizable(false);
			primaryStage.show();
			createTrayIcon(primaryStage);
		} catch (IOException e) {
			e.printStackTrace();
			throw new ExceptionHandler("Failed to load GUI");
		}
	}

	private void customiseGUIMenuBar(Stage primaryStage) {
		setProgramName(primaryStage);
		//setProgramLogo(primaryStage);
	}

	private void setProgramName(Stage primaryStage) {
		primaryStage.setTitle(APPLICATION_NAME);
	}

	private void setProgramLogo(Stage primaryStage) {

		primaryStage.getIcons().add(new Image(ResourceLoader.load(LOGO_URL)));
	}

	private void setEnvironment() {
		this.logic = new Logic();
		this.logger = Logger.getLogger(LOGGER_NAME);
		initializeLogger();
	}

	private void initializeSaveDirectory(Stage primaryStage) throws IOException {
		if (!logic.checkIfFileExists()) {
			DirectoryChooser dirChooser = new DirectoryChooser();
			configureDirectoryChooser(dirChooser);
			directoryPrompt(primaryStage, dirChooser);
			taskList = logic.loadDataFile();
		} else {
			taskList = logic.loadDataFile();
		}
	}

	public void directoryPrompt(Stage primaryStage, DirectoryChooser dirChooser) throws IOException {
		final File selectedDirectory = dirChooser.showDialog(primaryStage);
		if (selectedDirectory != null) {
			logic.setDirectory(selectedDirectory.getPath().toString() + BACKSLASH);
		} else {
			logic.setDirectory(EMPTY_STRING);
		}
	}

	private void configureDirectoryChooser(final DirectoryChooser dirChooser) {
		dirChooser.setTitle(DIRECTORY_CHOOSER_TITLE);
		dirChooser.setInitialDirectory(new File(System.getProperty(CURRENT_DIRECTORY)));
	}

	private void initializeLogger() {
		try {
			FileHandler fileHandler = new FileHandler("logfile.txt", true);
			LoggerFormat formatter = new LoggerFormat();
			fileHandler.setFormatter(formatter);
			logger.setUseParentHandlers(false);
			logger.addHandler(fileHandler);
		} catch (IOException e) {
			System.out.println(ERROR_LOGGER_INIT);
		}
	}

	// Create Tray Icon
	public void createTrayIcon(Stage primaryStage) {
		if (SystemTray.isSupported()) {
			SystemTray tray = SystemTray.getSystemTray();
			setToTray(primaryStage);

			ActionListener showListener = showApplication(primaryStage);
			ActionListener closeListener = closeTray();

			PopupMenu popup = popupMenuConfiguration(closeListener, showListener);

			trayIconConfiguration(showListener, popup);

			try {
				tray.add(trayIcon);
			} catch (AWTException e) {
				System.err.println(e);
			}

		}
	}

	// Configuration for Tray Icon
	private void trayIconConfiguration(ActionListener showListener, PopupMenu popup) {
		java.awt.Image image = Toolkit.getDefaultToolkit().getImage("src/application/gui/files/" + LOGO_URL);
		trayIcon = new TrayIcon(image, APPLICATION_NAME, popup);
		trayIcon.setImageAutoSize(false);
		trayIcon.addActionListener(showListener);
	}

	// Show Application Menu
	private ActionListener showApplication(Stage primaryStage) {
		ActionListener showListener = new ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						logger.info("Clicked show on system tray icon");
						primaryStage.show();
						primaryStage.setIconified(false);
					}
				});
			}
		};
		return showListener;
	}

	// Close Menu
	private ActionListener closeTray() {
		ActionListener closeListener = new ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent e) {
				logger.info("Clicked close on system tray icon");
				System.exit(0);
			}
		};
		return closeListener;
	}

	// Minimize to tray
	private void setToTray(Stage primaryStage) {
		primaryStage.setOnCloseRequest(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent t) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						if (SystemTray.isSupported()) {
							primaryStage.hide();
							showProgramIsMinimizedMsg();
						} else {
							System.exit(0);
						}
					}
				});
			}
		});
	}

	// create a popup menu for right clicking system tray icon
	private PopupMenu popupMenuConfiguration(final ActionListener closeListener, ActionListener showListener) {
		PopupMenu popup = new PopupMenu();

		MenuItem showItem = new MenuItem(SHOW_MENU_TEXT);
		showItem.addActionListener(showListener);
		popup.add(showItem);

		MenuItem closeItem = new MenuItem(EXIT_MENU_TEXT);
		closeItem.addActionListener(closeListener);
		popup.add(closeItem);
		return popup;
	}

	// Message when minimized
	public void showProgramIsMinimizedMsg() {
		trayIcon.displayMessage(APPLICATION_NAME, SYSTEM_TRAY_HINT, TrayIcon.MessageType.INFO);
	}

}
```
###### Tasker\src\application\gui\GuiMain.java
``` java

```
###### Tasker\src\application\gui\ListItem.java
``` java
	
	private void overdueCheck(int overdueCheck) {
		if (overdueCheck < 0) {
			listNumber.setStyle(String.format(BACKGROUND_STYLE, DARK_RED));
			this.date.setStyle(this.date.getStyle() + String.format(FONT_STYLE, DARK_RED));
		}
	}

	private void setBackground(String priority) {
		switch (priority) {
		case "high":
			listNumber.setStyle(String.format(BACKGROUND_STYLE, RED));
			break;
		case "medium":
			listNumber.setStyle(String.format(BACKGROUND_STYLE, BLUE));
			break;
		case "low":
			listNumber.setStyle(String.format(BACKGROUND_STYLE, GREEN));
			break;
		default:
			listNumber.setStyle(String.format(BACKGROUND_STYLE, GREEN));
			break;
		}

	}
```
###### Tasker\src\application\gui\ListView.fxml
``` fxml
		<StackPane fx:id="stackPane" layoutX="23.0" layoutY="184.0"
			prefHeight="579.0" prefWidth="1066.0" style="-fx-background-insets: 0;">
			<children>
				<ListView fx:id="displayList" prefHeight="575.0" prefWidth="1066.0"
					style="-fx-background-insets: 0;" />
				<ListView fx:id="calendarList" prefHeight="575.0"
					prefWidth="1066.0" style="-fx-background-insets: 0;" />
			</children>
		</StackPane>
```
###### Tasker\src\application\gui\ListView.fxml
``` fxml
	</children>
	<effect>
		<DropShadow />
	</effect>
</fx:root>
```
###### Tasker\src\application\gui\OpeningPage.java
``` java
	private void initialize() {
		helpLabel.setText(MESSAGE_HELP_INTRO);
		feedbackLabel.setText(MESSAGE_FEEDBACK_INTRO);
		displayList.setPrefSize(1070, 580);
		this.displayList.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
			public ListCell<Task> call(ListView<Task> param) {
				ListCell<Task> cell = new ListCell<Task>() {
					@Override
					public void updateItem(Task item, boolean empty) {
						super.updateItem(item, empty);
						if (item != null) {
							int taskNumber = this.getIndex() + TASK_NUM_OFFSET;
							String taskDescription = item.getTaskDescription();
							String taskDuration = item.durationToString();
							String taskLocation = getLocationString(item);

							ListItem listViewItem = new ListItem(taskNumber, taskDescription, taskDuration,
									taskLocation);
							setGraphic(listViewItem);
						} else {
							setGraphic(null);
						}
					}
				};

				return cell;
			}
		});
		updateListView(tasksOnScreen);
	}
```
###### Tasker\src\application\gui\OpeningPage.java
``` java
	public void initializeInputArea() {
		textInputArea.setOnKeyPressed(new EventHandler<KeyEvent>() {

			public void handle(KeyEvent ke) {
				if (ke.getCode().equals(KeyCode.ENTER)) {
					try {
						text = textInputArea.getText();
						commands.add(text);
						Feedback feedback = logic.executeCommand(text, tasksOnScreen);
						System.out.println(feedback.getMessage());
						tasksOnScreen = feedback.getTasks();
						updateListView(tasksOnScreen);
						feedbackLabel.setText(feedback.getMessage());
						if (feedback.getMessage().equals(MESSAGE_STORAGE_URL_NOT_FOUND)) {
							DirectoryChooser dirChooser = new DirectoryChooser();
							configureDirectoryChooser(dirChooser);
							Stage stage = new Stage();
							directoryPrompt(stage, dirChooser);
						}
						textInputArea.clear();
					} catch (Exception e) {
						feedbackLabel.setText(MESSAGE_ERROR);
					}
				}
				if (ke.getCode().equals(KeyCode.UP)) {
					// if used commands list is not empty
					if (!commands.isEmpty()) {
						if (!commands.contains(textInputArea.getText())) {
							pointer = commands.size();
						} else {
							pointer = commands.indexOf(textInputArea.getText());
						}
						// if pointer is not at the front end
						if (pointer != 0) {
							textInputArea.setText(commands.get(pointer - 1));
						}
					}
				}
				if (ke.getCode().equals(KeyCode.DOWN)) {
					if (!commands.isEmpty()) {
						if (!commands.contains(textInputArea.getText())) {
							pointer = commands.size();
						} else {
							pointer = commands.indexOf(textInputArea.getText());
						}
						// if pointer is not at the end
						if (pointer != commands.size() - 1) {
							textInputArea.setText(commands.get(pointer + 1));
						}
					}
				}
			}
		});
		textInputArea.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				getHints(oldValue, newValue, helpLabel);
			}
		});

	}

	public void directoryPrompt(Stage primaryStage, DirectoryChooser dirChooser) throws IOException {
		final File selectedDirectory = dirChooser.showDialog(primaryStage);
		if (selectedDirectory != null) {
			logic.setDirectory(selectedDirectory.getPath().toString() + BACKSLASH);
			feedbackLabel.setText("Directory Changed: " + selectedDirectory.getPath().toString() + BACKSLASH);
		} else {
			logic.setDirectory(EMPTY_STRING);
			feedbackLabel.setText("Directory Not Changed!");
		}
	}

	private void configureDirectoryChooser(final DirectoryChooser dirChooser) {
		dirChooser.setTitle(DIRECTORY_CHOOSER_TITLE);
		dirChooser.setInitialDirectory(new File(System.getProperty(CURRENT_DIRECTORY)));
	}

	private void getHints(String oldValue, String newValue, Label helpLabel) {
		String newLetter = EMPTY_STRING;
		String oldWord = EMPTY_STRING;
		String newWord = EMPTY_STRING;

		if (!oldValue.isEmpty() && oldValue != null) {
			oldWord = getFirstWord(oldValue);
		}
		if (!newValue.isEmpty() && newValue != null) {
			newWord = getFirstWord(newValue);
			newLetter = getFirstLetter(newValue);
		}

		if (newWord == null) {
			return;
		}

		if (newWord.equals(oldWord)) {
			return;
		} else {
			switch (newLetter.toLowerCase()) {
			case "a":
				helpLabel.setText(ADD_HINT_MESSAGE);
				break;
			case "h":
				helpLabel.setText(HELP_HINT_MESSAGE);
				if (!newValue.isEmpty() && newValue.length() >= 4) {
					if (!newWord.equalsIgnoreCase("help")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "d":
				if (!newValue.isEmpty() && newValue.length() > 1) {
					if (getSecondLetter(newValue).equalsIgnoreCase("do")) {
						helpLabel.setText(DONE_HINT_MESSAGE);
						if (!newValue.isEmpty() && newValue.length() >= 4) {
							if (!newWord.equalsIgnoreCase("done")) {
								helpLabel.setText(ADD_HINT_MESSAGE);
							}
						}
					}
				} else {
					helpLabel.setText(DELETE_HINT_MESSAGE);
				}
				if (!newValue.isEmpty() && newValue.length() >= 6) {
					if (!newWord.equalsIgnoreCase("delete")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "u":
				if (!newValue.isEmpty() && newValue.length() > 1) {
					if (getSecondLetter(newValue).equalsIgnoreCase("un")) {
						helpLabel.setText(UNDO_HINT_MESSAGE);
						if (!newValue.isEmpty() && newValue.length() >= 4) {
							if (!newWord.equalsIgnoreCase("undo")) {
								helpLabel.setText(ADD_HINT_MESSAGE);
							}
						}
					}
				} else {
					helpLabel.setText(UPDATE_HINT_MESSAGE);
				}
				if (!newValue.isEmpty() && newValue.length() >= 6) {
					if (!newWord.equalsIgnoreCase("update")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "e":
				helpLabel.setText(EXIT_HINT_MESSAGE);
				if (!newValue.isEmpty() && newValue.length() >= 4) {
					if (!newWord.equalsIgnoreCase("exit")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			case "s":
				if (!newValue.isEmpty() && newValue.length() > 1) {
					if (getSecondLetter(newValue).equalsIgnoreCase("se")) {
						helpLabel.setText(SEARCH_HINT_MESSAGE);
						if (!newValue.isEmpty() && newValue.length() >= 6) {
							if (!newWord.equalsIgnoreCase("search")) {
								helpLabel.setText(ADD_HINT_MESSAGE);
							}
						}
					}
				} else {
					helpLabel.setText(STORAGE_HINT_MESSAGE);

				}
				if (!newValue.isEmpty() && newValue.length() >= 7) {
					if (!newWord.equalsIgnoreCase("storage")) {
						helpLabel.setText(ADD_HINT_MESSAGE);
					}
				}
				break;
			default:
				helpLabel.setText(ADD_HINT_MESSAGE);
				break;
			}
		}
	}
```
###### Tasker\src\application\gui\ResourceLoader.java
``` java
package application.gui;

import java.io.InputStream;

import javax.annotation.Resource;

public class ResourceLoader {
	public static InputStream load(String path) {
		InputStream input = ResourceLoader.class.getResourceAsStream(path);
		if (input == null) {
			input = Resource.class.getResourceAsStream("/" + path);
		}
		return input;
	}
}
```
###### Tasker\src\application\gui\ResourceLoader.java
``` java

```
###### Tasker\src\application\gui\TaskListView.java
``` java
package application.gui;

import java.text.SimpleDateFormat;
import java.util.ArrayList;

import application.storage.Task;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.util.Callback;

public class TaskListView {
	private ObservableList<Task> items = FXCollections.observableArrayList();
	private ListView<Task> listView = new ListView<Task>(items);

	// Constants
	private static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("dd-MM-yyyy");
	private static final SimpleDateFormat FORMAT_TIME = new SimpleDateFormat("h:mm a");
	private static final SimpleDateFormat FORMAT_YEAR = new SimpleDateFormat("yyyy");
	private static final String EMPTY_STRING = "";
	private static final String LOCATION_AT = "At ";
	private static final String BY = "By ";
	private static final String SPACE = " ";
	private static final String EMPTY_DATE = "0001";
	private static final String DATE_TO_DATE = " to ";
	private static final int TASK_NUM_OFFSET = 1;

	private static String LOCATION_INFO = LOCATION_AT + "%1$s";
	private static String DURATION_SAME_DATE_INFO = "%1$s" + SPACE + "%2$s" + DATE_TO_DATE + "%3$s";
	private static String DURATION_DIFF_DATE_INFO = "%1$s" + SPACE + "%2$s" + DATE_TO_DATE + "%3$s" + SPACE + "%4$s";
	private static String DURATION_END_DATE_INFO = BY + "%1$s" + SPACE + "%2$s";
	private static String DURATION_END_DATE_ONLY_INFO = BY + "%1$s";

	public void createTaskListView(Pane parent) {
		BorderPane pane = new BorderPane();
		addDataToListView(pane);

		parent.getChildren().add(pane);
	}

	private void addDataToListView(BorderPane pane) {
		listView.setPrefSize(2500, 2500);
		listView.setCellFactory(new Callback<ListView<Task>, ListCell<Task>>() {
			public ListCell<Task> call(ListView<Task> param) {
				ListCell<Task> cell = new ListCell<Task>() {
					@Override
					public void updateItem(Task item, boolean empty) {
						super.updateItem(item, empty);
						if (item != null) {
							int taskNumber = this.getIndex() + TASK_NUM_OFFSET;
							String taskDescription = item.getTaskDescription();
							String taskDuration = setDurationDetails(item);
							String taskLocation = setLocationDetails(item);
							Cell cells = new Cell(taskNumber, taskDescription, taskDuration, taskLocation);

							setGraphic(cells.getHBox());
						} else {
							setGraphic(null);
						}
					}
				};

				return cell;
			}
		});
		pane.setCenter(listView);
	}

	public void updateList(ArrayList<Task> tasks) {

		items.clear();

		for (int i = 0; i < tasks.size(); i++) {
			items.add(tasks.get(i));
		}

		listView.setItems(items);
	}

	private String setDurationDetails(Task item) {
		String taskDuration = EMPTY_STRING;

		if (!FORMAT_YEAR.format(item.getStartDate().getTime()).equals(EMPTY_DATE)) {
			if (FORMAT_DATE.format(item.getStartDate().getTime())
					.equals(FORMAT_DATE.format(item.getEndDate().getTime()))) {
				taskDuration = String.format(DURATION_SAME_DATE_INFO, FORMAT_DATE.format(item.getStartDate().getTime()),
						FORMAT_TIME.format(item.getStartTime().getTime()),
						FORMAT_TIME.format(item.getEndTime().getTime()));
			} else {
				taskDuration = String.format(DURATION_DIFF_DATE_INFO, FORMAT_DATE.format(item.getStartDate().getTime()),
						FORMAT_TIME.format(item.getStartTime().getTime()),
						FORMAT_DATE.format(item.getEndDate().getTime()),
						FORMAT_TIME.format(item.getEndTime().getTime()));
			}
		} else {
			if (!FORMAT_YEAR.format(item.getEndDate().getTime()).equals(EMPTY_DATE)) {
				if (!FORMAT_TIME.format(item.getEndTime().getTime()).equals("0:00")) {
					taskDuration = String.format(DURATION_END_DATE_INFO,
							FORMAT_DATE.format(item.getEndDate().getTime()),
							FORMAT_TIME.format(item.getEndTime().getTime()));
				} else {
					taskDuration = String.format(DURATION_END_DATE_ONLY_INFO,
							FORMAT_DATE.format(item.getEndDate().getTime()));
				}
			} else {
				taskDuration = EMPTY_STRING;
			}
		}
		return taskDuration;
	}

	private String setLocationDetails(Task item) {
		String taskLocation = EMPTY_STRING;

		if (!item.getLocation().equals(EMPTY_STRING)) {
			taskLocation = String.format(LOCATION_INFO, item.getLocation());
		} else {
			taskLocation = EMPTY_STRING;
		}
		return taskLocation;
	}

}
```
###### Tasker\src\application\gui\TaskListView.java
``` java

```
###### Tasker\src\application\logger\LoggerFormat.java
``` java
package application.logger;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Formatter;
import java.util.logging.Handler;
import java.util.logging.LogRecord;

/**
 * 
 * @author Shawn
 *
 */

public class LoggerFormat extends Formatter {

	private static final String HEADER = " Start ";
	private static final String TAIL = "  End  ";
	private static final String NEXT_LINE = "\n";
	private static final String PADDING = " ---------------------- ";
	private static final String SEPARATOR = " - ";

	private static final String DATE_FORMAT = "dd.MM.yyyy hh:mm:ss";
	private static final DateFormat DF = new SimpleDateFormat(DATE_FORMAT);

	@Override
	public String format(LogRecord log) {
		String date = DF.format(new Date(log.getMillis()));
		String className = log.getSourceClassName();
		String methodName = log.getSourceMethodName();
		String level = String.format("%-7s", log.getLevel().toString());
		String message = formatMessage(log);
		String logMessage = date + SEPARATOR + level + SEPARATOR + className + SEPARATOR + methodName + SEPARATOR
				+ message + NEXT_LINE;
		return logMessage;
	}

	public String getHead(Handler handler) {
		String logHead = PADDING + HEADER + new Date() + PADDING + NEXT_LINE;
		return logHead;
	}

	public String getTail(Handler handler) {
		String logTail = PADDING + TAIL + new Date() + PADDING + NEXT_LINE;
		return logTail;
	}

}
```
###### Tasker\src\application\logger\LoggerFormat.java
``` java

```
###### Tasker\src\application\logic\ChangeStorageLocation.java
``` java
package application.logic;

import java.io.File;
import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;

public class ChangeStorageLocation implements Command {
	private static final String EMPTY_STRING = "";
	private static final String MESSAGE_STORAGE_URL_NOT_FOUND = "Storage Location Invalid: Opening Directory Chooser";
	private static final String MESSAGE_STORAGE_URL_FOUND = "Storage changed: ";
	String arguments;

	ChangeStorageLocation(String arguments) {
		this.arguments = arguments;
		interpretArguments(arguments);
	}

	private void interpretArguments(String arguments) {
		setNewStorageLocation(arguments);
	}

	// storage and click on a new folder after prompt
	private void setNewStorageLocation(String arguments) {

	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasksOnScreen) {
		if (arguments != EMPTY_STRING) {
			if (new File(arguments).isDirectory()) {
				Feedback feedback = new Feedback(MESSAGE_STORAGE_URL_FOUND, tasksOnScreen, null);
				feedback.setCalFlag();
				return feedback;
			}
		}
		Feedback feedback = new Feedback(MESSAGE_STORAGE_URL_NOT_FOUND, tasksOnScreen, null);
		feedback.setStorageFlag();
		return feedback;
	}
}
```
###### Tasker\src\application\logic\ChangeStorageLocation.java
``` java

```
###### Tasker\src\application\logic\Exit.java
``` java
package application.logic;

import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;

public class Exit implements Command {

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		System.exit(0);
		return null;
	}
}
```
###### Tasker\src\application\logic\Exit.java
``` java

```
###### Tasker\src\application\logic\Logic.java
``` java
	public void setDirectory(String file) throws IOException {
        storageConnector.setDirectory(file);
    }

	
	public ArrayList<Task> loadDataFile() throws IOException {
		storageConnector.initialise();
		return storageConnector.getOpenList();
	}

	// if false means user first time starting program
	public boolean checkIfFileExists() throws IOException {
		return storageConnector.directoryExists();
	}

```
###### Tasker\src\application\logic\Logic.java
``` java
/*
	public Feedback executeCommand(String command)throws NoDescriptionException {
        Feedback feedback;
        Command cmd = parser.interpretCommand(command);
        logger.info("executing above parsed command");
        feedback = cmd.execute(storageConnector, tasksOnScreen);
        logger.info("adding command to history");
        history.add(cmd);
        logger.info("saving tasks to file.");
        //storage.saveFile();
        return feedback;
    }
    
	*/
```
###### Tasker\src\application\logic\Logic.java
``` java
	// for UI
	
	public Feedback executeCommand(String command,  ArrayList<Task> tasksOnScreen)throws NoDescriptionException {
		Feedback feedback;
		Command cmd = parser.interpretCommand(command);
		logger.info("executing above parsed command");
		feedback = cmd.execute(storageConnector, tasksOnScreen);
		logger.info("adding command to history");
		history.add(cmd);
		logger.info("saving tasks to file.");
		//storage.saveFile();
		return feedback;
	}


}
```
###### Tasker\src\application\logic\Logic.java
``` java

```
###### Tasker\src\application\logic\LogicJUnit.java
``` java
package application.logic;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.IOException;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import application.storage.Task;

/**
 * 
 * @author Shawn
 *
 */

public class LogicJUnit {
	private Logic logic = new Logic();

	@Before
	@Test
	public void beforeTestLoad() throws IOException {
		ArrayList<Task> tasklist = new ArrayList<Task>();
		tasklist = logic.loadDataFile();
		assertTrue(tasklist.size() >= 0);
	}

	@Test
	public void testAddDelete() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = new ArrayList<Task>();
		tasklist = logic.loadDataFile();
		Feedback fb = logic.executeCommand("play dota from 30 april 1pm to 2pm at home", tasklist);
		assertEquals("Added Task: \"play dota, from 30-04-2016 1:00 PM to 30-04-2016 2:00 PM, at home\"",
				fb.getMessage());
		fb = logic.executeCommand("delete 1", tasklist);
		assertEquals("Deleted Task: \"play dota, from 30-04-2016 1:00 PM to 30-04-2016 2:00 PM, at home\"",
				fb.getMessage());
	}

	@Test
	public void testDeleteFail() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = new ArrayList<Task>();
		tasklist = logic.loadDataFile();
		Feedback fb = logic.executeCommand("play dota from 30 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("delete 0", tasklist);
		assertEquals("Please enter a valid number.", fb.getMessage());
		logic.executeCommand("delete 1", tasklist);
	}

	@Test
	public void testSearch() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = new ArrayList<Task>();
		tasklist = logic.loadDataFile();
		Feedback fb = logic.executeCommand("play dota from 30 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("search dota", tasklist);
		assertEquals(fb.getMessage(), "Here are the results of your search!");
		assertTrue(fb.getTasks().size() == 1);
		fb = logic.executeCommand("search by 30/6/2016", tasklist);
		assertTrue(fb.getTasks().size() == 2);
		System.out.println(fb.getTasks().size());
		fb = logic.executeCommand("search on 30/6/2016", tasklist);
		assertEquals(fb.getMessage(), "Search Not Found");
		fb = logic.executeCommand("delete 1", tasklist);
		fb = logic.executeCommand("delete 1", tasklist);
	}

	@Test
	public void testUpdate() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = new ArrayList<Task>();
		tasklist = logic.loadDataFile();
		Feedback fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("update 1 play dota", tasklist);
		assertEquals(fb.getMessage(),
				"Updated Task: From: \"play dot, from 01-04-2016 1:00 PM to 01-04-2016 2:00 PM, at home\"\nTo: \"play dota, from 01-04-2016 1:00 PM to 01-04-2016 2:00 PM, at home\"");
		fb = logic.executeCommand("delete 1", tasklist);
	}

	@Test
	public void testDone() throws NoDescriptionException, IOException {
		ArrayList<Task> tasklist = new ArrayList<Task>();
		tasklist = logic.loadDataFile();
		Feedback fb = logic.executeCommand("play dot from 1 april 1pm to 2pm at home", tasklist);
		fb = logic.executeCommand("done 1", tasklist);
		assertTrue(fb.getTasks().size() == 0);
	}

}
```
###### Tasker\src\application\logic\LogicJUnit.java
``` java

```
###### Tasker\src\application\logic\Parser.java
``` java
	// Requests the logic to call for new storage location from the GUI then
	// sends the data to Storage
	private Command initializeStorageLocation(String[] args) {
		Command command = null;
		if (args.length == 2) {
			command = new ChangeStorageLocation(args[1]);
		} else {
			command = new ChangeStorageLocation("");
		}
		return command;
	}

	private Command initializeExit() {
		Command command = new Exit();
		return command;
	}

```
###### Tasker\src\application\logic\Parser.java
``` java
	private Command getAppropSearchCommand(String[] args) {
		try {
			return getSearchCommand(args);
		} catch (NotDateException e) {
			return getSearchByName(args);
		}

	}

```
###### Tasker\src\application\logic\Parser.java
``` java
	private Command getSearchCommand(String[] args) throws NotDateException {
		String[] argsForDate = (String[]) ArrayUtils.remove(args, 0);
		if (args[0].equalsIgnoreCase("by")) {
			return getSearchByDateCommand(argsForDate);
		} else if (args[0].equalsIgnoreCase("on")) {
			return getSearchOnDateCommand(argsForDate);
		} else {
			return getSearchByName(args);
		}
	}
```
###### Tasker\src\application\logic\Parser.java
``` java

	private Command getSearchByName(String[] args) {
		String taskName = getString(args, 0, args.length - 1);
		Command cmd = new SearchByName(taskName);
		return cmd;
	}

	private Command getSearchOnDateCommand(String[] args) throws NotDateException {
		Calendar date = getDateForSearch(args);
		Command cmd = new SearchOnDate(date);
		return cmd;
	}

	private Command getSearchByDateCommand(String[] args) throws NotDateException {
		Calendar date = getDateForSearch(args);
		Command cmd = new SearchByDate(date);
		return cmd;
	}

	private Calendar getDateForSearch(String[] args) throws NotDateException {
		String dateString = getString(args, 0, args.length - 1);
		List<Date> dates1 = dateParser.parse(dateString);
		List<Date> dates2 = dateParser.parse(dateString);
		if (dates1.size() == 0) {
			throw new NotDateException();
		}
		LocalDateTime date = fixDateForSearch(dates1.get(0), dates2.get(0));
		return convertToCalendar(date);
	}

	private LocalDateTime fixDateForSearch(Date date1, Date date2) {
		if (date1.equals(date2)) {
			return new LocalDateTime(date1);
		} else {
			LocalDateTime date = new LocalDateTime(date1);
			date = date.withHourOfDay(23);
			date = date.withMinuteOfHour(59);
			date = date.withSecondOfMinute(59);
			return date;
		}
	}

	private Command getAppropDeleteCommand(String[] args) {
		if (args.length == 1) {
			int index = Integer.parseInt(args[0]) - ARRAY_INDEXING_OFFSET;
			Command command = new DeleteByNum(index);
			return command;
		} else {
			return getCommandDeleteByName(args);
		}
	}

	private Command getCommandDeleteByName(String[] args) {
		String taskToDelete = getString(args, 0, args.length - 1);
		Command command = new DeleteByName(taskToDelete);
		return command;
	}

	private Command getAppropDoneCommand(String[] args) {
		if (args.length == 1) {
			int index = Integer.parseInt(args[0]) - ARRAY_INDEXING_OFFSET;
			Command command = new DoneByNum(index);
			return command;
		} else {
			return getCommandDoneByName(args);
		}
	}

	private Command getCommandDoneByName(String[] args) {
		String taskToDelete = getString(args, 0, args.length - 1);
		Command command = new DoneByName(taskToDelete);
		return command;
	}

	private Calendar[] parseDates(String[] segments) {
		String dateString = segments[DATE_POS];
		String dateTypeKeyword = dateString.split("\\s+")[0];
		List<Date> tempDates1 = dateParser.parse(dateString);
		List<Date> tempDates2 = dateParser.parse(dateString);
		changeSegmentsIfNeeded(segments, tempDates1.size());
		Calendar startDate = getStartDate(dateTypeKeyword, tempDates1, tempDates2);
		Calendar endDate = getEndDate(dateTypeKeyword, tempDates1, tempDates2);
		System.out.println(startDate);
		System.out.println(endDate);
		Calendar[] dates = { startDate, endDate };
		return dates;
	}

	private void changeSegmentsIfNeeded(String[] segments, int size) {
		if (size == 0) {
			segments[DESC_POS] = segments[DESC_POS].trim() + " " + segments[DATE_POS];
			segments[DESC_POS] = segments[DESC_POS].trim();
		}
	}

	private Calendar getStartDate(String keyword, List<Date> tempDates1, List<Date> tempDates2) {
		LocalDateTime date;
		if (tempDates1.size() == 0) {
			date = null;
		} else if (tempDates1.size() == 1) {
		    if (Arrays.asList(DATE_MARKERS_START).indexOf(keyword) != -1){
		        date = fixDate(tempDates1.get(0), tempDates2.get(0));
		    }else if (Arrays.asList(DATE_MARKERS_END).indexOf(keyword) != -1){
		        date = createEmptyDate();
		    }else if (Arrays.asList(DATE_MARKERS_FULL_DAY_EVENT).indexOf(keyword) != -1){
		        date = fixDate(tempDates1.get(0), tempDates2.get(0));
		        date = date.withMillisOfDay(0);
		    }else{
		        date = null;
		    }
		} else {
			date = fixDate(tempDates1.get(0), tempDates2.get(0));
		}
		//System.out.println(date);
		return convertToCalendar(date);
	}

	
	
	private Calendar getEndDate(String keyword, List<Date> tempDates1, List<Date> tempDates2) {
		LocalDateTime date;
		if (tempDates1.size() == 0) {
			date = null;
		} else if (tempDates1.size() == 1) {
		    if (Arrays.asList(DATE_MARKERS_START).indexOf(keyword) != -1){
                date = createEmptyDate();
            }else if (Arrays.asList(DATE_MARKERS_FULL_DAY_EVENT).indexOf(keyword) != -1){
                date = fixDate(tempDates1.get(0), tempDates2.get(0));
                date = date.withTime(23, 59, 59, 999);
            }else{
                date = fixDate(tempDates1.get(0), tempDates2.get(0));
            }
		} else {
			date = fixDate(tempDates1.get(1), tempDates2.get(1));
		}
		//System.out.println(date);
		return convertToCalendar(date);
	}

	private Calendar[] fixDatesForAdd(Calendar[] dates){
	    Calendar startDate = dates[0];
	    Calendar endDate = dates[1];
	    if (startDate != null){
	        if (startDate.equals(convertToCalendar(createEmptyDate()))){
               startDate = (Calendar) endDate.clone();
               startDate.add(Calendar.HOUR, - DEFAULT_EVENT_DURATION); 
               
            } else if (endDate.equals(convertToCalendar(createEmptyDate()))){
                endDate = (Calendar) startDate.clone();
                endDate.add(Calendar.HOUR, + DEFAULT_EVENT_DURATION); 
            }
        }
        Calendar[] fixedDates = {startDate, endDate};
        return fixedDates;
	}
	
	private Calendar[] fixDatesForUpdate(Calendar[] dates){
        Calendar startDate = dates[0];
        Calendar endDate = dates[1];
        if (endDate == null && startDate == null){
            endDate = convertToCalendar(createEmptyDate());
            startDate = convertToCalendar(createEmptyDate());
        }
        Calendar[] fixedDates = {startDate, endDate};
        System.out.println("START:" + startDate);
        System.out.println("END:" + endDate);
        return fixedDates;
    }
    
	
	private LocalDateTime fixDate(Date date1, Date date2) {
		if (date1.equals(date2)) {
			return new LocalDateTime(date1);
		} else {
			LocalDateTime date = new LocalDateTime(date1);
			date = date.withMillisOfDay(1);
			System.out.println(date);
			return date;
		}
	}

	private LocalDateTime createEmptyDate() {
		LocalDateTime date = new LocalDateTime();
		date = date.withYear(1);
		date = date.withMillisOfDay(1);
		return date;
	}

	private Calendar convertToCalendar(LocalDateTime date) {
		if ( date == null){
		    return null;
		}
		Date temp = date.toDate();
		Calendar cal = Calendar.getInstance();
		cal.setTime(temp);
		return cal;
	}

	private String[] getSegments(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
		String description = getDescription(dateIndex, locationIndex,priorityIndex, args);
		String date = getDateString(dateIndex, locationIndex,priorityIndex, args);
		String location = getLocationString(dateIndex, locationIndex,priorityIndex, args);
		String priority = getPriority(priorityIndex, args);
		String[] segments = new String[ARGUMENT_NUMBER];
		System.out.println(description);
		segments[DESC_POS] = description.trim();
		segments[DATE_POS] = date;
		segments[LOC_POS] = location.trim();
		segments[PRI_POS] = priority.trim();
		return segments;
	}

	private String getPriority(int priorityIndex, String[] args){
	    if (priorityIndex == -1){
	        return EMPTY;
	    } else{
	        return args[priorityIndex + 1];
	    }
	}
	
	private String getDescription(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
		String description;
		int end = args.length;
		if (priorityIndex != -1){
		    end = priorityIndex;
		}
		if (dateIndex == -1 && locationIndex == -1) {
			description = getString(args, 0, end - 1);
		} else if ((dateIndex < locationIndex || locationIndex == -1) && dateIndex != -1) {
			System.out.println(dateIndex);
			description = getString(args, 0, dateIndex - 1);
		} else {
			description = getString(args, 0, locationIndex - 1);
		}
		return description;
	}

	private int fixPriorityIndex(int priorityIndex, String[] args){
	    int priorityLevelPosition = priorityIndex + 1 ;
	    List<String> levels = Arrays.asList(PRIORITY_LEVELS);
	    if (priorityLevelPosition == args.length){
	        return -1;
	    }else if (!levels.contains(args[priorityLevelPosition].toLowerCase())){
	        return -1;
	    }else{
	        return priorityIndex;
	    }
	}
	
	private String getDateString(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
	    int end = args.length;
	    if (priorityIndex != -1){
	        end = priorityIndex;
	    }
	    if (dateIndex == -1) {
			return EMPTY;
		} else if (dateIndex < locationIndex) {
			return getString(args, dateIndex, locationIndex - 1);
		} else {
			return getString(args, dateIndex, end - 1);
		}
	}

	private String getLocationString(int dateIndex, int locationIndex, int priorityIndex, String[] args) {
	    int end = args.length;
        if (priorityIndex != -1){
            end = priorityIndex;
        }
        if (locationIndex == -1) {
			return EMPTY;
		} else if (locationIndex < dateIndex) {
			return getString(args, locationIndex + 1, dateIndex - 1);
		} else {
			return getString(args, locationIndex + 1, end - 1);
		}
	}

	private String getString(String[] args, int start, int end) {
		String string = EMPTY;
		for (int i = start; i <= end; i++) {
			string = string + args[i] + " ";
		}
		return string.trim();
	}

	private int getDateStartIndex(String[] args) {
		ArrayList<Integer> indices = new ArrayList<Integer>();
	    int eventDateIndex = getLastIndex(DATE_MARKERS_START, args);
		if (eventDateIndex == -1){
		    indices.add(getLastIndex(DATE_MARKERS_END, args));
		}else{
		    indices.add(eventDateIndex);
		}
		indices.add(getLastIndex(DATE_MARKERS_DEADLINE, args));
		indices.add(getLastIndex(DATE_MARKERS_FULL_DAY_EVENT, args));
        int dateIndex = (int) Collections.max(indices);
		return dateIndex;
	}
	
	private static int getLastIndex(String[] keywords, String[] commandWords){
	    int[] positions = new int[keywords.length];
	    String[] commandLowerCase = new String[commandWords.length];
	    for (int i = 0; i < commandWords.length; i++ ){
	        commandLowerCase[i] = commandWords[i].toLowerCase();
	    }
	    for (int i = 0; i < keywords.length; i++){
	        positions[i] = Arrays.asList(commandLowerCase).lastIndexOf(keywords[i].toLowerCase());
	    }
	    List<Integer> list = Arrays.asList(ArrayUtils.toObject(positions));
	    return ((int) Collections.max(list));
	}

	private void checkForError(String userCommand) /* throws Error */ {
		if (userCommand == null) {
			logger.warning("null user commands");
			throw new Error(MESSAGE_NULL_ERROR);
		}
	}

}
```
###### Tasker\src\application\logic\SearchByDate.java
``` java
package application.logic;

import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Storage;
import application.storage.Task;

/**
 * 
 * @author Shawn
 *
 */

public class SearchByDate implements Command {
	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";
	
	private Calendar date;

	private ArrayList<Task> taskList;

	SearchByDate(Calendar date) {
		this.date = date;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		taskList = storageConnector.searchTaskByDate(date);
		return checkIfListEmpty(storageConnector);
	}

	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList.size() != 0) {
			return getFeedbackList(MESSAGE_SEARCH_RESULTS, taskList, null);
		} else {
			Feedback fb = new Feedback(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(),  null);
			fb.setCalFlag();
			return fb;
		}
	}
	
	private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
}
```
###### Tasker\src\application\logic\SearchByDate.java
``` java

```
###### Tasker\src\application\logic\SearchByName.java
``` java
package application.logic;

import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;

/**
 * 
 * @author Shawn
 *
 */

public class SearchByName implements Command {

	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";
	private static final String EMPTY_STRING = "";
	private static final String SPACE = " ";

	private String taskName;

	private ArrayList<Task> taskList;

	SearchByName(String taskName) {
		this.taskName = taskName;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		// TODO Auto-generated method stub
		taskList = storageConnector.searchTaskByName(taskName);
		return checkIfListEmpty(storageConnector);
	}

	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList.size() != 0) {
			return getFeedbackList(MESSAGE_SEARCH_RESULTS, taskList, null);
		} else {
			Feedback fb = new Feedback(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(), null);
			fb.setCalFlag();
			return fb;
		}
	}
	
	private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
}
```
###### Tasker\src\application\logic\SearchByName.java
``` java

```
###### Tasker\src\application\logic\SearchByPriority.java
``` java
package application.logic;

import java.util.ArrayList;

import application.storage.Storage;
import application.storage.Task;

public class SearchByPriority implements Command {
	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";

	private String priority;

	private ArrayList<Task> taskList;

	SearchByPriority(String[] arguments) {
		priority = arguments[1];
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		taskList = storageConnector.searchTaskByPriority(priority);
		return checkIfListEmpty(storageConnector);
	}

	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList != null) {
			return getFeedbackList(MESSAGE_SEARCH_RESULTS, taskList, null);
		} else {
			Feedback fb = new Feedback(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(), null);
			fb.setCalFlag();
			return fb;
		}
	}
	private Feedback getFeedbackList(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setListFlag();
        return fb;
    }
	
}
```
###### Tasker\src\application\logic\SearchByPriority.java
``` java

```
###### Tasker\src\application\logic\SearchOnDate.java
``` java
package application.logic;

import java.util.ArrayList;
import java.util.Calendar;

import application.storage.Storage;
import application.storage.Task;

/**
 * 
 * @author Shawn
 *
 */

public class SearchOnDate implements Command {
	private static final String MESSAGE_SEARCH_RESULTS = "Here are the results of your search!";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "Search Not Found";

	private Calendar date;

	private ArrayList<Task> taskList;

	SearchOnDate(Calendar date) {
		this.date = date;
	}

	@Override
	public Feedback execute(StorageConnector storageConnector, ArrayList<Task> tasks) {
		taskList = storageConnector.searchTaskOnDate(date);
		return checkIfListEmpty(storageConnector);
	}

	private Feedback checkIfListEmpty(StorageConnector storageConnector) {
		if (taskList.size() != 0) {
			Feedback fb = new Feedback(MESSAGE_SEARCH_RESULTS, taskList, null);
			fb.setListFlag();
			return fb;
		} else {
			return getFeedbackCal(MESSAGE_SEARCH_NOT_FOUND, storageConnector.getOpenList(), null);
		}
	}
	
	private Feedback getFeedbackCal(String message, ArrayList<Task> tasks, Task task){
        Feedback fb = new Feedback(message, tasks, task);
        fb.setCalFlag();
        return fb;
    }
}
```
###### Tasker\src\application\logic\SearchOnDate.java
``` java

```
