# A0125522R
###### Fantasktic\src\application\storage\DatabaseManager.java
``` java

package application.storage;

import java.util.ArrayList;

/**
 * DatabaseManager is used to hold the close list (tasks that are done) and open list (current ongoing tasks) for easy access from other components.
 * It also keep track of the total tasks (task index) added in the program.
 */

public class DatabaseManager {
	
	// Lists and task index
	private int taskIndex = 0;
	private ArrayList<Task> closeList = new ArrayList<Task>();
	private ArrayList<Task> openList = new ArrayList<Task>();
	
	/**
	 * Returns the close list (tasks that are done).
	 */
	public ArrayList<Task> getCloseList() {
		return closeList;
	}
	/**
	 * Returns the open list (current ongoing tasks).
	 */
	public ArrayList<Task> getOpenList() {
		return openList;
	}
	
	/**
	 * Returns the current task index count.
	 */
	public int getTaskIndex() {
		return taskIndex;
	}
	
	/**
	 * Set the task index count.
	 */
	public void setTaskIndex(int i) {
		taskIndex = i;
	}
	
	/**
	 * Updates the close list with the new close list.
	 */
	public void updateCloseList(ArrayList<Task> closeList) {
		this.closeList = closeList;
	}
	
	/**
	 * Updates the open list with the new open list.
	 */
	public void updateOpenList(ArrayList<Task> openList) {
		this.openList = openList;
	}

	/**
	 * Increase the task count.
	 */
	public int updateTaskIndex() {
		taskIndex++;
		return taskIndex;
	}
}
```
###### Fantasktic\src\application\storage\DeadlineTask.java
``` java

package application.storage;

import java.util.Calendar;

/**
 * DeadlineTask is a subclass of Task class. This class is used when the user
 * creates a task with a deadline. It has an extra parameter, endDate, to denote
 * the task deadline.
 */
public class DeadlineTask extends Task implements Cloneable {
	private Calendar endDate;

	/**
	 * Creates a DeadlineTask object with "empty" variables initalised.
	 */
	public DeadlineTask() {
		setTaskDescription(EMPTY_STRING);
		endDate = Calendar.getInstance();
		setLocation(EMPTY_STRING);
		setRemindDate(Calendar.getInstance());
		setPriority(EMPTY_STRING);
		setTaskIndex(EMPTY_TASK);
	}

	/**
	 * Creates a DeadlineTask object with specified variables.
	 */
	public DeadlineTask(String taskDescription, Calendar endDate, String location, Calendar remindDate, String priority,
			int taskIndex) {
		setTaskDescription(taskDescription);
		this.endDate = endDate;
		setEndTime(endDate);
		setLocation(location);
		setRemindDate(remindDate);
		setPriority(priority);
		setTaskIndex(taskIndex);
	}

	/**
	 * Set the deadline date (year, month, date).
	 */
	public void setEndDate(Calendar endDate) {
		this.endDate.set(endDate.get(Calendar.YEAR), endDate.get(Calendar.MONTH), endDate.get(Calendar.DATE));
	}

	/**
	 * Set the deadline time (hour, minute, second, milliseconds).
	 */
	public void setEndTime(Calendar endTime) {
		this.endDate.set(Calendar.HOUR_OF_DAY, endTime.get(Calendar.HOUR_OF_DAY));
		this.endDate.set(Calendar.MINUTE, endTime.get(Calendar.MINUTE));
		this.endDate.set(Calendar.SECOND, endTime.get(Calendar.SECOND));
		this.endDate.set(Calendar.MILLISECOND, endTime.get(Calendar.MILLISECOND));
	}

	/**
	 * Returns null as no start date for DeadlineTask.
	 */
	public Calendar getStartDate() {
		return NO_DATE;
	}

	/**
	 * Returns null as no start time for DeadlineTask.
	 */
	public Calendar getStartTime() {
		return NO_TIME;
	}

	/**
	 * Returns the deadline date.
	 */
	public Calendar getEndDate() {
		return endDate;
	}

	/**
	 * Returns the deadline time.
	 */
	public Calendar getEndTime() {
		return endDate;
	}

	/**
	 * Returns the deadline in String.
	 */
	public String durationToString() {
		String durationMessage = EMPTY_STRING;
		String endingDate = dateToString(endDate);
		String endingTime = timeToString(endDate);
		if (!endingDate.equals(EMPTY_DATE_STRING)) {
			durationMessage += KEYWORD_BY + endingDate;
			if (!endingTime.equals(EMPTY_TIME_STRING)) {
				durationMessage += KEYWORD_SPACE + endingTime;
			}
		}
		return durationMessage;
	}

	/**
	 * Returns the task details in String.
	 */
	public String toString() {
		String taskDetails = KEYWORD_QUOTE;
		taskDetails += getTaskDescription();
		taskDetails += KEYWORD_SPACE + durationToString();
		if (!getLocation().equalsIgnoreCase(EMPTY_STRING)) {
			taskDetails += KEYWORD_AT + getLocation();
		}
		
		if (!getPriority().equalsIgnoreCase(EMPTY_STRING)) {
			taskDetails += KEYWORD_FULLSTOP + KEYWORD_PRIORITY + getPriority();
		}
		
		taskDetails += KEYWORD_QUOTE;
		return taskDetails;
	}

	/**
	 * Clones a DeadlineTask.
	 */
	protected Object clone() throws CloneNotSupportedException {
		DeadlineTask newTask = (DeadlineTask) super.clone();
		newTask.endDate = (Calendar) endDate.clone();
		newTask.remindDate = (Calendar) remindDate.clone();
		return newTask;
	}

```
###### Fantasktic\src\application\storage\EventTask.java
``` java

package application.storage;

import java.util.Calendar;

/**
 * EventTask is a subclass of Task class. This class is used when the user
 * creates a task with a event duration. It has an two extra parameter,
 * startDate and endDate, to denote the task duration.
 */
public class EventTask extends Task implements Cloneable {
	private Calendar startDate;
	private Calendar endDate;

	/**
	 * Creates a EventTask object with "empty" variables initalised.
	 */
	public EventTask() {
		setTaskDescription(EMPTY_STRING);
		startDate = Calendar.getInstance();
		endDate = Calendar.getInstance();
		setLocation(EMPTY_STRING);
		setRemindDate(Calendar.getInstance());
		setPriority(EMPTY_STRING);
		setTaskIndex(EMPTY_TASK);
	}

	/**
	 * Creates a EventTask object with specified variables.
	 */
	public EventTask(String taskDescription, Calendar startDate, Calendar endDate, String location, Calendar remindDate,
			String priority, int taskIndex) {
		setTaskDescription(taskDescription);
		this.startDate = startDate;
		this.endDate = endDate;
		setLocation(location);
		setRemindDate(remindDate);
		setPriority(priority);
		setTaskIndex(taskIndex);
	}

	/**
	 * Set the start date (year, month, date).
	 */
	public void setStartDate(Calendar startDate) {
		this.startDate.set(startDate.get(Calendar.YEAR), startDate.get(Calendar.MONTH), startDate.get(Calendar.DATE));
	}

	/**
	 * Set the start time (hour, minute, seconds, milliseconds).
	 */
	public void setStartTime(Calendar startTime) {
		this.startDate.set(Calendar.HOUR_OF_DAY, startTime.get(Calendar.HOUR_OF_DAY));
		this.startDate.set(Calendar.MINUTE, startTime.get(Calendar.MINUTE));
		this.startDate.set(Calendar.SECOND, startTime.get(Calendar.SECOND));
		this.startDate.set(Calendar.MILLISECOND, startTime.get(Calendar.MILLISECOND));
	}

	/**
	 * Set the end date (year, month, date).
	 */
	public void setEndDate(Calendar endDate) {
		this.endDate.set(endDate.get(Calendar.YEAR), endDate.get(Calendar.MONTH), endDate.get(Calendar.DATE));
	}

	/**
	 * Set the end time (hour, minute, seconds, milliseconds).
	 */
	public void setEndTime(Calendar endTime) {
		this.endDate.set(Calendar.HOUR_OF_DAY, endTime.get(Calendar.HOUR_OF_DAY));
		this.endDate.set(Calendar.MINUTE, endTime.get(Calendar.MINUTE));
		this.endDate.set(Calendar.SECOND, endTime.get(Calendar.SECOND));
		this.endDate.set(Calendar.MILLISECOND, endTime.get(Calendar.MILLISECOND));
	}

	/**
	 * Returns the start date.
	 */
	public Calendar getStartDate() {
		return startDate;
	}

	/**
	 * Returns the start time.
	 */
	public Calendar getStartTime() {
		return startDate;
	}

	/**
	 * Returns the end date.
	 */
	public Calendar getEndDate() {
		return endDate;
	}

	/**
	 * Returns the end time.
	 */
	public Calendar getEndTime() {
		return endDate;
	}

	/**
	 * Returns the event duration in String.
	 */
	public String durationToString() {
		String durationMessage = EMPTY_STRING;
		String startingDate = dateToString(startDate);
		String startingTime = timeToString(startDate);
		String endingDate = dateToString(endDate);
		String endingTime = timeToString(endDate);

		// display start date, if exist
		if (!startingDate.equals(EMPTY_DATE_STRING)) {
			durationMessage += startingDate;
			if (!startingTime.equals(EMPTY_TIME_STRING)) {
				durationMessage += KEYWORD_SPACE + startingTime;
			} 
			// if start and end date is same, display same date + both time
			if (startingDate.equalsIgnoreCase(endingDate)) {
				if (startingTime.equals(EMPTY_TIME_STRING)) {
					durationMessage += endingTime;
				} else if (!endingTime.equals(EMPTY_TIME_STRING) && !startingTime.equals(EMPTY_TIME_STRING)) {
					durationMessage += KEYWORD_TO + endingTime;
				}
				return durationMessage;
			}
		}

		// display start date and end date, if both exist
		if ((!startingDate.equals(EMPTY_DATE_STRING)) && (!endingDate.equals(EMPTY_DATE_STRING))) {
			durationMessage += KEYWORD_TO + endingDate;
			if (!endingTime.equals(EMPTY_TIME_STRING)) {
				durationMessage += KEYWORD_SPACE + endingTime;
			}
		// display only end date, if exist
		} else if (startingDate.equals(EMPTY_DATE_STRING) && (!endingDate.equals(EMPTY_DATE_STRING))) {
			durationMessage += KEYWORD_BY + endingDate;
			if (!endingTime.equals(EMPTY_TIME_STRING)) {
				durationMessage += KEYWORD_SPACE + endingTime;
			}
		}
		return durationMessage;
	}

	/**
	 * Returns the task details in String.
	 */
	public String toString() {
		String taskDetails = KEYWORD_QUOTE;
		taskDetails += getTaskDescription();
		taskDetails += KEYWORD_SPACE + durationToString();
		if (!getLocation().equalsIgnoreCase(EMPTY_STRING)) {
			taskDetails += KEYWORD_AT + getLocation();
		}
		
		if (!getPriority().equalsIgnoreCase(EMPTY_STRING)) {
			taskDetails += KEYWORD_FULLSTOP + KEYWORD_PRIORITY + getPriority();
		}
		
		taskDetails += KEYWORD_QUOTE;
		return taskDetails;
	}

	/**
	 * Clones a EventTask.
	 */
	protected Object clone() throws CloneNotSupportedException {
		EventTask newTask = (EventTask) super.clone();
		newTask.startDate = (Calendar) startDate.clone();
		newTask.endDate = (Calendar) endDate.clone();
		newTask.remindDate = (Calendar) remindDate.clone();
		return newTask;
	}

```
###### Fantasktic\src\application\storage\FileManager.java
``` java

package application.storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import application.logger.LoggerHandler;

/**
 * FileManager is used to save/load tasks into/into text file. It also holds the
 * current storage location path, and the data files (open and close lists)
 * path.
 */
public class FileManager {

	// Constants
	private static final String EMPTY = "";
	private static final String EMPTY_PATH = "";
	private static final String FILE_CLOSED_NAME = "FantaskticHistory.txt";
	private static final String FILE_DATA_NAME = "FantaskticData.txt";
	private static final String FILE_DIRECTORY_NAME = "FantaskticDirectory.txt";
	private static final String KEYWORD_SLASH = "\\";
	private static final int DIRECTORY_BEGIN_INDEX = 0;
	private static final int NO_TASK = 0;

	// Log messages
	private static final String LOG_INFO_LOADING_DIRECTORY = "Loading directory file.";
	private static final String LOG_INFO_LOADING_TASKS = "Loading tasks into list.";
	private static final String LOG_INFO_NO_DIRECTORY_CHOOSEN = "No directory choosen.";
	private static final String LOG_INFO_NEW_DIRECTORY_CHOOSEN = "New directory choosen.";
	private static final String LOG_INFO_SAVING_TASKS = "Saving tasks into file.";
	private static final String LOG_INFO_SAVE_FILE = "Saving file.";
	private static final String LOG_ERROR_CLEAR_FILE = "Error clearing file.";
	private static final String LOG_ERROR_FIND_FILE = "Error finding file.";
	private static final String LOG_ERROR_INITIALISE_DIRECTORY = "Error initialising directory.";
	private static final String LOG_ERROR_LOADING_DIERCTORY = "Error loading directory file.";
	private static final String LOG_ERROR_LOAD_TASK_INDEX = "Error initialising data file task index.";
	private static final String LOG_ERROR_SAVING_TASKS = "Error saving all tasks.";
	private static final String LOG_ERROR_SAVE_FILE = "Error saving file.";
	private static final String LOG_ERROR_SAVE_TASK_INDEX = "Error saving task index.";
	private static final String LOG_ERROR_SET_DIRECTORY = "Error setting directory.";

	// Path variables
	private String closedFilePath = "";
	private String dataFilePath = "";

	// Logger
	private static Logger logger = LoggerHandler.getLog();

	/**
	 * Clears the given file.
	 */
	public void clear(String filePath) {
		assert (filePath != null);
		File file = new File(filePath);
		if (file.exists()) {
			try {
				PrintWriter fw = new PrintWriter(filePath);
				fw.print(EMPTY);
				fw.close();
			} catch (FileNotFoundException e) {
				logger.log(Level.SEVERE, LOG_ERROR_CLEAR_FILE);
			}
		}
	}

	/**
	 * Return the path of close list.
	 */
	public String getClosedFilePath() {
		assert (closedFilePath != null);
		return closedFilePath;
	}

	/**
	 * Return the path of data list.
	 */
	public String getDataFilePath() {
		assert (dataFilePath != null);
		return dataFilePath;
	}

	/**
	 * Return the storage path in the directory file .
	 */
	public String getDirectoryPath() {
		return loadDirectoryFile();
	}

	/**
	 * Checks whether the directory file exist.
	 */
	public boolean isDirectoryExists() {
		// check whether its user first time opening program
		File directoryFile = new File(FILE_DIRECTORY_NAME);
		if (!directoryFile.exists()) {
			PrintWriter fw;
			try {
				fw = new PrintWriter(new BufferedWriter(new FileWriter(FILE_DIRECTORY_NAME, true)));
				fw.print(EMPTY);
				fw.close();
				return false;
			} catch (IOException e) {
				logger.log(Level.SEVERE, LOG_ERROR_INITIALISE_DIRECTORY);
				return false;
			}
		} else {
			return true;
		}
	}

	/**
	 * Loads the user tasks file (open and close list) into a list.
	 */
	public ArrayList<Task> loadFile(String filePath) {
		assert (filePath != null);
		File file = new File(filePath);
		ArrayList<Task> list = new ArrayList<Task>();
		logger.log(Level.INFO, LOG_INFO_LOADING_TASKS);
		if (file.exists()) {
			try {
				BufferedReader in = new BufferedReader(new FileReader(filePath));
				
				// skip first line first if its data file (open list)
				if (filePath.equalsIgnoreCase(dataFilePath)) {
					in.readLine();
				}
				list = loadTasksIntoFile(in, list);
				in.close();
			} catch (IOException e) {
				logger.log(Level.SEVERE, LOG_ERROR_FIND_FILE);
			}
		}
		return list;
	}

	/**
	 * Loads the given file of tasks (close,open) into ArrayList<Task>.
	 */
	private ArrayList<Task> loadTasksIntoFile(BufferedReader in, ArrayList<Task> list) throws IOException {
		String readText;
		Gson gson = new GsonBuilder().registerTypeAdapter(Task.class, new TaskSerializer())
				.registerTypeAdapter(EventTask.class, new TaskSerializer())
				.registerTypeAdapter(DeadlineTask.class, new TaskSerializer())
				.registerTypeAdapter(FloatingTask.class, new TaskSerializer()).create();
		while ((readText = in.readLine()) != null) {
			Task task = gson.fromJson(readText, Task.class);
			list.add(task);
		}
		return list;
	}

	/**
	 * Loads the directory file and initialise the close, data file path and
	 * return storage directory path of data files.
	 */
	public String loadDirectoryFile() {
		try {
			BufferedReader in = new BufferedReader(new FileReader(FILE_DIRECTORY_NAME));
			logger.log(Level.INFO, LOG_INFO_LOADING_DIRECTORY);
			String directoryPath = in.readLine();
			directoryPath = loadFilePaths(directoryPath);
			in.close();
			return directoryPath;
		} catch (IOException e) {
			logger.log(Level.SEVERE, LOG_ERROR_LOADING_DIERCTORY);
			return null;
		}
	}

	/**
	 * Set the file paths up to save open list and close list subsequently and
	 * return the storage directory of data files.
	 */
	private String loadFilePaths(String directoryPath) {
		if (directoryPath == null) {
			closedFilePath = FILE_CLOSED_NAME;
			dataFilePath = FILE_DATA_NAME;
			File directoryFile = new File(FILE_DIRECTORY_NAME);
			String absolutePath = directoryFile.getAbsolutePath();
			directoryPath = absolutePath.substring(DIRECTORY_BEGIN_INDEX, absolutePath.lastIndexOf(File.separator))
					+ KEYWORD_SLASH;
		} else {
			closedFilePath = directoryPath + FILE_CLOSED_NAME;
			dataFilePath = directoryPath + FILE_DATA_NAME;
		}
		return directoryPath;
	}

	/**
	 * Loads the total task index count.
	 */
	public int loadTaskIndex() {
		File f = new File(dataFilePath);
		if (f.exists()) {
			try {
				BufferedReader in = new BufferedReader(new FileReader(dataFilePath));
				String taskIndex;
				taskIndex = in.readLine();
				in.close();
				return Integer.parseInt(taskIndex);
			} catch (IOException e) {
				logger.log(Level.SEVERE, LOG_ERROR_LOAD_TASK_INDEX);
				return NO_TASK;
			}
		} else {
			return NO_TASK;
		}
	}

	/**
	 * Saves all tasks into the file path specified.
	 */
	private void saveAllTasks(ArrayList<Task> list, String filePath) {
		logger.log(Level.INFO, LOG_INFO_SAVING_TASKS);
		try {
			saveTasksIntoFile(list, filePath);
		} catch (IOException e) {
			logger.log(Level.SEVERE, LOG_ERROR_SAVING_TASKS);
		}
	}

	/**
	 * Saves all tasks into the file.
	 */
	private void saveTasksIntoFile(ArrayList<Task> list, String filePath) throws IOException {
		PrintWriter fwz = new PrintWriter(new BufferedWriter(new FileWriter(filePath, true)));
		Gson gson = new GsonBuilder().registerTypeAdapter(Task.class, new TaskSerializer())
				.registerTypeAdapter(EventTask.class, new TaskSerializer())
				.registerTypeAdapter(DeadlineTask.class, new TaskSerializer())
				.registerTypeAdapter(FloatingTask.class, new TaskSerializer()).create();
		for (int i = 0; i < list.size(); i++) {
			String taskJson = gson.toJson(list.get(i));
			fwz.println(taskJson);
		}
		fwz.close();
	}

	/**
	 * Saves a given file.
	 */
	public void saveFile(ArrayList<Task> list, String filePath) {
		assert (filePath != null);
		File f = new File(filePath);
		logger.log(Level.INFO, LOG_INFO_SAVE_FILE);
		if (!f.exists()) {
			try {
				f.createNewFile();
			} catch (IOException e) {
				logger.log(Level.SEVERE, LOG_ERROR_SAVE_FILE);
			}
		} else {
			// save all the tasks
			saveAllTasks(list, filePath);
		}
	}

	/**
	 * Saves the total task index count.
	 */
	public void saveTaskIndex(int taskIndex) {
		// #clear datafile first
		clear(dataFilePath);

		try {
			PrintWriter fw = new PrintWriter(new BufferedWriter(new FileWriter(dataFilePath, true)));
			fw.println(taskIndex);
			fw.close();
		} catch (IOException e) {
			logger.log(Level.SEVERE, LOG_ERROR_SAVE_TASK_INDEX);
		}
	}

	/**
	 * Set the storage directory at the path that the user specified.
	 */
	public boolean setDirectory(String newPath) {
		assert (newPath != null);
		if (newPath.equalsIgnoreCase(EMPTY_PATH)) {
			logger.log(Level.INFO, LOG_INFO_NO_DIRECTORY_CHOOSEN);
			return false;
		} else {
			clear(FILE_DIRECTORY_NAME);
			logger.log(Level.INFO, LOG_INFO_NEW_DIRECTORY_CHOOSEN);
			try {
				PrintWriter fw = new PrintWriter(FILE_DIRECTORY_NAME);

				// get current path
				Path oldClosedFilePath = Paths.get(closedFilePath);
				Path oldDataFilePath = Paths.get(dataFilePath);

				// store new path
				closedFilePath = newPath + FILE_CLOSED_NAME;
				dataFilePath = newPath + FILE_DATA_NAME;
				fw.println(newPath);

				// migration of data files
				migrateFilesAndDeleteExistingFiles(oldClosedFilePath, oldDataFilePath);
				fw.close();
				return true;
			} catch (IOException e) {
				logger.log(Level.SEVERE, LOG_ERROR_SET_DIRECTORY);
				return false;
			}
		}
	}

	/**
	 * Migrate any existing data files to new directory and delete the existing
	 * data files.
	 */
	private void migrateFilesAndDeleteExistingFiles(Path oldClosedFilePath, Path oldDataFilePath) throws IOException {
		
		Path newClosedFilePath = Paths.get(closedFilePath);		
		if (oldClosedFilePath.toFile().exists()) {
			if (!oldClosedFilePath.equals(newClosedFilePath)) {
				Files.copy(oldClosedFilePath, newClosedFilePath, StandardCopyOption.REPLACE_EXISTING);
				Files.deleteIfExists(oldClosedFilePath);
			}
		}
		
		Path newDataFilePath = Paths.get(dataFilePath);
		if (oldDataFilePath.toFile().exists()) {
			if (!oldDataFilePath.equals(newDataFilePath)) {
				Files.copy(oldDataFilePath, newDataFilePath, StandardCopyOption.REPLACE_EXISTING);
				Files.deleteIfExists(oldDataFilePath);
			}
		}
	}
}
```
###### Fantasktic\src\application\storage\FloatingTask.java
``` java

package application.storage;

import java.util.Calendar;

/**
 * FloatingTask is a subclass of Task class. 
 * This class is used when the user creates a task with no date specified.
 */
public class FloatingTask extends Task implements Cloneable {

	/**
	 * Creates a FloatingTask object with "empty" variables initalised.
	 */
	public FloatingTask() {
		setTaskDescription(EMPTY_STRING);
		setLocation(EMPTY_STRING);
		setRemindDate(Calendar.getInstance());
		setPriority(EMPTY_STRING);
		setTaskIndex(EMPTY_TASK);
	}

	/**
	 * Creates a FloatingTask object with specified variables.
	 */
	public FloatingTask(String taskDescription, String location, Calendar remindDate, String priority, int taskIndex) {
		setTaskDescription(taskDescription);
		setLocation(location);
		setRemindDate(remindDate);
		setPriority(priority);
		setTaskIndex(taskIndex);
	}

	/**
	 * Returns null as no start date for FloatingTask.
	 */
	public Calendar getStartDate() {
		return NO_DATE;
	}

	/**
	 * Returns null as no end date for FloatingTask.
	 */
	public Calendar getEndDate() {
		return NO_DATE;
	}

	/**
	 * Returns null as no start time for FloatingTask.
	 */
	public Calendar getStartTime() {
		return NO_TIME;
	}

	/**
	 * Returns null as no end time for FloatingTask.
	 */
	public Calendar getEndTime() {
		return NO_TIME;
	}

	/**
	 * Returns empty string as no duration for FloatingTask.
	 */
	public String durationToString() {
		return EMPTY_STRING;
	}

	/**
	 * Returns the task details in String.
	 */
	public String toString() {
		String taskDetails = KEYWORD_QUOTE;
		taskDetails += getTaskDescription();
		if (!getLocation().equalsIgnoreCase(EMPTY_STRING)) {
			taskDetails += KEYWORD_AT + getLocation();
		}
		
		if (!getPriority().equalsIgnoreCase(EMPTY_STRING)) {
			taskDetails += KEYWORD_FULLSTOP + KEYWORD_PRIORITY + getPriority();
		}
		
		taskDetails += KEYWORD_QUOTE;
		return taskDetails;
	}

	/**
	 * Clones a FloatingTask.
	 */
	protected Object clone() throws CloneNotSupportedException {
		FloatingTask newTask = (FloatingTask) super.clone();
		newTask.remindDate = (Calendar) remindDate.clone();
		return newTask;
	}

```
###### Fantasktic\src\application\storage\Storage.java
``` java

package application.storage;

import java.util.Calendar;
import java.util.ArrayList;

/**
 * Storage is implemented with facade pattern which acts as an simple interface
 * to components who wish to utilize its task manipulation function.
 */
public class Storage implements Cloneable {

	// Constants
	private static final int INVALID_TASK_INDEX = -1;
	private static final int UPDATED_CLOSE_LIST = 0;
	private static final int UPDATED_DATE_LIST = 1;

	// Managers
	private DatabaseManager databaseManager;
	private FileManager fileManager;
	private TaskManager taskManager;

	public Storage() {
		databaseManager = new DatabaseManager();
		fileManager = new FileManager();
		taskManager = new TaskManager();
	}

```
###### Fantasktic\src\application\storage\Storage.java
``` java
	/**
	 * Delete a task in the open list with the specified task index and save and
	 * return deleted task.
	 */
	public Task deleteTask(int index) {
		Task deletedTask = null;
		for (int i = 0; i < databaseManager.getOpenList().size(); i++) {
			if (databaseManager.getOpenList().get(i).getTaskIndex() == index) {
				deletedTask = databaseManager.getOpenList().get(i);
			}
		}
		databaseManager.updateOpenList(taskManager.delete(databaseManager.getOpenList(), index));
		saveFile();
		return deletedTask;
	}

	/**
	 * Checks if the directory file exist.
	 */
	public boolean directoryExists() {
		return fileManager.isDirectoryExists();
	}

	/**
	 * Gets the updated open list (ongoing tasks).
	 */
	public ArrayList<Task> getOpenList() {
		databaseManager.updateOpenList(taskManager.sortDate(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}

	/**
	 * Gets the updated close list (tasks done).
	 */
	public ArrayList<Task> getCloseList() {
		databaseManager.updateCloseList(taskManager.sortDate(databaseManager.getCloseList()));
		return databaseManager.getCloseList();
	}

	/**
	 * Initialise the Storage by loading the necessary components for task
	 * functions.
	 */
	public boolean initialise() {
		fileManager.loadDirectoryFile();
		databaseManager.updateCloseList(fileManager.loadFile(fileManager.getClosedFilePath()));
		databaseManager.updateOpenList(fileManager.loadFile(fileManager.getDataFilePath()));
		databaseManager.setTaskIndex(fileManager.loadTaskIndex());
		return true;
	}

	/**
	 * Saves all current data into file.
	 */
	private void saveFile() {
		fileManager.clear(fileManager.getClosedFilePath());
		fileManager.saveTaskIndex(databaseManager.getTaskIndex());
		fileManager.saveFile(databaseManager.getCloseList(), fileManager.getClosedFilePath());
		fileManager.saveFile(databaseManager.getOpenList(), fileManager.getDataFilePath());
	}

	/**
	 * Search the tasks by a specified date.
	 */
	public ArrayList<Task> searchTaskByDate(Calendar date) {
		return taskManager.searchDateBy(databaseManager.getOpenList(), date);
	}

	/**
	 * Search the tasks on a specified date.
	 */
	public ArrayList<Task> searchTaskOnDate(Calendar date) {
		return taskManager.searchDateOn(databaseManager.getOpenList(), date);
	}

	/**
	 * Search the tasks by a specified name.
	 */
	public ArrayList<Task> searchTaskByName(String taskName) {
		return taskManager.searchName(databaseManager.getOpenList(), taskName);
	}

	/**
	 * Search the tasks by a specified priority.
	 */
	public ArrayList<Task> searchTaskByPriority(String priority) {
		return taskManager.searchPriority(databaseManager.getOpenList(), priority);
	}

```
###### Fantasktic\src\application\storage\Storage.java
``` java
	/**
	 * Sets the directory path to hold the data files (open and close list) and
	 * return the original directory path.
	 */
	public String setDirectory(String path) {
		String originalDirectoryPath = fileManager.getDirectoryPath();
		fileManager.setDirectory(path);
		return originalDirectoryPath;
	}

	/**
	 * Sorts the open list (ongoing tasks) by ascending end date.
	 */
	public ArrayList<Task> sortByDate() {
		databaseManager.updateOpenList(taskManager.sortDate(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}

	/**
	 * Sorts the open list (ongoing tasks) by ascending task name.
	 */
	public ArrayList<Task> sortByName() {
		databaseManager.updateOpenList(taskManager.sortName(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}

	/**
	 * Sorts the open list (ongoing tasks) by priority (high to low)
	 */
	public ArrayList<Task> sortByPriority() {
		databaseManager.updateOpenList(taskManager.sortPriority(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}

	/**
	 * Update a task, save the file and return the original and updated task.
	 */
	public ArrayList<Task> updateTask(int index, String taskDescription, Calendar startDate, Calendar endDate,
			String location, Calendar remindDate, String priority) {
		ArrayList<Task> list = new ArrayList<Task>();

		// add original/old task into list for return
		int taskIndex = INVALID_TASK_INDEX;
		for (int i = 0; i < databaseManager.getOpenList().size(); i++) {
			if (databaseManager.getOpenList().get(i).getTaskIndex() == index) {
				taskIndex = i;
				list.add(cloneObject(databaseManager.getOpenList().get(i)));
				break;
			}
		}

		// update task and add into list for return
		databaseManager.updateOpenList(taskManager.update(databaseManager.getOpenList(), taskDescription, startDate,
				endDate, location, remindDate, priority, index));
		list.add(databaseManager.getOpenList().get(taskIndex));

		saveFile();
		return list;
	}

	/**
	 * Clones a Task object.
	 */
	private Task cloneObject(Task obj) {
		try {
			if (obj instanceof FloatingTask) {
				return (FloatingTask) obj.clone();
			}
			
			if (obj instanceof DeadlineTask) {
				return (DeadlineTask) obj.clone();
			} else {
				return (EventTask) obj.clone();
			}
			
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}

	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
}
```
###### Fantasktic\src\application\storage\StorageTest.java
``` java

package application.storage;

import static org.junit.Assert.*;
import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * StorageTest is used to test all task manipulation functions.
 * 
 * TAKE NOTE :
 * --------------
 * Before running all tests, do take note of variables such as CUSTOM_DIRECTORY1 & CUSTOM_DIRECTORY2.
 * - Adjust the designated directory path according to your own local computer.
 * Also to ensure reliability and consistency, remove any data files in the folders you'll be testing with.
 */
public class StorageTest {
	Storage storageController;
    private static final int EMPTY = 1;
	static final String CUSTOM_DIRECTORY1 = "E:\\eclipse\\workspace\\";
	static final String CUSTOM_DIRECTORY2 = "E:\\eclipse\\workspace\\CS2103_Tasker\\";
	static final String FILE_CLOSED_NAME = "FantaskticHistory.txt";
	static final String FILE_DATA_NAME = "FantaskticData.txt";
	static final String FILE_DIRECTORY_NAME = "FantaskticDirectory.txt";
	static final SimpleDateFormat FORMAT_TIME = new SimpleDateFormat("h:mm a");
	static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("d MMM yyyy");
	static Calendar cal1 = Calendar.getInstance();
	static Calendar cal2 = Calendar.getInstance();
	static Calendar cal3 = Calendar.getInstance();
	static Calendar time1 = Calendar.getInstance();
	static Calendar noDate = Calendar.getInstance();
	static Calendar noTime = Calendar.getInstance();
	static Calendar noDateTime = Calendar.getInstance();
	
    @Before
	public void before() throws IOException {
		storageController = new Storage();
		if(!storageController.directoryExists())	
			storageController.setDirectory("");
		storageController.initialise();
		cal1.set(2020, Calendar.JUNE, 30);
		cal2.set(2030, Calendar.DECEMBER, 25);
		cal3.set(2040, Calendar.APRIL, 1);
		noDate.set(Calendar.YEAR, EMPTY);
		noTime.set(Calendar.MILLISECOND, EMPTY);
		noTime.set(Calendar.HOUR_OF_DAY, 0);
		noTime.set(Calendar.MINUTE, 0);
		noTime.set(Calendar.SECOND, 0);
		time1.set(Calendar.YEAR, EMPTY);
		time1.set(Calendar.HOUR_OF_DAY, 17);
		time1.set(Calendar.MINUTE, 17);
		noDateTime.set(Calendar.YEAR, EMPTY);
		noDateTime.set(Calendar.MILLISECOND, EMPTY);
		noDateTime.set(Calendar.HOUR_OF_DAY, 0);
		noDateTime.set(Calendar.MINUTE, 0);
		noDateTime.set(Calendar.SECOND, 0);
	}
	
	@Test
	public void checkDirectoryExists() throws IOException {
		assertTrue(storageController.directoryExists());	
	}
	
	@Test
	public void checkInitialise() throws IOException {
		storageController.directoryExists();	
		storageController.setDirectory("");
		assertTrue(storageController.initialise());
	}
	
	@Test
	public void setDirectory() throws IOException {
		storageController.addTaskInList("Go to hell", cal1, noDate, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", noDate, cal1, "Home", cal2, "low");
		assertEquals(CUSTOM_DIRECTORY2, storageController.setDirectory(CUSTOM_DIRECTORY1));
		assertEquals(CUSTOM_DIRECTORY1, storageController.setDirectory(""));
		assertEquals(CUSTOM_DIRECTORY1, storageController.setDirectory(CUSTOM_DIRECTORY2));
		assertEquals(CUSTOM_DIRECTORY2, storageController.setDirectory(""));
	}

	@Test
	public void addTask() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		assertEquals("FloatingTask",storageController.getOpenList().get(0).getClass().getSimpleName());
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		assertEquals("DeadlineTask",storageController.getOpenList().get(0).getClass().getSimpleName());
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		assertEquals("EventTask",storageController.getOpenList().get(1).getClass().getSimpleName());
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		assertEquals("FloatingTask",storageController.getOpenList().get(3).getClass().getSimpleName());
	}
	
	@Test
	public void closeTask() throws IOException {
		storageController.addTaskInList("Do homework", null, cal2, "Home", cal2, "low");
		storageController.addTaskInList("Go to hell", cal1, cal2, "Doom", noDate, "high");
		assertEquals("Do homework",storageController.closeTask(1).getTaskDescription());
	}
	
	@Test
	public void deleteTask() throws IOException {
		storageController.addTaskInList("Do homework", null, cal2, "Home", cal2, "low");
		storageController.addTaskInList("Go to hell", cal1, cal2, "Doom", noDate, "high");
		assertEquals("Do homework",storageController.deleteTask(1).getTaskDescription());
	}
	
	@Test
	public void searchName() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.searchTaskByName("home");
		assertEquals(2,searchList.size());
	}
	
	@Test
	public void searchByDate() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar searchDate = Calendar.getInstance();
		searchDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> searchList = storageController.searchTaskByDate(searchDate);
		assertEquals(2,searchList.size());
	}
	
	@Test
	public void searchPriority() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.searchTaskByPriority("low");	
		assertEquals(2,searchList.size());
	}
	
	@Test
	public void sortName() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.sortByName();
		assertEquals("Go to hell",searchList.get(2).getTaskDescription());
		assertEquals("Finish CS2103",searchList.get(1).getTaskDescription());
	}
	
//	@Test
	public void sortDate() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.sortByDate();
		assertEquals("Do homework",searchList.get(0).getTaskDescription());
		assertEquals("Finish CS2103",searchList.get(3).getTaskDescription());
	}
	
	@Test
	public void sortPriority() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "medium");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.sortByPriority();
		assertEquals("Do homework",searchList.get(3).getTaskDescription());
		assertEquals("Finish CS2103",searchList.get(1).getTaskDescription());
	}
	
	@Test
	public void updateTask() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		EventTask eventTask = new EventTask("Finish CS2103 and CS3230", cal1, newDate, "Home", noDate, "highest",3);
		list = storageController.updateTask(3, "Finish CS2103 and CS3230", noDate, newDate, "Home", noDate, "highest");
		assertEquals(eventTask.getTaskDescription(), list.get(1).getTaskDescription());
		assertEquals(eventTask.durationToString(), list.get(1).durationToString());
	}	

	@Test
	public void updateTaskWithTime() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "", noDate, time1, "Home", noDate, "highest");
		assertEquals(FORMAT_TIME.format(time1.getTime()), FORMAT_TIME.format(list.get(1).getEndTime().getTime()));
	}
	
	@Test
	public void searchOnDate() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar searchDate = Calendar.getInstance();
		searchDate.set(2030, Calendar.DECEMBER, 25);
		ArrayList<Task> searchList = storageController.searchTaskOnDate(searchDate);
		assertEquals("Sign up for homework",searchList.get(0).getTaskDescription());
	}
	
	@Test 
	public void checkCloseList() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		storageController.closeTask(1);
		storageController.closeTask(4);
		ArrayList<Task> list = storageController.getCloseList();
		assertEquals("Go to hell",list.get(0).getTaskDescription());
		assertEquals("Finish CS2103",list.get(1).getTaskDescription());
	}
	
	@Test	// event task ---> deadline task
	public void updateTaskType1() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "", null, cal3, "School", noDate, "high");
		DeadlineTask deadlineTask = new DeadlineTask("Sign up for homework", cal3, "School", noDate, "high",3);
		assertEquals(deadlineTask.toString(), list.get(1).toString());
	}
	
	@Test	
	// event task ---> floating task
	public void updateTaskType2() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "Bee CS2103", null, null, "School", noDate, "high");
		FloatingTask floatingTask = new FloatingTask("Bee CS2103", "School", noDate, "high", 3);
		assertEquals(floatingTask.toString(), list.get(1).toString());
	}
	
	@Test	
	// event task ---> event task
	public void updateTaskType3() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "", cal2, cal3, "School", noDate, "high");
		Calendar cal = (Calendar) cal2.clone();
		cal.set(2030, Calendar.DECEMBER, 25);
		EventTask eventTask = new EventTask("Sign up for homework", cal, cal3, "School", noDate, "high", 3);
		assertEquals(eventTask.toString(), list.get(1).toString());
	}
	
	@Test 
	// floating task ---> event task
	public void updateTaskType4() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(1, "", cal1, cal2, "Hell", noDate, "high");
		EventTask eventTask = new EventTask("Go to hell", cal1, cal2, "Hell", noDate, "high", 1);
		assertEquals(eventTask.toString(), list.get(1).toString());
	}
	
	@Test 
	// floating task ---> deadline task
	public void updateTaskType5() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(1, "", null, cal2, "Heaven", noDate, "high");
		DeadlineTask deadlineTask = new DeadlineTask("Go to hell", cal2, "Heaven", noDate, "high",1);
		assertEquals(deadlineTask.toString(), list.get(1).toString());
	}
	
	@Test 
	// floating task ---> floating task
	public void updateTaskType6() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(1, "", null, null, "LT33", noDate, "high");
		FloatingTask floatingTask = new FloatingTask("Go to hell", "LT33", noDate, "high", 3);
		assertEquals(floatingTask.toString(), list.get(1).toString());
	}
	
	@Test 
	// deadline task ---> event task	
	public void updateTaskType7() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(2, "", cal1, cal2, "Hell", noDate, "high");
		Calendar cal = (Calendar) cal1.clone();
		cal.set(2020, Calendar.JUNE, 30);
		EventTask eventTask = new EventTask("Do homework", cal, cal2, "Hell", noDate, "high", 2);
		assertEquals(eventTask.toString(), list.get(1).toString());
	}
	
	@Test 
	// deadline task --> floating task
	public void updateTaskType8() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(2, "", null, null, "Hell", noDate, "high");
		FloatingTask floatingTask = new FloatingTask("Do homework", "Hell", noDate, "high", 3);
		assertEquals(floatingTask.toString(), list.get(1).toString());
	}
	
	@Test 
	// deadline task ---> deadline task
	public void updateTaskType9() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(2, "", null, cal3, "Hell", noDate, "high");
		DeadlineTask deadlineTask = new DeadlineTask("Do homework", cal3, "Hell", noDate, "high",1);
		assertEquals(deadlineTask.toString(), list.get(1).toString());
	}

```
###### Fantasktic\src\application\storage\Task.java
``` java

package application.storage;

import java.text.SimpleDateFormat;
import java.util.Calendar;
/**
 * Task is the parent class of all Task types.
 * This class is used when the user wants to interacts with a Task.
 */
public abstract class Task implements Cloneable {

	// Task variables
	private String taskDescription;
	private String location;
	protected Calendar remindDate;
	protected String priority;
	private int taskIndex;
	
	// Date & Time String format
	private static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("d MMM yyyy");
	private static final SimpleDateFormat FORMAT_TIME = new SimpleDateFormat("h:mm a");
	
	// Constants
	protected static final int EMPTY_DATE = 1;
    protected static final int EMPTY_TASK = -1;
    protected static final int EMPTY_TIME_PARAMETER_1 = 1;
    protected static final int EMPTY_TIME_PARAMETER_2 = 0;
	protected static final int ONE_DAY = 86400000;
	protected static final int TWO_HOUR = 7200000;
    protected static final String EMPTY_DATE_STRING = "";
    protected static final String EMPTY_STRING = "";
    protected static final String EMPTY_TIME_STRING = "";
    protected static final String KEYWORD_AND = "and";
    protected static final String KEYWORD_AT = ", at ";
    protected static final String KEYWORD_BY = "by ";
    protected static final String KEYWORD_QUOTE = "\"";
    protected static final String KEYWORD_TO = " to ";
    protected static final String KEYWORD_SPACE = " ";
    protected static final String KEYWORD_FULLSTOP = ". ";
    protected static final String KEYWORD_PRIORITY = "Priority ";
    protected static final Calendar NO_DATE = null;
    protected static final Calendar NO_TIME = null;
	protected static final String HIGH = "high";
	protected static final String MEDIUM = "medium";
	protected static final String LOW = "low";
	

	/**
	 * Task default constructor.
	 */
	public Task() {
		taskDescription = EMPTY_STRING;
		location = EMPTY_STRING;
		remindDate = Calendar.getInstance();
		priority = EMPTY_STRING;
		taskIndex = EMPTY_TASK;
	}
	
	/**
	 * Task constructor with specified variables.
	 */
	public Task(String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate,
			String priority, int taskIndex) {
		this.taskDescription = taskDescription;
		this.location = location;
		this.remindDate = remindDate;
		this.priority = priority;
		this.taskIndex = taskIndex;
	}

	/**
	 * Set the task description.
	 */
	public void setTaskDescription(String taskDescription) {
		this.taskDescription = taskDescription;
	}

	/**
	 * Set the task location.
	 */
	public void setLocation(String location) {
		this.location = location;
	}

	/**
	 * Set the remind date (year, month, date).
	 */
	public void setRemindDate(Calendar remindDate) {
		this.remindDate.set(remindDate.get(Calendar.YEAR), remindDate.get(Calendar.MONTH), remindDate.get(Calendar.DATE));
	}
	
	/**
	 * Set the remind time (hour, minute, seconds, milliseconds).
	 */
	public void setRemindTime(Calendar remindTime) {
		this.remindDate.set(Calendar.HOUR_OF_DAY, remindTime.get(Calendar.HOUR_OF_DAY));
		this.remindDate.set(Calendar.MINUTE, remindTime.get(Calendar.MINUTE));
		this.remindDate.set(Calendar.SECOND, remindTime.get(Calendar.SECOND));
		this.remindDate.set(Calendar.MILLISECOND, remindTime.get(Calendar.MILLISECOND));
	}

	/**
	 * Set the priority.
	 */
	public void setPriority(String priority) {
		this.priority = priority;
	}

	/**
	 * Set the task index.
	 */
	public void setTaskIndex(int taskIndex) {
		this.taskIndex = taskIndex;
	}

	/**
	 * Get the task description.
	 */
	public String getTaskDescription() {
		return taskDescription;
	}
	
	/**
	 * Get the task index.
	 */
	public int getTaskIndex() {
		return taskIndex;
	}

	/**
	 * Get the location.
	 */
	public String getLocation() {
		return location;
	}

	/**
	 * Get the remind date (year, month, date).
	 */
	public Calendar getRemindDate() {
		return remindDate;
	}
	
	/**
	 * Get the remind date (hour, minute, seconds, milliseconds).
	 */
	public Calendar getRemindTime() {
		return remindDate;
	}

	/**
	 * Get the priority.
	 */
	public String getPriority() {
		return priority;
	}
	
	/**
	 * Formats a given date into a String (e.g 7th April 2016)
	 */
	public String dateToString(Calendar date) {
		if (!isDateEmpty(date)) {
			return FORMAT_DATE.format(date.getTime());
		} else {
			return EMPTY_STRING;
		}
	}

	/**
	 * Checks if the date is "empty".
	 */
	public boolean isDateEmpty(Calendar date) {
		return date.get(Calendar.YEAR)==EMPTY_DATE;
	}
	
	/**
	 * Formats a given time into a String (e.g 5:30 PM)
	 */
	public String timeToString(Calendar date) {
		if (!isTimeEmpty(date)) {
			return FORMAT_TIME.format(date.getTime());
		} else {
			return EMPTY_STRING;
		}

	}
	
	/**
	 * Checks if the time is "empty".
	 */
	public boolean isTimeEmpty(Calendar date) {
		return (date.get(Calendar.MILLISECOND) == EMPTY_TIME_PARAMETER_1)
				&& (date.get(Calendar.HOUR_OF_DAY) == EMPTY_TIME_PARAMETER_2)
				&& (date.get(Calendar.MINUTE) == EMPTY_TIME_PARAMETER_2)
				&& (date.get(Calendar.SECOND) == EMPTY_TIME_PARAMETER_2);
	}
	
	// abstract methods for subclasses
	public abstract Calendar getStartDate();
	
	public abstract Calendar getEndDate();
	
	public abstract Calendar getStartTime();
	
	public abstract Calendar getEndTime();
	
	public abstract String durationToString();

```
###### Fantasktic\src\application\storage\Task.java
``` java
	/**
	 * Clones a Task object.
	 */
	protected Object clone() throws CloneNotSupportedException {
    	Task newTask = (Task) super.clone();
    	newTask.remindDate = (Calendar) remindDate.clone();
    	return newTask;
    }
	
}
```
###### Fantasktic\src\application\storage\TaskManager.java
``` java

package application.storage;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.logging.Level;
import java.util.logging.Logger;
import application.logger.LoggerHandler;

/**
 * TaskManager is used when task manipulation functions are needed. It runs and
 * execute all the given task functions, i.e add, close, delete, search, update,
 * etc.
 */
public class TaskManager {

	// Constants
	private static final int DATE_IS_BY_AND_ON = 0;
	private static final int EMPTY_DATE = 1;
	private static final int EMPTY_TIME_PARAMETER_1 = 1;
	private static final int EMPTY_TIME_PARAMETER_2 = 0;
	private static final int INVALID_TASK = -1;
	private static final int INVALID_INDEX = -1;
	private static final int INVALID_TASK_INDEX = 0;
	private static final String DEADLINE_TASK = "DEADLINE_TASK";
	private static final String EMPTY_STRING = "";
	private static final String EVENT_TASK = "EVENT_TASK";
	private static final String FLOATING_TASK = "FLOATING_TASK";
	private static final String SPACE = "\\s+";

	// Log messages
	private static final String LOG_INFO_ADD_FLOATING_TASK = "Adding Floating Task.";
	private static final String LOG_INFO_ADD_DEADLINE_TASK = "Adding Deadline Task.";
	private static final String LOG_INFO_ADD_EVENT_TASK = "Adding Event Task.";
	private static final String LOG_INFO_CONVERT_TO_EVENT_TASK = "Converting to Event Task.";
	private static final String LOG_INFO_CONVERT_TO_DEADLINE_TASK = "Converting to Deadline Task.";
	private static final String LOG_INFO_CONVERT_TO_FLOATING_TASK = "Converting to Floating Task.";
	private static final String LOG_INFO_DELETED_TASK = "Deleted Task.";
	private static final String LOG_INFO_SEARCH_BY_DATE = "Searching tasks by date.";
	private static final String LOG_INFO_SEARCH_NAME = "Searching tasks with name.";
	private static final String LOG_INFO_SEARCH_ON_DATE = "Searching tasks on date.";
	private static final String LOG_INFO_UPDATE_TASK = "Updating Task.";
	private static final String LOG_INFO_UPDATED_DEADLINE_END_DATE = "Updated Deadline Task's end date.";
	private static final String LOG_INFO_UPDATED_DEADLINE_END_TIME = "Updated Deadline Task's end time.";
	private static final String LOG_INFO_UPDATED_EVENT_START_DATE = "Updated Event Task's start date.";
	private static final String LOG_INFO_UPDATED_EVENT_START_TIME = "Updated Event Task's start time.";
	private static final String LOG_INFO_UPDATED_EVENT_END_DATE = "Updated Event Task's end date.";
	private static final String LOG_INFO_UPDATED_EVENT_END_TIME = "Updated Event Task's end time.";
	private static final String LOG_INFO_UPDATED_LOCATION = "Updated location.";
	private static final String LOG_INFO_UPDATED_PRIORITY = "Updated priority";
	private static final String LOG_INFO_UPDATED_REMIND_DATE = "Updated remind date.";
	private static final String LOG_INFO_UPDATED_REMIND_TIME = "Updated remind time.";
	private static final String LOG_INFO_UPDATED_TASK_DESCRIPTION = "Updated task description.";

	// Logger
	private static Logger logger = LoggerHandler.getLog();

```
###### Fantasktic\src\application\storage\TaskManager.java
``` java
	/**
	 * Find and delete the task in the open list.
	 */
	public ArrayList<Task> delete(ArrayList<Task> openList, int taskIndex) {
		assert (taskIndex > INVALID_TASK_INDEX);
		int indexOfTask = findIndexOfTaskInList(openList, taskIndex);
		if (indexOfTask > INVALID_INDEX) {
			openList.remove(indexOfTask);
			logger.log(Level.INFO, LOG_INFO_DELETED_TASK);
		}
		return openList;
	}

	/**
	 * Search "name" in the open list and and return search results.
	 */
	public ArrayList<Task> searchName(ArrayList<Task> openList, String searchTask) {
		assert (searchTask != null);
		String[] splitArray = searchTask.split(SPACE);
		ArrayList<Task> searchList = new ArrayList<Task>();
		logger.log(Level.INFO, LOG_INFO_SEARCH_NAME);
		for (int i = 0; i < openList.size(); i++) {
			Task obj = openList.get(i);
			for (int k = 0; k < splitArray.length; k++) {
				if (obj.getTaskDescription().toLowerCase().contains(splitArray[k].toLowerCase())) {
					searchList.add(obj);
					break;
				}
			}
		}
		return searchList;
	}

	/**
	 * Search the tasks by a specified date in the open list and return search
	 * results.
	 */
	public ArrayList<Task> searchDateBy(ArrayList<Task> openList, Calendar searchDate) {
		assert (searchDate != null);
		ArrayList<Task> searchList = new ArrayList<Task>();
		logger.log(Level.INFO, LOG_INFO_SEARCH_BY_DATE);
		for (int i = 0; i < openList.size(); i++) {
			Task obj = openList.get(i);
			if (obj.getEndDate() != null) {
				if (!isDateEmpty(obj.getEndDate())) {
					if (obj.getEndDate().compareTo(searchDate) <= DATE_IS_BY_AND_ON) {
						searchList.add(obj);
					}
				}
			}
		}
		return searchList;
	}

	/**
	 * Search the tasks on a specified date in the open list and return search
	 * results.
	 */
	public ArrayList<Task> searchDateOn(ArrayList<Task> openList, Calendar searchDate) {
		assert (searchDate != null);
		ArrayList<Task> searchList = new ArrayList<Task>();
		logger.log(Level.INFO, LOG_INFO_SEARCH_ON_DATE);
		for (int i = 0; i < openList.size(); i++) {
			Task obj = openList.get(i);
			// check end date first if its deadline task
			if (obj.getEndDate() != null) {
				if (!isDateEmpty(obj.getEndDate())) {
					if (isDatesSame(searchDate, obj.getEndDate())) {
						searchList.add(obj);
						continue;
					}
				}
			}
			// else check start date too if its event task
			if (obj.getStartDate() != null) {
				if (!isDateEmpty(obj.getStartDate())) {
					if (isDatesSame(searchDate, obj.getStartDate())) {
						searchList.add(obj);
						continue;
					}
				}
			}
		}
		return searchList;
	}

	/**
	 * Checks two given date if its same.
	 */
	private boolean isDatesSame(Calendar searchDate, Calendar obj) {
		return obj.get(Calendar.YEAR) == searchDate.get(Calendar.YEAR)
				&& obj.get(Calendar.MONTH) == searchDate.get(Calendar.MONTH)
				&& obj.get(Calendar.DATE) == searchDate.get(Calendar.DATE);
	}

```
###### Fantasktic\src\application\storage\TaskManager.java
``` java
	/**
	 * Sort the open list in ascending date.
	 */
	public ArrayList<Task> sortDate(ArrayList<Task> openList) {
		Collections.sort(openList, new ComparatorDate());
		return openList;
	}

	/**
	 * Sort the open list in ascending task name.
	 */
	public ArrayList<Task> sortName(ArrayList<Task> openList) {
		Collections.sort(openList, (o1, o2) -> o1.getTaskDescription().compareTo(o2.getTaskDescription()));
		return openList;
	}

	/**
	 * Sort the open list in priority (high to low).
	 */
	public ArrayList<Task> sortPriority(ArrayList<Task> openList) {
		Collections.sort(openList, new ComparatorPriority());
		return openList;
	}

	/**
	 * Update a specified task with specified variables.
	 */
	public ArrayList<Task> update(ArrayList<Task> openList, String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate, String priority, int taskIndex) {

		assert (taskIndex > INVALID_TASK_INDEX);
		// find task
		int indexOfTask = findIndexOfTaskInList(openList, taskIndex);
		logger.log(Level.INFO, LOG_INFO_UPDATE_TASK);

		// update task based on current task type
		if (openList.get(indexOfTask) instanceof FloatingTask) {
			convertFloatingTask(openList, taskDescription, startDate, endDate, location, remindDate, priority,
					taskIndex, indexOfTask);
		} else if (openList.get(indexOfTask) instanceof DeadlineTask) {
			convertDeadlineTask(openList, taskDescription, startDate, endDate, location, remindDate, priority,
					taskIndex, indexOfTask);
		} else if (openList.get(indexOfTask) instanceof EventTask) {
			convertEventTask(openList, taskDescription, startDate, endDate, location, remindDate, priority, taskIndex,
					indexOfTask);
		}
		return openList;
	}

	/**
	 * Convert the FloatingTask if necessary (to DeadlineTask or EventTask).
	 */
	private void convertFloatingTask(ArrayList<Task> openList, String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate, String priority, int taskIndex, int indexOfTask) {
		assert (openList != null);

		// convert : floating task to event task
		if (toEventTask(startDate, endDate)) {
			openList.set(indexOfTask, updateToTaskType(EVENT_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
			logger.log(Level.INFO, LOG_INFO_CONVERT_TO_EVENT_TASK);
		}

		// convert : floating task to deadline task
		else if (toDeadlineTask(startDate, endDate)) {
			openList.set(indexOfTask, updateToTaskType(DEADLINE_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
			logger.log(Level.INFO, LOG_INFO_CONVERT_TO_DEADLINE_TASK);
		}

		// no conversion
		else {
			openList.set(indexOfTask, updateToTaskType(FLOATING_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
		}
	}

	/**
	 * Convert the DeadlineTask if necessary (to FloatingTask or EventTask).
	 */
	private void convertDeadlineTask(ArrayList<Task> openList, String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate, String priority, int taskIndex, int indexOfTask) {
		assert (openList != null);

		// convert : deadline task to event task
		if (toEventTask(startDate, endDate)) {
			openList.set(indexOfTask, updateToTaskType(EVENT_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
			logger.log(Level.INFO, LOG_INFO_CONVERT_TO_EVENT_TASK);
		}

		// convert : deadline task to floating task
		else if (toFloatingTask(startDate, endDate)) {
			openList.set(indexOfTask, updateToTaskType(FLOATING_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
			logger.log(Level.INFO, LOG_INFO_CONVERT_TO_FLOATING_TASK);
		}

		// no conversion
		else {
			openList.set(indexOfTask, updateToTaskType(DEADLINE_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
		}
	}

	/**
	 * Convert the EventTask if necessary (to FloatingTask or DeadlineTask).
	 */
	private void convertEventTask(ArrayList<Task> openList, String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate, String priority, int taskIndex, int indexOfTask) {
		assert (openList != null);

		// convert : event task to deadline task
		if (toDeadlineTask(startDate, endDate)) {
			openList.set(indexOfTask, updateToTaskType(DEADLINE_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
			logger.log(Level.INFO, LOG_INFO_CONVERT_TO_DEADLINE_TASK);
		}

		// convert : event task to floating task
		else if (toFloatingTask(startDate, endDate)) {
			openList.set(indexOfTask, updateToTaskType(FLOATING_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
			logger.log(Level.INFO, LOG_INFO_CONVERT_TO_FLOATING_TASK);
		}

		// no conversion
		else {
			openList.set(indexOfTask, updateToTaskType(EVENT_TASK, openList.get(indexOfTask), taskDescription,
					startDate, endDate, location, remindDate, priority, taskIndex));
		}
	}

	/**
	 * Updates and convert a task to the task type specified.
	 */
	private Task updateToTaskType(String taskType, Task originalTask, String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate, String priority, int taskIndex) {
		assert (taskIndex > INVALID_TASK_INDEX);
		String originalTaskDescription = originalTask.getTaskDescription();
		Calendar originalStartDate = originalTask.getStartDate();
		Calendar originalEndDate = originalTask.getEndDate();
		Calendar originalRemindDate = originalTask.getRemindDate();
		String originalLocation = originalTask.getLocation();
		String originalPriority = originalTask.getPriority();

		// determine which task type to update/convert to
		switch (taskType) {
		case (FLOATING_TASK):
			return updatedToFloatingTask(taskDescription, startDate, endDate, location, remindDate, priority, taskIndex,
					originalTaskDescription, originalRemindDate, originalLocation, originalPriority);
		case (DEADLINE_TASK):
			return updatedToDeadlineTask(originalTask, taskDescription, startDate, endDate, location, remindDate,
					priority, taskIndex, originalTaskDescription, originalEndDate, originalRemindDate, originalLocation,
					originalPriority);
		case (EVENT_TASK):
			return updatedToEventTask(originalTask, taskDescription, startDate, endDate, location, remindDate, priority,
					taskIndex, originalTaskDescription, originalStartDate, originalEndDate, originalRemindDate,
					originalLocation, originalPriority);
		default:
			return null;
		}
	}

	/**
	 * Update and returns the task in EventTask type.
	 */
	private Task updatedToEventTask(Task originalTask, String taskDescription, Calendar startDate, Calendar endDate,
			String location, Calendar remindDate, String priority, int taskIndex, String originalTaskDescription,
			Calendar originalStartDate, Calendar originalEndDate, Calendar originalRemindDate, String originalLocation,
			String originalPriority) {
		assert (originalTask != null);
		EventTask eventTask;

		// get the details from original task type and insert into updated task
		if (originalTask instanceof FloatingTask) {
			eventTask = new EventTask(originalTaskDescription, Calendar.getInstance(), Calendar.getInstance(),
					originalLocation, originalRemindDate, originalPriority, taskIndex);
		} else if (originalTask instanceof DeadlineTask) {
			eventTask = new EventTask(originalTaskDescription, Calendar.getInstance(), originalEndDate,
					originalLocation, originalRemindDate, originalPriority, taskIndex);
		} else {
			eventTask = new EventTask(originalTaskDescription, originalStartDate, originalEndDate, originalLocation,
					originalRemindDate, originalPriority, taskIndex);
		}
		eventTask = (EventTask) updateTaskParameters(eventTask, taskDescription, startDate, endDate, location,
				remindDate, priority, taskIndex);
		return eventTask;
	}

	/**
	 * Update and returns the task in DeadlineTask type.
	 */
	private Task updatedToDeadlineTask(Task originalTask, String taskDescription, Calendar startDate, Calendar endDate,
			String location, Calendar remindDate, String priority, int taskIndex, String originalTaskDescription,
			Calendar originalEndDate, Calendar originalRemindDate, String originalLocation, String originalPriority) {
		assert (originalTask != null);
		DeadlineTask deadlineTask;

		// get the details from original task type and insert into updated task
		if (originalTask instanceof FloatingTask) {
			deadlineTask = new DeadlineTask(originalTaskDescription, Calendar.getInstance(), originalLocation,
					originalRemindDate, originalPriority, taskIndex);
		} else {
			deadlineTask = new DeadlineTask(originalTaskDescription, originalEndDate, originalLocation,
					originalRemindDate, originalPriority, taskIndex);
		}
		deadlineTask = (DeadlineTask) updateTaskParameters(deadlineTask, taskDescription, startDate, endDate, location,
				remindDate, priority, taskIndex);
		return deadlineTask;
	}

	/**
	 * Update and returns the task in FloatingTask type.
	 */
	private Task updatedToFloatingTask(String taskDescription, Calendar startDate, Calendar endDate, String location,
			Calendar remindDate, String priority, int taskIndex, String originalTaskDescription,
			Calendar originalRemindDate, String originalLocation, String originalPriority) {

		// get the details from original task type and insert into updated task
		FloatingTask floatingTask = new FloatingTask(originalTaskDescription, originalLocation, originalRemindDate,
				originalPriority, taskIndex);
		floatingTask = (FloatingTask) updateTaskParameters(floatingTask, taskDescription, startDate, endDate, location,
				remindDate, priority, taskIndex);
		return floatingTask;
	}

	/**
	 * Updates a task with the specified variables.
	 */
	private Task updateTaskParameters(Task obj, String taskDescription, Calendar startDate, Calendar endDate,
			String location, Calendar remindDate, String priority, int taskIndex) {

		assert (taskIndex > INVALID_TASK_INDEX);

		// update task parameters
		if (!taskDescription.equalsIgnoreCase(EMPTY_STRING)) {
			obj.setTaskDescription(taskDescription);
			logger.log(Level.INFO, LOG_INFO_UPDATED_TASK_DESCRIPTION);
		}

		if (!location.equalsIgnoreCase(EMPTY_STRING)) {
			obj.setLocation(location);
			logger.log(Level.INFO, LOG_INFO_UPDATED_LOCATION);
		}

		if (!isDateEmpty(remindDate)) {
			obj.setRemindDate(remindDate);
			logger.log(Level.INFO, LOG_INFO_UPDATED_REMIND_DATE);
		}

		if (!isTimeEmpty(remindDate)) {
			obj.setRemindTime(remindDate);
			logger.log(Level.INFO, LOG_INFO_UPDATED_REMIND_TIME);
		}

		if (!priority.equalsIgnoreCase(EMPTY_STRING)) {
			obj.setPriority(priority);
			logger.log(Level.INFO, LOG_INFO_UPDATED_PRIORITY);
		}

		if (obj instanceof DeadlineTask) {
			if (!isDateEmpty(endDate)) {
				((DeadlineTask) obj).setEndDate(endDate);
				((DeadlineTask) obj).setEndTime(endDate);
				logger.log(Level.INFO, LOG_INFO_UPDATED_DEADLINE_END_DATE);
			}
			if (!isTimeEmpty(endDate)) {
				((DeadlineTask) obj).setEndTime(endDate);
				logger.log(Level.INFO, LOG_INFO_UPDATED_DEADLINE_END_TIME);
			}

			return obj;
		}

		if (obj instanceof EventTask) {
			if (!isDateEmpty(startDate)) {
				((EventTask) obj).setStartDate(startDate);
				logger.log(Level.INFO, LOG_INFO_UPDATED_EVENT_START_DATE);
			}
			if (!isTimeEmpty(startDate)) {
				((EventTask) obj).setStartTime(startDate);
				logger.log(Level.INFO, LOG_INFO_UPDATED_EVENT_START_TIME);
			}
			if (!isDateEmpty(endDate)) {
				((EventTask) obj).setEndDate(endDate);
				((EventTask) obj).setEndTime(endDate);
				logger.log(Level.INFO, LOG_INFO_UPDATED_EVENT_END_DATE);
			}
			if (!isTimeEmpty(endDate)) {
				((EventTask) obj).setEndTime(endDate);
				logger.log(Level.INFO, LOG_INFO_UPDATED_EVENT_END_TIME);
			}
			return obj;
		}
		return obj;
	}

	/**
	 * Find the index of the task in the open list.
	 */
	private int findIndexOfTaskInList(ArrayList<Task> openList, int taskIndex) {
		for (int i = 0; i < openList.size(); i++) {
			if (isTheRightTask(openList, taskIndex, i)) {
				return i;
			}
		}
		return INVALID_TASK;
	}

	/**
	 * Checks whether convert task to FloatingTask.
	 */
	private boolean toFloatingTask(Calendar startDate, Calendar endDate) {
		return startDate == null && endDate == null;
	}

	/**
	 * Checks whether convert task to DeadlineTask.
	 */
	private boolean toDeadlineTask(Calendar startDate, Calendar endDate) {
		return startDate == null && endDate != null;
	}

	/**
	 * Checks whether convert task to EventTask.
	 */
	private boolean toEventTask(Calendar startDate, Calendar endDate) {
		return startDate != null && endDate != null && !isDateEmpty(startDate) && !isDateEmpty(endDate);
	}

	/**
	 * Checks whether a date is "empty".
	 */
	private boolean isDateEmpty(Calendar date) {
		return date.get(Calendar.YEAR) == EMPTY_DATE;
	}

	/**
	 * Checks whether a time is "empty".
	 */
	private boolean isTimeEmpty(Calendar date) {
		return date.get(Calendar.MILLISECOND) == EMPTY_TIME_PARAMETER_1
				&& date.get(Calendar.HOUR_OF_DAY) == EMPTY_TIME_PARAMETER_2
				&& date.get(Calendar.MINUTE) == EMPTY_TIME_PARAMETER_2
				&& date.get(Calendar.SECOND) == EMPTY_TIME_PARAMETER_2;
	}

```
###### Fantasktic\src\application\storage\TaskManager.java
``` java
}

/**
 * Custom comparator for sorting tasks based on priority.
 */
class ComparatorPriority implements Comparator<Task> {

	// Constants
	private static final int NO_PRIORITY_VALUE = 4;
	private static final int LOW_PRIORITY_VALUE = 3;
	private static final int MEDIUM_PRIORITY_VALUE = 2;
	private static final int HIGH_PRIORITY_VALUE = 1;
	private static final String NO_PRIORITY = "";
	private static final String HIGH_PRIORITY = "high";
	private static final String MEDIUM_PRIORITY = "medium";
	private static final String LOW_PRIORITY = "low";
	private static final int TASK_1_PRIORITY = 0;
	private static final int TASK_2_PRIORITY = 1;

	@Override
	public int compare(Task o1, Task o2) {
		Task[] tasks = { o1, o2 };
		int[] integers = new int[tasks.length];
		for (int i = 0; i < tasks.length; i++) {
			if (tasks[i].getPriority().equals(NO_PRIORITY))
				integers[i] = NO_PRIORITY_VALUE;
			if (tasks[i].getPriority().equalsIgnoreCase(LOW_PRIORITY))
				integers[i] = LOW_PRIORITY_VALUE;
			if (tasks[i].getPriority().equalsIgnoreCase(MEDIUM_PRIORITY))
				integers[i] = MEDIUM_PRIORITY_VALUE;
			if (tasks[i].getPriority().equalsIgnoreCase(HIGH_PRIORITY))
				integers[i] = HIGH_PRIORITY_VALUE;
		}
		return Integer.compare(integers[TASK_1_PRIORITY], integers[TASK_2_PRIORITY]);
	}
}

/**
 * Custom comparator for sorting tasks based on date.
 */
class ComparatorDate implements Comparator<Task> {

	// Constants
	private static final int LEFT_TASK_DATE_IS_BEFORE = -1;
	private static final int LEFT_TASK_DATE_IS_AFTER = 1;
	private static final int INVALID = 0;

	@Override
	public int compare(Task o1, Task o2) {
		if (o1 instanceof DeadlineTask && o2 instanceof DeadlineTask) {
			return ((DeadlineTask) o1).getEndTime().compareTo(((DeadlineTask) o2).getEndTime());
		} else if (o1 instanceof DeadlineTask && o2 instanceof EventTask) {
			return ((DeadlineTask) o1).getEndTime().compareTo(((EventTask) o2).getEndTime());
		} else if (o1 instanceof DeadlineTask && o2 instanceof FloatingTask) {
			return LEFT_TASK_DATE_IS_BEFORE;
		} else if (o1 instanceof EventTask && o2 instanceof DeadlineTask) {
			return ((EventTask) o1).getEndTime().compareTo(((DeadlineTask) o2).getEndTime());
		} else if (o1 instanceof EventTask && o2 instanceof EventTask) {
			return ((EventTask) o1).getEndTime().compareTo(((EventTask) o2).getEndTime());
		} else if (o1 instanceof EventTask && o2 instanceof FloatingTask) {
			return LEFT_TASK_DATE_IS_BEFORE;
		} else if (o1 instanceof FloatingTask && o2 instanceof DeadlineTask) {
			return LEFT_TASK_DATE_IS_AFTER;
		} else if (o1 instanceof FloatingTask && o2 instanceof EventTask) {
			return LEFT_TASK_DATE_IS_AFTER;
		} else {
			return INVALID;
		}

	}
}
```
###### Fantasktic\src\application\storage\TaskSerializer.java
``` java

package application.storage;

import java.lang.reflect.Type;
import java.util.Calendar;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

/**
 * TaskSerializer is a custom serializer that originated from GSON Library.
 * It is used for easy and neat saving/load of the tasks data into/from the text file.
 */
public class TaskSerializer implements JsonSerializer<Task>, JsonDeserializer<Task> {

	// Constants
	private static final String TASK_TYPE = "taskType";
	private static final String TASK_DESCRIPTION = "taskDescription";
	private static final String TASK_START_DATE = "startDate";
	private static final String TASK_START_DATE_MILLISECONDS = "start-Date-milliseconds";
	private static final String TASK_END_DATE = "endDate";
	private static final String TASK_END_DATE_MILLISECONDS = "end-Date-milliseconds";
	private static final String TASK_LOCATION = "location";
	private static final String TASK_REMIND_DATE = "remindDate";
	private static final String TASK_REMIND_DATE_MILLISECONDS = "remind-Date-milliseconds";
	private static final String TASK_PRIORITY = "priority";
	private static final String TASK_INDEX = "taskIndex";

	/**
	 * Saves the Task properties into a JSON object.
	 */
	@Override
	public JsonElement serialize(Task src, Type typeOfSrc, JsonSerializationContext context) {

		JsonObject object = new JsonObject();
		String className = src.getClass().getSimpleName();
		object.addProperty(TASK_TYPE, className);
		object.addProperty(TASK_DESCRIPTION, src.getTaskDescription());

		if (src instanceof DeadlineTask) {
			JsonElement endDate = context.serialize(((DeadlineTask) src).getEndDate());
			object.add(TASK_END_DATE, endDate);
			long endMilliseconds = ((DeadlineTask) src).getEndDate().get(Calendar.MILLISECOND);
			object.addProperty(TASK_END_DATE_MILLISECONDS, endMilliseconds);
		} else if (src instanceof EventTask) {
			JsonElement startDate = context.serialize(((EventTask) src).getStartDate());
			object.add(TASK_START_DATE, startDate);
			long startMilliseconds = ((EventTask) src).getStartDate().get(Calendar.MILLISECOND);
			object.addProperty(TASK_START_DATE_MILLISECONDS, startMilliseconds);
			JsonElement endDate = context.serialize(((EventTask) src).getEndDate());
			object.add(TASK_END_DATE, endDate);
			long endMilliseconds = ((EventTask) src).getEndDate().get(Calendar.MILLISECOND);
			object.addProperty(TASK_END_DATE_MILLISECONDS, endMilliseconds);
		}
		object.addProperty(TASK_LOCATION, src.getLocation());
		JsonElement remindDate = context.serialize(src.getRemindDate());
		object.add(TASK_REMIND_DATE, remindDate);
		long remindMilliseconds = src.getRemindDate().get(Calendar.MILLISECOND);
		object.addProperty(TASK_REMIND_DATE_MILLISECONDS, remindMilliseconds);
		object.addProperty(TASK_PRIORITY, src.getPriority());
		object.addProperty(TASK_INDEX, src.getTaskIndex());
		return object;
	}

	/**
	 * Load the task properties from JSON object into a Task object.
	 */
	@Override
	public Task deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
			throws JsonParseException {

		JsonObject object = json.getAsJsonObject();
		String className = object.get(TASK_TYPE).getAsString();
		String taskDescript = object.get(TASK_DESCRIPTION).getAsString();
		String location = object.get(TASK_LOCATION).getAsString();
		String priority = object.get(TASK_PRIORITY).getAsString();
		int taskIndex = object.get(TASK_INDEX).getAsInt();
		Calendar remindDate = context.deserialize(object.get(TASK_REMIND_DATE), Calendar.class);
		remindDate.set(Calendar.MILLISECOND, object.get(TASK_REMIND_DATE_MILLISECONDS).getAsInt());

		if (className.equalsIgnoreCase(FloatingTask.class.getSimpleName())) {
			FloatingTask floatingTask = new FloatingTask(taskDescript, location, remindDate, priority, taskIndex);
			return floatingTask;
		} else if (className.equalsIgnoreCase(DeadlineTask.class.getSimpleName())) {
			Calendar endDate = context.deserialize(object.get(TASK_END_DATE), Calendar.class);
			endDate.set(Calendar.MILLISECOND, object.get(TASK_END_DATE_MILLISECONDS).getAsInt());
			DeadlineTask deadlineTask = new DeadlineTask(taskDescript, endDate, location, remindDate, priority,
					taskIndex);
			return deadlineTask;
		} else {
			Calendar startDate = context.deserialize(object.get(TASK_START_DATE), Calendar.class);
			startDate.set(Calendar.MILLISECOND, object.get(TASK_START_DATE_MILLISECONDS).getAsInt());
			Calendar endDate = context.deserialize(object.get(TASK_END_DATE), Calendar.class);
			endDate.set(Calendar.MILLISECOND, object.get(TASK_END_DATE_MILLISECONDS).getAsInt());
			EventTask eventTask = new EventTask(taskDescript, startDate, endDate, location, remindDate, priority,
					taskIndex);
			return eventTask;
		}
	}

}
```
