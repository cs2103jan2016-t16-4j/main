# A0125522R
###### Tasker\src\application\storage\DatabaseManager.java
``` java

package application.storage;

import java.util.ArrayList;

public class DatabaseManager {
	private int taskIndex = 0;
	private ArrayList<Task> closeList = new ArrayList<Task>();
	private ArrayList<Task> openList = new ArrayList<Task>();
	
	public ArrayList<Task> getCloseList() {
		return closeList;
	}
	
	public ArrayList<Task> getOpenList() {
		return openList;
	}
	
	public int getTaskIndex() {
		return taskIndex;
	}
	
	public void setTaskIndex(int i) {
		taskIndex = i;
	}
	
	public void updateCloseList(ArrayList<Task> closeList) {
		this.closeList = closeList;
	}
	
	public void updateOpenList(ArrayList<Task> openList) {
		this.openList = openList;
	}

	public int updateTaskIndex() {
		taskIndex++;
		return taskIndex;
	}
}
```
###### Tasker\src\application\storage\DeadlineTask.java
``` java

package application.storage;

import java.util.Calendar;

public class DeadlineTask extends Task implements Cloneable {
	private Calendar endDate;
	
	public DeadlineTask() {
		setTaskDescription("");
		endDate = Calendar.getInstance();
		setLocation("");
		setRemindDate(Calendar.getInstance());
		setPriority("");
		setTaskIndex(-1);
	}
	
	public DeadlineTask(String taskDescription, Calendar endDate, String location, Calendar remindDate, String priority,
			int taskIndex) {
		
		setTaskDescription(taskDescription);
		this.endDate = endDate;
		setEndTime(endDate);
		setLocation(location);
		setRemindDate(remindDate);
		setPriority(priority);
		setTaskIndex(taskIndex);
	}
	
	public void setEndDate(Calendar endDate) {
		this.endDate.set(endDate.get(Calendar.YEAR), endDate.get(Calendar.MONTH), endDate.get(Calendar.DATE));
	}

	public void setEndTime(Calendar endTime) {
		this.endDate.set(Calendar.HOUR_OF_DAY, endTime.get(Calendar.HOUR_OF_DAY));
		this.endDate.set(Calendar.MINUTE, endTime.get(Calendar.MINUTE));
		this.endDate.set(Calendar.SECOND, endTime.get(Calendar.SECOND));
		this.endDate.set(Calendar.MILLISECOND, endTime.get(Calendar.MILLISECOND));
	}
	
	public Calendar getStartDate() {
		return null;
	}
	
	public Calendar getStartTime() {
		return null;
	}
	
	public Calendar getEndDate() {
		return endDate;
	}

	public Calendar getEndTime() {
		return endDate;
	}
	
	public String durationToString() {
		String message = "";
		String endingDate = dateToString(endDate);
		String endingTime = timeToString(endDate);
		if (!endingDate.equals("")) {
			message += "by " + endingDate;
			if (!endingTime.equals("")) {
				message += " " + endingTime;
			}
		}
		return message;		
	}
	
	public String toString() {
		String message = "\"";
		message += getTaskDescription();
		message += " " + durationToString();
		
		if (!getLocation().equalsIgnoreCase("")) {
			message += ", at " + getLocation();
		}
		
		message += "\"";
		
		return message;	
	}
	
    protected Object clone() throws CloneNotSupportedException {
    	DeadlineTask newTask = (DeadlineTask) super.clone();
    	newTask.endDate = (Calendar) endDate.clone();
    	newTask.remindDate = (Calendar) remindDate.clone();
    	return newTask;
    }



}
```
###### Tasker\src\application\storage\EventTask.java
``` java

package application.storage;

import java.util.Calendar;

public class EventTask extends Task implements Cloneable{
	private Calendar startDate;
	private Calendar endDate;
	
	public EventTask() {
		setTaskDescription("");
		startDate = Calendar.getInstance();
		endDate = Calendar.getInstance();
		setLocation("");
		setRemindDate(Calendar.getInstance());
		setPriority("");
		setTaskIndex(-1);
	}
	
	public EventTask(String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate,
			String priority, int taskIndex) {
		setTaskDescription(taskDescription);
		this.startDate = startDate;
		this.endDate = endDate;
		setLocation(location);
		setRemindDate(remindDate);
		setPriority(priority);
		setTaskIndex(taskIndex);
	}
	
	public void setStartDate(Calendar startDate) {
		this.startDate.set(startDate.get(Calendar.YEAR), startDate.get(Calendar.MONTH), startDate.get(Calendar.DATE));
	}
	
	public void setStartTime(Calendar startTime) {
	    this.startDate.set(Calendar.HOUR_OF_DAY, startTime.get(Calendar.HOUR_OF_DAY));
		this.startDate.set(Calendar.MINUTE, startTime.get(Calendar.MINUTE));
	    this.startDate.set(Calendar.SECOND, startTime.get(Calendar.SECOND));
		this.startDate.set(Calendar.MILLISECOND, startTime.get(Calendar.MILLISECOND));
	}

	public void setEndDate(Calendar endDate) {
		this.endDate.set(endDate.get(Calendar.YEAR), endDate.get(Calendar.MONTH), endDate.get(Calendar.DATE));
	}

	public void setEndTime(Calendar endTime) {
		this.endDate.set(Calendar.HOUR_OF_DAY, endTime.get(Calendar.HOUR_OF_DAY));
		this.endDate.set(Calendar.MINUTE, endTime.get(Calendar.MINUTE));
		this.endDate.set(Calendar.SECOND, endTime.get(Calendar.SECOND));
		this.endDate.set(Calendar.MILLISECOND, endTime.get(Calendar.MILLISECOND));
	}
	
	public Calendar getStartDate() {
		return startDate;
	}
	
	public Calendar getStartTime() {
		return startDate;
	}

	public Calendar getEndDate() {
		return endDate;
	}

	public Calendar getEndTime() {
		return endDate;
	}
	
	public String durationToString() {
		String message = "";
		String startingDate = dateToString(startDate);
		String startingTime = timeToString(startDate);
		String endingDate = dateToString(endDate);
		String endingTime = timeToString(endDate);
		// display start date, if exist
		if (!startingDate.equals("")) {
			message += startingDate;
			if (!startingTime.equals("")) {
				message += " " + startingTime;
			} // if start date and end date is same, display 1 date + both time only
			if (startingDate.equalsIgnoreCase(endingDate)) {
				if (startingTime.equals("")) {
					message += endingTime;
				}
				else if (!endingTime.equals("") && !startingTime.equals("")) {
					message += " to " + endingTime;
				}
				return message;
			}
		}
		// display start date and end date, if both exist
		if ( (!startingDate.equals("")) && (!endingDate.equals("")) ) {
			message += " to " + endingDate;
			if (!endingTime.equals("")) {
				message += " " + endingTime;
			} // display end date, if exist
		} else if (startingDate.equals("") && (!endingDate.equals(""))) {
			message += "by " + endingDate;
			if (!endingTime.equals("")) {
				message += " " + endingTime;
			}
		}
		return message;		
	}
	
	public String toString() {
		String message = "\"";
		message += getTaskDescription();
		message += " " + durationToString();
		
		if (!getLocation().equalsIgnoreCase("")) {
			message += ", at " + getLocation();
		}
		
		message += "\"";
		
		return message;	
	}
	
    protected Object clone() throws CloneNotSupportedException {
    	EventTask newTask = (EventTask) super.clone();
    	newTask.startDate = (Calendar) startDate.clone();
    	newTask.endDate = (Calendar) endDate.clone();
    	newTask.remindDate = (Calendar) remindDate.clone();
    	return newTask;
    }
}
```
###### Tasker\src\application\storage\FileManager.java
``` java

package application.storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class FileManager {

	private static final String FILE_CLOSED_NAME = "TaskerDataHistory.txt";
	private static final String FILE_DATA_NAME = "TaskerData.txt";
	private static final String FILE_DIRECTORY_NAME = "TaskerDirectory.txt";
	private static final int NO_TASK = 0;
	private String closedFilePath = "";
	private String dataFilePath = "";

	public void clear(String path) throws FileNotFoundException {
		File f = new File(path);
		if (f.exists()) {
			PrintWriter fw = new PrintWriter(path);
			fw.print("");
			fw.close();
		}
	}

	public String getClosedFilePath() {
		return closedFilePath;
	}

	public String getDataFilePath() {
		return dataFilePath;
	}

	public boolean isDirectoryExists() throws IOException {
		// check whether its user first time opening program
		File d = new File(FILE_DIRECTORY_NAME);
		if (!d.exists()) {
			PrintWriter fw = new PrintWriter(new BufferedWriter(new FileWriter(FILE_DIRECTORY_NAME, true)));
			fw.print(""); // indicate path name is not specified yet
			fw.close();
			return false;
		} else {
			return true;
		}
	}

	public ArrayList<Task> loadFile(String filePath) throws NumberFormatException, IOException {
		File f = new File(filePath);
		BufferedReader in;
		ArrayList<Task> list = new ArrayList<Task>();
		if (f.exists()) {
			String readText;
			in = new BufferedReader(new FileReader(filePath));
			// skip first line first for data file
			if (filePath.equalsIgnoreCase(dataFilePath)) {
				readText = in.readLine();
			}
			Gson gson = new GsonBuilder().registerTypeAdapter(Task.class, new TaskSerializer())
					.registerTypeAdapter(EventTask.class, new TaskSerializer())
					.registerTypeAdapter(DeadlineTask.class, new TaskSerializer())
					.registerTypeAdapter(FloatingTask.class, new TaskSerializer()).create();
			while ((readText = in.readLine()) != null) {
				Task task = gson.fromJson(readText, Task.class);
				list.add(task);
			}
			in.close();
		}
		return list;
	}

	public void loadDirectoryFile() throws IOException {
		// check whether user specified a custom directory to save datafile
		BufferedReader in = new BufferedReader(new FileReader(FILE_DIRECTORY_NAME));
		String readText = in.readLine();
		if (readText == null) {
			closedFilePath = FILE_CLOSED_NAME;
			dataFilePath = FILE_DATA_NAME;
		} else {
			closedFilePath = readText + FILE_CLOSED_NAME;
			dataFilePath = readText + FILE_DATA_NAME;
		}
		System.out.println("Closed file path : " + closedFilePath);
		System.out.println("Data file path : " + dataFilePath);
		in.close();
	}

	public int loadTaskIndex() throws IOException {
		File f = new File(dataFilePath);
		if (f.exists()) {
			BufferedReader in = new BufferedReader(new FileReader(dataFilePath));
			String readText = in.readLine();
			in.close();
			return Integer.parseInt(readText);
		} else {
			return NO_TASK;
		}
	}

	private void saveAllTasks(ArrayList<Task> list, String filePath) throws IOException {
		PrintWriter fwz = new PrintWriter(new BufferedWriter(new FileWriter(filePath, true)));
		Gson gson = new GsonBuilder().registerTypeAdapter(Task.class, new TaskSerializer())
				.registerTypeAdapter(EventTask.class, new TaskSerializer())
				.registerTypeAdapter(DeadlineTask.class, new TaskSerializer())
				.registerTypeAdapter(FloatingTask.class, new TaskSerializer()).create();
		for (int i = 0; i < list.size(); i++) {
			String json = gson.toJson(list.get(i));
			fwz.println(json);
		}
		fwz.close();
	}

	public void saveFile(ArrayList<Task> list, String filePath) throws IOException {
		// #check if file exists
		File f = new File(filePath);
		if (!f.exists()) {
			f.createNewFile();
		}

		// #save all the tasks
		saveAllTasks(list, filePath);
	}

	public void saveTaskIndex(int index) throws IOException {
		// #clear datafile first
		clear(dataFilePath);

		PrintWriter fw = new PrintWriter(new BufferedWriter(new FileWriter(dataFilePath, true)));
		fw.println(index);
		fw.close();
	}

	public boolean setDirectory(String path) throws IOException {

		if (path.equalsIgnoreCase("")) {
			System.out.println("Directory choosen : EMPTY");
			return false;
		} else {
			clear(FILE_DIRECTORY_NAME);

			PrintWriter fw = new PrintWriter(FILE_DIRECTORY_NAME);
			// get current path
			Path oldClosedFilePath = Paths.get(closedFilePath);
			Path oldDataFilePath = Paths.get(dataFilePath);

			// store new path
			closedFilePath = path + FILE_CLOSED_NAME;
			dataFilePath = path + FILE_DATA_NAME;
			fw.println(path);

			// migration of data files
			Path newClosedFilePath = Paths.get(closedFilePath);
			if (oldClosedFilePath.toFile().exists()) {
				Files.copy(oldClosedFilePath, newClosedFilePath, StandardCopyOption.REPLACE_EXISTING);
				Files.deleteIfExists(oldClosedFilePath);
			}

			Path newDataFilePath = Paths.get(dataFilePath);
			if (oldDataFilePath.toFile().exists()) {
				Files.copy(oldDataFilePath, newDataFilePath, StandardCopyOption.REPLACE_EXISTING);
				Files.deleteIfExists(oldDataFilePath);
			}

			fw.close();
			return true;
		}
	}

}
```
###### Tasker\src\application\storage\FloatingTask.java
``` java

package application.storage;

import java.util.Calendar;

public class FloatingTask extends Task implements Cloneable  {

	public FloatingTask() {
		setTaskDescription("");
		setLocation("");
		setRemindDate(Calendar.getInstance());
		setPriority("");
		setTaskIndex(-1);
	}
	
	public FloatingTask(String taskDescription, String location, Calendar remindDate, String priority, int taskIndex) {
		
		setTaskDescription(taskDescription);
		setLocation(location);
		setRemindDate(remindDate);
		setPriority(priority);
		setTaskIndex(taskIndex);
	}
		
	public Calendar getStartDate() {
		return null;
	}

	public Calendar getEndDate() {
		return null;
	}
	
	public Calendar getStartTime() {
		return null;
	}

	public Calendar getEndTime() {
		return null;
	}
	
	public String durationToString() {
		return "";
	}
	
	public String toString() {
		String message = "\"";
		message += getTaskDescription();
		
		if (!getLocation().equalsIgnoreCase("")) {
			message += " at " + getLocation();
		}
		
		message += "\"";
		
		return message;	
	}
	
    protected Object clone() throws CloneNotSupportedException {
    	FloatingTask newTask = (FloatingTask) super.clone();
    	newTask.remindDate = (Calendar) remindDate.clone();
    	return newTask;
    }

}
```
###### Tasker\src\application\storage\InvalidIndexException.java
``` java

package application.storage;

public class InvalidIndexException extends Exception {
	public InvalidIndexException (String message) {
		super(message);
	}
}
```
###### Tasker\src\application\storage\Storage.java
``` java

package application.storage;

import java.io.IOException;
import java.util.Calendar;
import java.util.ArrayList;

public class Storage implements Cloneable {

	private static final int UPDATED_CLOSE_LIST = 0;
	private static final int UPDATED_DATE_LIST = 1;
	private DatabaseManager databaseManager;
	private FileManager fileManager;
	private TaskManager taskManager;

	public Storage() {
		databaseManager = new DatabaseManager();
		fileManager = new FileManager();
		taskManager = new TaskManager();		
	}
```
###### Tasker\src\application\storage\Storage.java
``` java
	public Task deleteTask(int index) throws IOException {
		Task deletedTask = null;
		for (int i = 0; i<databaseManager.getOpenList().size(); i++) {
			if (databaseManager.getOpenList().get(i).getTaskIndex()==index) {
				deletedTask = databaseManager.getOpenList().get(i);
			}
		}
		
		databaseManager.updateOpenList(taskManager.delete(databaseManager.getOpenList(), index));
		saveFile();
		return deletedTask;
	}
	
	public boolean directoryExists() throws IOException {
		return fileManager.isDirectoryExists();
	}
	
	public ArrayList<Task> getOpenList() {
		databaseManager.updateOpenList(taskManager.sortDate(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}
	
	public ArrayList<Task> getCloseList() {
		databaseManager.updateCloseList(taskManager.sortDate(databaseManager.getCloseList()));
		return databaseManager.getCloseList();
	}
	
	public boolean initialise() throws IOException {
		fileManager.loadDirectoryFile();
		databaseManager.updateCloseList(fileManager.loadFile(fileManager.getClosedFilePath()));
		databaseManager.updateOpenList(fileManager.loadFile(fileManager.getDataFilePath()));
		databaseManager.setTaskIndex(fileManager.loadTaskIndex());
		return true;
	}
	
	private void saveFile() throws IOException {
		fileManager.clear(fileManager.getClosedFilePath());
		fileManager.saveTaskIndex(databaseManager.getTaskIndex());
		fileManager.saveFile(databaseManager.getCloseList(), fileManager.getClosedFilePath());
		fileManager.saveFile(databaseManager.getOpenList(), fileManager.getDataFilePath());
	}
	
	public ArrayList<Task> searchTaskByDate(Calendar date) {
		return taskManager.searchDateBy(databaseManager.getOpenList(), date);
	}
	
	public ArrayList<Task> searchTaskOnDate(Calendar date) {
		return taskManager.searchDateOn(databaseManager.getOpenList(), date);
	}
	
	public ArrayList<Task> searchTaskByName(String taskName) {
		return taskManager.searchName(databaseManager.getOpenList(), taskName);
	}
	
	public ArrayList<Task> searchTaskByPriority(String priority) {
		return taskManager.searchPriority(databaseManager.getOpenList(), priority);
	}
```
###### Tasker\src\application\storage\Storage.java
``` java
	public void setDirectory(String path) throws IOException {
		fileManager.setDirectory(path);
	}
	
	public ArrayList<Task> sortByDate() {
		databaseManager.updateOpenList(taskManager.sortDate(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}
	
	public ArrayList<Task> sortByName() {
		databaseManager.updateOpenList(taskManager.sortName(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}
	
	public ArrayList<Task> sortByPriority() {
		databaseManager.updateOpenList(taskManager.sortPriority(databaseManager.getOpenList()));
		return databaseManager.getOpenList();
	}
	
	public ArrayList<Task> updateTask(int index, String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate,
			String priority) throws IOException, CloneNotSupportedException {
		ArrayList<Task> list = new ArrayList<Task>();
		
		// add original/old task 
		int taskIndex = -1;
		for (int i = 0; i<databaseManager.getOpenList().size(); i++) {
			if (databaseManager.getOpenList().get(i).getTaskIndex()==index) {
				taskIndex = i;
				list.add(cloneObject(databaseManager.getOpenList().get(i)));
				break;
			}
		}
		
		// update task
		databaseManager.updateOpenList(taskManager.update(
				databaseManager.getOpenList(), taskDescription, startDate,
				endDate, location, remindDate, priority, index));
		list.add(databaseManager.getOpenList().get(taskIndex));
		
		saveFile();
		return list;
	}
	
	private Task cloneObject (Task obj) throws CloneNotSupportedException {
		if (obj instanceof FloatingTask) {
			return (FloatingTask) obj.clone();
		}
		else if (obj instanceof DeadlineTask) {
			return (DeadlineTask) obj.clone();
		} else {
			return (EventTask) obj.clone();
		}
	}
	
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```
###### Tasker\src\application\storage\StorageStub.java
``` java
	public boolean dateIsBeforeOrEqual(String scannedDate, String dateSearch) {
		return true;	
	}
	
	// isSearchBy - indicate if its searching <by> date (true), or searching <on> date (false)
	public void searchByDate(String dateSearch, boolean isSearchBy) {
		if (isSearchBy) {
			for (int i = 0; i < 3; i++) {
				if (dateIsBeforeOrEqual("dd/mm/yyyy", dateSearch)) {
					storeSearchResults();
				}
			}
		}
		else {
			for (int i = 0; i < 3; i++) {
				storeSearchResults();
			}
		}					
		showSearchResults();
	}

	// search the task with the index indicate (Task object) and update
	public void findTaskAndUpdate(int index) {
		System.out.println("Finding the task in the search list to update...");
		updateTaskInList();
	}

	// returns Logic a search results list to update using index
	public String getSearchResults() {
		return "A list of search results with index no";
	}
	// updates the task with the necessary details only
	public void updateTaskInList() {
		System.out.println("Updated the task..");
	}

	// search for all possible tasks via taskName
	public void searchByTask(String taskSearch) {
		for (int i = 0; i < 3; i++) {
				storeSearchResults();
		}
		showSearchResults();
	}

	// display total results found + return Logic a search list
	public String showSearchResults() {
		System.out.println("Search : <number> results found.");
		return "A list of search results with index no";
	}

	// store tasks into current search list
	public void storeSearchResults() {
		System.out.println("Storing task into search results...");
	}

	// returns Logic feedback on success/failure on add/update/delete etc
	public String showFeedback() {
		return "Feedback on success/failure from Storage returned to Logic";
	}

}
```
###### Tasker\src\application\storage\StorageTest.java
``` java

package application.storage;

import static org.junit.Assert.*;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class StorageTest {
	Storage storageController;
	static final String FILE_CLOSED_NAME = "TaskerDataHistory.txt";
	static final String FILE_DATA_NAME = "TaskerData.txt";
	static final String FILE_DIRECTORY_NAME = "TaskerDirectory.txt";
	static final String CUSTOM_DIRECTORY1 = "E:/Eclipse/workspace/";
	static final String CUSTOM_DIRECTORY2 = "E:/Eclipse/workspace/CS2103_Tasker/";
	static Calendar cal1 = Calendar.getInstance();
	static Calendar cal2 = Calendar.getInstance();
	static Calendar cal3 = Calendar.getInstance();
	static Calendar time1 = Calendar.getInstance();
	static Calendar noDate = Calendar.getInstance();
	static Calendar noTime = Calendar.getInstance();
    private static final int EMPTY = 1;
	
    @Before
	public void before() throws IOException {
		storageController = new Storage();
		if(!storageController.directoryExists())	
			storageController.setDirectory("");
		storageController.initialise();
		cal1.set(2020, Calendar.JUNE, 30);
		cal2.set(2030, Calendar.DECEMBER, 25);
		cal3.set(2040, Calendar.APRIL, 1);
		noDate.set(Calendar.YEAR, EMPTY);
		noTime.set(Calendar.MILLISECOND, EMPTY);
		noTime.set(Calendar.HOUR_OF_DAY, 0);
		noTime.set(Calendar.MINUTE, 0);
		noTime.set(Calendar.SECOND, 0);
		time1.set(Calendar.YEAR, EMPTY);
		time1.set(Calendar.HOUR_OF_DAY, 17);
		time1.set(Calendar.MINUTE, 17);
	}
	
//	@Test
	public void checkDirectory() throws IOException {
		assertFalse(storageController.directoryExists());	
	}
	
//	@Test
	public void checkInitialise() throws IOException {
		storageController.directoryExists();	
		storageController.setDirectory("");
		assertTrue(storageController.initialise());
	}
	
//	@Test
	public void setDirectory() throws IOException {
		storageController.addTaskInList("Go to hell", cal1, noDate, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", noDate, cal1, "Home", cal2, "low");
		System.out.println("Closed File Path is : "+storageController.fileManager.getClosedFilePath());
		System.out.println("Data File Path is : "+storageController.fileManager.getDataFilePath());
		storageController.setDirectory(CUSTOM_DIRECTORY1);
		System.out.println("Closed File Path is : "+storageController.fileManager.getClosedFilePath());
		System.out.println("Data File Path is : "+storageController.fileManager.getDataFilePath());
		storageController.setDirectory("");
		System.out.println("Closed File Path is : "+storageController.fileManager.getClosedFilePath());
		System.out.println("Data File Path is : "+storageController.fileManager.getDataFilePath());
		storageController.setDirectory(CUSTOM_DIRECTORY2);
		System.out.println("Closed File Path is : "+storageController.fileManager.getClosedFilePath());
		System.out.println("Data File Path is : "+storageController.fileManager.getDataFilePath());
		storageController.setDirectory("");
		System.out.println("Closed File Path is : "+storageController.fileManager.getClosedFilePath());
		System.out.println("Data File Path is : "+storageController.fileManager.getDataFilePath());
	}

//	@Test
	public void addTask() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		assertEquals("FloatingTask",storageController.getOpenList().get(0).getClass().getSimpleName());
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		assertEquals("DeadlineTask",storageController.getOpenList().get(1).getClass().getSimpleName());
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		assertEquals("EventTask",storageController.getOpenList().get(2).getClass().getSimpleName());
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		assertEquals("FloatingTask",storageController.getOpenList().get(3).getClass().getSimpleName());
	}
	
//	@Test
	public void closeTask() throws IOException {
		storageController.addTaskInList("Go to hell", cal1, cal2, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.closeTask(1);
	}
	
//	@Test
	public void deleteTask() throws IOException {
		storageController.addTaskInList("Go to hell", cal1, noDate, "Doom", noDate, "high");
		storageController.deleteTask(1);
	}
	
//	@Test
	public void searchName() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.searchTaskByName("home");
		for (int i = 0; i<searchList.size(); i++) {
			System.out.println("Found : "+searchList.get(i).toString());
		}
	}
	
//	@Test
	public void searchByDate() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar searchDate = Calendar.getInstance();
//		cal1.set(2020, Calendar.JUNE, 30);
//		cal2.set(2030, Calendar.DECEMBER, 25);
		searchDate.set(2020, Calendar.JUNE, 30);
		ArrayList<Task> searchList = storageController.searchTaskByDate(searchDate);
		for (int i = 0; i<searchList.size(); i++) {
			System.out.println("Found : "+searchList.get(i).toString());
		}
	}
	
//	@Test
	public void searchPriority() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.searchTaskByPriority("low");
		assertTrue(searchList.get(0) == storageController.databaseManager.getOpenList().get(1));
		assertTrue(searchList.get(1) == storageController.databaseManager.getOpenList().get(3));		
		for (int i = 0; i<searchList.size(); i++) {
			System.out.println("Found : "+searchList.get(i).toString());
		}
	}
	
//	@Test
	public void sortName() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.sortByName();
		for (int i = 0; i<searchList.size(); i++) {
			System.out.println(i+") " +searchList.get(i).toString());
		}
	}
	
//	@Test
	public void sortDate() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		ArrayList<Task> searchList = storageController.sortByDate();
		for (int i = 0; i<searchList.size(); i++) {
			System.out.println(i+") " +searchList.get(i).toString());
		}
	}
	
//	@Test
	public void sortPriority() throws IOException {
//		storageController.addTaskInList("Go to hell", cal1, noDate, "Doom", noDate, "high");
//		storageController.addTaskInList("Do homework", noDate, cal1, "Home", cal2, "low");
//		storageController.addTaskInList("Finish CS2103", noDate, noDate, "School", noDate, "high");
//		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		ArrayList<Task> searchList = storageController.sortByPriority();
		for (int i = 0; i<searchList.size(); i++) {
			System.out.println(i+") " +searchList.get(i).toString());
		}
	}
	
//	@Test
	public void updateTask() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "Finish CS2103 and CS3230", noDate, newDate, "Home", noDate, "highest");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test
	public void addAndSetDirectoryAndAdd() throws IOException {
//		System.out.println("Closed File Path is : "+storageController.fileManager.getClosedFilePath());
//		System.out.println("Data File Path is : "+storageController.fileManager.getDataFilePath());
//		storageController.addTaskInList("Go to hell", cal1, noDate, "Doom", noDate, "high");
//		storageController.addTaskInList("Do homework", noDate, cal1, "Home", cal2, "low");
		
		storageController.setDirectory(CUSTOM_DIRECTORY1);
		System.out.println("Closed File Path is : "+storageController.fileManager.getClosedFilePath());
		System.out.println("Data File Path is : "+storageController.fileManager.getDataFilePath());
		storageController.addTaskInList("Finish CS2103", noDate, noDate, "School", noDate, "high");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
	}

//	@Test
	public void updateTaskWithTime() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "", noDate, time1, "Home", noDate, "highest");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test
	public void searchOnDate() throws IOException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar searchDate = Calendar.getInstance();
		searchDate.set(2030, Calendar.DECEMBER, 25);
//		cal1.set(2020, Calendar.JUNE, 30);
//		cal2.set(2030, Calendar.DECEMBER, 25);
		ArrayList<Task> searchList = storageController.searchTaskOnDate(cal1);
		for (int i = 0; i<searchList.size(); i++) {
			System.out.println("Found : "+searchList.get(i).toString());
		}
	}
	
//	@Test
	public void testString() {
		Task task = new Task();
		Calendar date = Calendar.getInstance();
		date.set(2030, Calendar.DECEMBER, 25);
		task.setStartDate(noDate);
		task.setEndDate(date);
		task.setRemindDate(noDate);
		task.setStartTime(time1);
		task.setEndTime(time1);
		task.setRemindTime(noTime);
		System.out.println("Start Date : "+task.dateToString(task.getStartDate()));
		System.out.println("End Date : "+task.dateToString(task.getEndDate()));
		System.out.println("Remind Date : "+task.dateToString(task.getRemindDate()));
		System.out.println("Start time : "+task.timeToString(task.getStartDate()));
		System.out.println("End time : "+task.timeToString(task.getEndDate()));
		System.out.println("Remind time : "+task.timeToString(task.getRemindDate()));
		System.out.println("Duration : "+task.durationToString());
	}
	
//	@Test 
	public void checkCloseList() throws IOException {
		ArrayList<Task> list = storageController.getCloseList();
		for (int i = 0; i<list.size(); i++) {
			System.out.println(list.get(i).toString());
		}
	}
	
//	@Test	// event task ---> deadline task
	public void updateTaskType1() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "", null, cal1, "School", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test	// event task ---> floating task
	public void updateTaskType2() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "Fucking CS2103", null, null, "School", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test	// event task ---> event task
	public void updateTaskType3() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(3, "", cal2, cal3, "School", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test // floating task ---> event task
	public void updateTaskType4() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(1, "", cal1, cal2, "Hell", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test // floating task ---> deadline task
	public void updateTaskType5() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(1, "", null, cal2, "Heaven", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test // floating task ---> floating task
	public void updateTaskType6() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(1, "", null, null, "LT33", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test // deadline task ---> event task	
	public void updateTaskType7() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(2, "", cal1, cal2, "Hell", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test // deadline task --> floating task
	public void updateTaskType8() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(2, "", null, null, "Hell", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@Test // deadline task ---> deadline task
	public void updateTaskType9() throws IOException, CloneNotSupportedException {
		storageController.addTaskInList("Go to hell", null, null, "Doom", noDate, "high");
		storageController.addTaskInList("Do homework", null, cal1, "Home", cal2, "low");
		storageController.addTaskInList("Sign up for homework", cal1, cal2, "Home", noDate, "low");
		storageController.addTaskInList("Finish CS2103", null, null, "School", noDate, "high");
		Calendar newDate = Calendar.getInstance();
		newDate.set(2035, Calendar.JUNE, 30);
		ArrayList<Task> list = new ArrayList<Task>();
		list = storageController.updateTask(2, "", null, cal3, "Hell", noDate, "high");
		System.out.println(list.size());
		System.out.println("Old : "+list.get(0).toString());
		System.out.println("New : "+list.get(1).toString());
	}
	
//	@After
	public void after() {
		File a = new File(FILE_DIRECTORY_NAME);
		File b = new File(FILE_CLOSED_NAME);
		File c = new File(FILE_DATA_NAME);
		a.delete();
		b.delete();
		c.delete();
	}

}
```
###### Tasker\src\application\storage\Task.java
``` java

package application.storage;

import java.text.SimpleDateFormat;
import java.util.Calendar;

public abstract class Task implements Cloneable {

	private String taskDescription;
	private String location;
	protected Calendar remindDate;
	private String priority;
	private int taskIndex;
	private static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("d MMM yyyy");
	private static final SimpleDateFormat FORMAT_TIME = new SimpleDateFormat("h:mm a");
    private static final int EMPTY = 1;
    private static final String EMPTY_STRING = "";
    
	public Task() {
		taskDescription = "";
		location = "";
		remindDate = Calendar.getInstance();
		priority = "";
		taskIndex = -1;
	}
	
	public Task(String taskDescription, Calendar startDate,
			Calendar endDate, String location, Calendar remindDate,
			String priority, int taskIndex) {
		this.taskDescription = taskDescription;
		this.location = location;
		this.remindDate = remindDate;
		this.priority = priority;
		this.taskIndex = taskIndex;
	}

	public void setTaskDescription(String taskDescription) {
		this.taskDescription = taskDescription;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public void setRemindDate(Calendar remindDate) {
		this.remindDate.set(remindDate.get(Calendar.YEAR), remindDate.get(Calendar.MONTH), remindDate.get(Calendar.DATE));
	}
	
	public void setRemindTime(Calendar remindTime) {
		this.remindDate.set(Calendar.HOUR_OF_DAY, remindTime.get(Calendar.HOUR_OF_DAY));
		this.remindDate.set(Calendar.MINUTE, remindTime.get(Calendar.MINUTE));
		this.remindDate.set(Calendar.SECOND, remindTime.get(Calendar.SECOND));
		this.remindDate.set(Calendar.MILLISECOND, remindTime.get(Calendar.MILLISECOND));
	}

	public void setPriority(String priority) {
		this.priority = priority;
	}

	public void setTaskIndex(int taskIndex) {
		this.taskIndex = taskIndex;
	}

	public String getTaskDescription() {
		return taskDescription;
	}
	
	public int getTaskIndex() {
		return taskIndex;
	}

	public String getLocation() {
		return location;
	}

	public Calendar getRemindDate() {
		return remindDate;
	}
	
	public Calendar getRemindTime() {
		return remindDate;
	}

	public String getPriority() {
		return priority;
	}
	
	public String dateToString(Calendar date) {
		if (date.get(Calendar.YEAR)!=EMPTY) {
			return FORMAT_DATE.format(date.getTime());
		} else {
			return EMPTY_STRING;
		}
	}
	
	public String timeToString(Calendar date) {
		if (!((date.get(Calendar.MILLISECOND)==EMPTY) && (date.get(Calendar.HOUR_OF_DAY)==0) && (date.get(Calendar.MINUTE)==0) && (date.get(Calendar.SECOND)==0))) {
			return FORMAT_TIME.format(date.getTime());
		} else {
			return EMPTY_STRING;
		}

	}

```
###### Tasker\src\application\storage\Task.java
``` java
	public abstract Calendar getStartDate();
	
	public abstract Calendar getEndDate();
	
	public abstract String durationToString();
    
	protected Object clone() throws CloneNotSupportedException {
    	Task newTask = (Task) super.clone();
    	newTask.remindDate = (Calendar) remindDate.clone();
    	return newTask;
    }
	
}
```
###### Tasker\src\application\storage\TaskManager.java
``` java

package application.storage;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;

public class TaskManager {
    private static final int EMPTY = 1;
	private static final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("dd-MM-yyyy");
```
###### Tasker\src\application\storage\TaskManager.java
``` java
	public ArrayList<Task> delete(ArrayList<Task> openList, int taskIndex) {
		for (int i = 0; i < openList.size(); i++) {
			if (openList.get(i).getTaskIndex() == taskIndex) {
				openList.remove(i);
				break;
			}
		}
		return openList;
	}
	
	public ArrayList<Task> searchName(ArrayList<Task> openList, String searchTask) {
		String[] splitArray = searchTask.split("\\s+");
		ArrayList<Task> searchList = new ArrayList<Task>();
		for (int i = 0; i < openList.size(); i++) {
			Task obj = openList.get(i);
			for (int k = 0; k<splitArray.length; k++) {
				if (obj.getTaskDescription().toLowerCase().contains(splitArray[k].toLowerCase())) {
					searchList.add(obj);
					break;
				}
			}
		}
		return searchList;
	}
	
	public ArrayList<Task> searchDateBy(ArrayList<Task> openList, Calendar searchDate) {
		ArrayList<Task> searchList = new ArrayList<Task>();
		for (int i = 0; i < openList.size(); i++) {
			Task obj = openList.get(i);
			if (obj instanceof DeadlineTask) {
				if (((DeadlineTask) obj).getEndTime().get(Calendar.YEAR) != EMPTY) {
					if (((DeadlineTask) obj).getEndDate().compareTo(searchDate) <= 0) {
						searchList.add(obj);
					}
				}
			} else if (obj instanceof EventTask) {
				if (((EventTask) obj).getEndTime().get(Calendar.YEAR) != EMPTY) {
					if (((EventTask) obj).getEndDate().compareTo(searchDate) <= 0) {
						searchList.add(obj);
					}
				}
			}
		}
		return searchList;
	}
	
	public ArrayList<Task> searchDateOn(ArrayList<Task> openList, Calendar searchDate) {
		ArrayList<Task> searchList = new ArrayList<Task>();
		for (int i = 0; i < openList.size(); i++) {
			Task obj = openList.get(i);
			// check if deadline task --> check end date only
			if (obj instanceof DeadlineTask) {
				if (((DeadlineTask) obj).getEndDate().get(Calendar.YEAR) != EMPTY) {
					if (((DeadlineTask) obj).getEndDate().get(Calendar.YEAR) == searchDate.get(Calendar.YEAR)
							&& ((DeadlineTask) obj).getEndDate().get(Calendar.MONTH) == searchDate.get(Calendar.MONTH)
							&& ((DeadlineTask) obj).getEndDate().get(Calendar.DATE) == searchDate.get(Calendar.DATE)) {
						searchList.add(obj);
						continue;
					}
				}
				// check if event task --> check start/end date 
			} else if (obj instanceof EventTask) {
				if (((EventTask) obj).getStartDate().get(Calendar.YEAR) != EMPTY) {
					if (((EventTask) obj).getStartDate().get(Calendar.YEAR) == searchDate.get(Calendar.YEAR)
							&& ((EventTask) obj).getStartDate().get(Calendar.MONTH) == searchDate.get(Calendar.MONTH)
							&& ((EventTask) obj).getStartDate().get(Calendar.DATE) == searchDate.get(Calendar.DATE)) {
						searchList.add(obj);
						continue;
					}
				}
				if (((EventTask) obj).getEndDate().get(Calendar.YEAR) != EMPTY) {
					if (((EventTask) obj).getEndDate().get(Calendar.YEAR) == searchDate.get(Calendar.YEAR)
							&& ((EventTask) obj).getEndDate().get(Calendar.MONTH) == searchDate.get(Calendar.MONTH)
							&& ((EventTask) obj).getEndDate().get(Calendar.DATE) == searchDate.get(Calendar.DATE)) {
						searchList.add(obj);
						continue;
					}

				}

			}
		}
		return searchList;
	}
```
###### Tasker\src\application\storage\TaskManager.java
``` java
	public ArrayList<Task> sortDate(ArrayList<Task> openList) {
		Collections.sort(openList, new ComparatorDate());
		return openList;
	}
	
	public ArrayList<Task> sortName(ArrayList<Task> openList) {
		Collections.sort(openList, (o1, o2) -> o1.getTaskDescription().compareTo(o2.getTaskDescription()));
		return openList;
	}
	
	public ArrayList<Task> sortPriority(ArrayList<Task> openList) {
		Collections.sort(openList, new ComparatorPriority());
		return openList;
	}
	
	public ArrayList<Task> update(ArrayList<Task> openList,
			String taskDescription, Calendar startDate, Calendar endDate,
			String location, Calendar remindDate, String priority, int taskIndex) {
		int index = 0;	
		
		// find task
		for (int i = 0; i < openList.size(); i++) {
			if (openList.get(i).getTaskIndex() == taskIndex) {
				index = i;
				break;
			}
		}
		
		// update task
		if (openList.get(index) instanceof FloatingTask) {
			// convert : floating task to event task
			if (startDate!=null && endDate!=null && startDate.get(Calendar.YEAR)!=EMPTY && endDate.get(Calendar.YEAR)!=EMPTY) {
				openList.set(index, updateToEventTask(openList.get(index), taskDescription, startDate, endDate, location, remindDate, priority, taskIndex));
			}
			// convert : floating task to deadline task	
			else if (startDate==null && endDate!=null) {
				openList.set(index, updateToDeadlineTask(openList.get(index), taskDescription, endDate, location, remindDate, priority, taskIndex));
			}
			// no conversion
			else {
				openList.set(index, updateToFloatingTask(openList.get(index), taskDescription, location, remindDate, priority, taskIndex));
			}
			

		}
		
		else if (openList.get(index) instanceof DeadlineTask) {
			// convert : deadline task to event task
			if (startDate!=null && endDate!=null && startDate.get(Calendar.YEAR)!=EMPTY && endDate.get(Calendar.YEAR)!=EMPTY) {
				openList.set(index, updateToEventTask(openList.get(index), taskDescription, startDate, endDate, location, remindDate, priority, taskIndex));
			}
			// convert : deadline task to floating task
			else if (startDate==null && endDate==null) {
				openList.set(index, updateToFloatingTask(openList.get(index), taskDescription, location, remindDate, priority, taskIndex));
			}
			// no conversion
			else {
				openList.set(index, updateToDeadlineTask(openList.get(index), taskDescription, endDate, location,
						remindDate, priority, taskIndex));
			}
		}
		
		else if (openList.get(index) instanceof EventTask) {
			// convert : event task to deadline task
			if (startDate==null && endDate!=null) {
				openList.set(index, updateToDeadlineTask(openList.get(index), taskDescription, endDate, location, remindDate, priority, taskIndex));
				}
			// convert : event task to floating task
			else if (startDate==null && endDate==null) {
				openList.set(index, updateToFloatingTask(openList.get(index), taskDescription, location, remindDate, priority, taskIndex));
			}
			// no conversion
			else {
				openList.set(index, updateToEventTask(openList.get(index), taskDescription, startDate, endDate, location, remindDate, priority, taskIndex));
			}
		}
		// return updated list
		return openList;
	}
		
	private EventTask updateToEventTask(Task originalTask,
			String taskDescription, Calendar startDate, Calendar endDate,
			String location, Calendar remindDate, String priority, int taskIndex) {
		
		EventTask eventTask;
		if (originalTask instanceof FloatingTask) {
			eventTask = new EventTask(originalTask.getTaskDescription(), Calendar.getInstance(), Calendar.getInstance(), originalTask.getLocation(), originalTask.getRemindDate(), originalTask.getPriority(), originalTask.getTaskIndex());
		}
		else if (originalTask instanceof DeadlineTask) {
			eventTask = new EventTask(originalTask.getTaskDescription(), Calendar.getInstance(), ((DeadlineTask) originalTask).getEndDate(), originalTask.getLocation(), originalTask.getRemindDate(), originalTask.getPriority(), originalTask.getTaskIndex());
		}
		else {
			eventTask = new EventTask(originalTask.getTaskDescription(), ((EventTask) originalTask).getStartDate(), ((EventTask) originalTask).getEndDate(), originalTask.getLocation(), originalTask.getRemindDate(), originalTask.getPriority(), originalTask.getTaskIndex());
		}
				
		// update task
		if (!taskDescription.equalsIgnoreCase("")) {
			eventTask.setTaskDescription(taskDescription);
		}
		if (startDate.get(Calendar.YEAR)!=EMPTY) {
			eventTask.setStartDate(startDate);
		}
		if (!(startDate.get(Calendar.MILLISECOND)==EMPTY && startDate.get(Calendar.HOUR_OF_DAY)==0 && startDate.get(Calendar.MINUTE)==0 && startDate.get(Calendar.SECOND)==0)) {
			eventTask.setStartTime(startDate);
		}
		if (endDate.get(Calendar.YEAR)!=EMPTY) {
			eventTask.setEndDate(endDate);
			eventTask.setEndTime(endDate);
//			eventTask.setStartDate(startDate);
//			eventTask.setStartTime(startDate);
		}
		if (!(endDate.get(Calendar.MILLISECOND)==EMPTY && endDate.get(Calendar.HOUR_OF_DAY)==0 && endDate.get(Calendar.MINUTE)==0 && endDate.get(Calendar.SECOND)==0)) {
			eventTask.setEndTime(endDate);
			eventTask.setStartTime(startDate);
		}
		if (!location.equalsIgnoreCase("")) {
			eventTask.setLocation(location);
		}
		if (remindDate.get(Calendar.YEAR)!=EMPTY) {
			eventTask.setRemindDate(remindDate);
		}
		if (!(remindDate.get(Calendar.MILLISECOND)==EMPTY && remindDate.get(Calendar.HOUR_OF_DAY)==0 && remindDate.get(Calendar.MINUTE)==0 && remindDate.get(Calendar.SECOND)==0)) {
			eventTask.setRemindDate(remindDate);
		}
		if (!priority.equalsIgnoreCase("")) {
			eventTask.setPriority(priority);
		}
		
		return eventTask;
	}
	
	private FloatingTask updateToFloatingTask(Task originalTask, String taskDescription, String location, Calendar remindDate, String priority,
			int taskIndex) {
		
		FloatingTask floatingTask = new FloatingTask(originalTask.getTaskDescription(), originalTask.getLocation(), originalTask.getRemindDate(), originalTask.getPriority(), originalTask.getTaskIndex());
	
		// update task
		if (!taskDescription.equalsIgnoreCase("")) {
			floatingTask.setTaskDescription(taskDescription);
		}

		if (!location.equalsIgnoreCase("")) {
			floatingTask.setLocation(location);
		}
		if (remindDate.get(Calendar.YEAR)!=EMPTY) {
			floatingTask.setRemindDate(remindDate);
		}
		if (!(remindDate.get(Calendar.MILLISECOND)==EMPTY && remindDate.get(Calendar.HOUR_OF_DAY)==0 && remindDate.get(Calendar.MINUTE)==0 && remindDate.get(Calendar.SECOND)==0)) {
			floatingTask.setRemindDate(remindDate);
		}
		if (!priority.equalsIgnoreCase("")) {
			floatingTask.setPriority(priority);
		}
		
		return floatingTask;
	}

	private DeadlineTask updateToDeadlineTask(Task originalTask, String taskDescription, Calendar endDate, String location,
			Calendar remindDate, String priority, int taskIndex) {
		
		DeadlineTask deadlineTask;
		if (originalTask instanceof EventTask) {
			deadlineTask = new DeadlineTask(originalTask.getTaskDescription(), ((EventTask) originalTask).getEndDate(), originalTask.getLocation(), originalTask.getRemindDate(), originalTask.getPriority(), originalTask.getTaskIndex());
		}
		else if (originalTask instanceof FloatingTask) {
			deadlineTask = new DeadlineTask(originalTask.getTaskDescription(), Calendar.getInstance(), originalTask.getLocation(), originalTask.getRemindDate(), originalTask.getPriority(), originalTask.getTaskIndex());
		}
		else {
			deadlineTask = new DeadlineTask(originalTask.getTaskDescription(), ((DeadlineTask) originalTask).getEndDate(), originalTask.getLocation(), originalTask.getRemindDate(), originalTask.getPriority(), originalTask.getTaskIndex());
		}
		// update task
		if (!taskDescription.equalsIgnoreCase("")) {
			deadlineTask.setTaskDescription(taskDescription);
		}

		if (endDate.get(Calendar.YEAR)!=EMPTY) {
			deadlineTask.setEndDate(endDate);
			deadlineTask.setEndTime(endDate);
		}
		if (!(endDate.get(Calendar.MILLISECOND)==EMPTY && endDate.get(Calendar.HOUR_OF_DAY)==0 && endDate.get(Calendar.MINUTE)==0 && endDate.get(Calendar.SECOND)==0)) {
			deadlineTask.setEndTime(endDate);
		}
		if (!location.equalsIgnoreCase("")) {
			deadlineTask.setLocation(location);
		}
		if (remindDate.get(Calendar.YEAR)!=EMPTY) {
			deadlineTask.setRemindDate(remindDate);
		}
		if (!(remindDate.get(Calendar.MILLISECOND)==EMPTY && remindDate.get(Calendar.HOUR_OF_DAY)==0 && remindDate.get(Calendar.MINUTE)==0 && remindDate.get(Calendar.SECOND)==0)) {
			deadlineTask.setRemindDate(remindDate);
		}
		if (!priority.equalsIgnoreCase("")) {
			deadlineTask.setPriority(priority);
		}
		
		return deadlineTask;
	}

```
###### Tasker\src\application\storage\TaskManager.java
``` java
}

class ComparatorPriority implements Comparator<Task> {
    @Override
    public int compare(Task o1, Task o2) {
    	int ob1=0,ob2=0;
    	if (o1.getPriority().equals(""))
    		ob1 = 4;
    	if (o1.getPriority().equalsIgnoreCase("low"))
    		ob1 = 3;
    	if (o1.getPriority().equalsIgnoreCase("medium"))
    		ob1 = 2;
    	if (o1.getPriority().equalsIgnoreCase("high"))
    		ob1 = 1;
    	if (o2.getPriority().equalsIgnoreCase(""))
    		ob2 = 4;
    	if (o2.getPriority().equalsIgnoreCase("low"))
    		ob2 = 3;
    	if (o2.getPriority().equalsIgnoreCase("medium"))
    		ob2 = 2;
    	if (o2.getPriority().equalsIgnoreCase("high"))
    		ob2 = 1;
    	
    	// nothing = 4, low = 3, medium = 2, high = 1
        return Integer.compare(ob1,ob2);
    }
}

class ComparatorDate implements Comparator<Task> {
    @Override
    public int compare(Task o1, Task o2) {
    	if (o1 instanceof DeadlineTask && o2 instanceof DeadlineTask) {
    		return ((DeadlineTask) o1).getEndTime().compareTo(((DeadlineTask) o2).getEndTime());
    	} else if (o1 instanceof DeadlineTask && o2 instanceof EventTask) {
    		return ((DeadlineTask) o1).getEndTime().compareTo(((EventTask) o2).getEndTime());
    	} else if (o1 instanceof DeadlineTask && o2 instanceof FloatingTask) {
    		return -1;
    	} else if (o1 instanceof EventTask && o2 instanceof DeadlineTask) {
    		return ((EventTask) o1).getEndTime().compareTo(((DeadlineTask) o2).getEndTime());
    	} else if (o1 instanceof EventTask && o2 instanceof EventTask) {
    		return ((EventTask) o1).getEndTime().compareTo(((EventTask) o2).getEndTime());
    	} else if (o1 instanceof EventTask && o2 instanceof FloatingTask) {
    		return -1;
    	} else if (o1 instanceof FloatingTask && o2 instanceof DeadlineTask) {
    		return 1;
    	} else if (o1 instanceof FloatingTask && o2 instanceof EventTask) {
    		return 1;
    	} else {
    		return 0;
    	}
    	
    }    
}
```
###### Tasker\src\application\storage\TaskSerializer.java
``` java

package application.storage;

import java.lang.reflect.Type;
import java.util.Calendar;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class TaskSerializer implements JsonSerializer<Task>, JsonDeserializer<Task>{

	private static final String TASKTYPE = "taskType";

	@Override
	public JsonElement serialize(Task src, Type typeOfSrc,	JsonSerializationContext context) {

		JsonObject object = new JsonObject();
	    String className = src.getClass().getSimpleName();
	    object.addProperty("taskType", className);
	    if (src instanceof FloatingTask) {
	        object.addProperty("taskDescription", src.getTaskDescription());
	        object.addProperty("location", src.getLocation());
	        JsonElement remindDate = context.serialize(src.getRemindDate());
	        object.add("remindDate", remindDate);
	        long remindMilliseconds = src.getRemindDate().get(Calendar.MILLISECOND);
	        object.addProperty("remind-Date-milliseconds", remindMilliseconds);
	        object.addProperty("priority", src.getPriority());	        
	        object.addProperty("taskIndex", src.getTaskIndex());
		    return object;
	    }
	    else if (src instanceof DeadlineTask) {
	        object.addProperty("taskDescription", src.getTaskDescription());
	        JsonElement endDate = context.serialize(((DeadlineTask) src).getEndDate());
	        object.add("endDate", endDate);
	        long endMilliseconds = ((DeadlineTask) src).getEndDate().get(Calendar.MILLISECOND);
	        object.addProperty("end-Date-milliseconds", endMilliseconds);
	        object.addProperty("location", src.getLocation());
	        JsonElement remindDate = context.serialize(src.getRemindDate());
	        object.add("remindDate", remindDate);
	        long remindMilliseconds = src.getRemindDate().get(Calendar.MILLISECOND);
	        object.addProperty("remind-Date-milliseconds", remindMilliseconds);
	        object.addProperty("priority", src.getPriority());	        
	        object.addProperty("taskIndex", src.getTaskIndex());
		    return object;
	    }
	    else if (src instanceof EventTask) {
	        object.addProperty("taskDescription", src.getTaskDescription());
	        JsonElement startDate = context.serialize(((EventTask) src).getStartDate());
	        object.add("startDate", startDate);
	        long startMilliseconds = ((EventTask) src).getStartDate().get(Calendar.MILLISECOND);
	        object.addProperty("start-Date-milliseconds", startMilliseconds);    
	        JsonElement endDate = context.serialize(((EventTask) src).getEndDate());
	        object.add("endDate", endDate);
	        long endMilliseconds = ((EventTask) src).getEndDate().get(Calendar.MILLISECOND);
	        object.addProperty("end-Date-milliseconds", endMilliseconds);
	        object.addProperty("location", src.getLocation());
	        JsonElement remindDate = context.serialize(src.getRemindDate());
	        object.add("remindDate", remindDate);
	        long remindMilliseconds = src.getRemindDate().get(Calendar.MILLISECOND);
	        object.addProperty("remind-Date-milliseconds", remindMilliseconds);
	        object.addProperty("priority", src.getPriority());	        
	        object.addProperty("taskIndex", src.getTaskIndex());
		    return object;
	    }
	    return object;
	}
	
	@Override
	public Task deserialize(JsonElement json, Type typeOfT,  JsonDeserializationContext context) throws JsonParseException {

		JsonObject object = json.getAsJsonObject();
		String className = object.get(TASKTYPE).getAsString();
		String taskDescript = object.get("taskDescription").getAsString();
		String location = object.get("location").getAsString();
		String priority = object.get("priority").getAsString();		
		int taskIndex = object.get("taskIndex").getAsInt();
		Calendar remindDate = context.deserialize(object.get("remindDate"), Calendar.class);
		remindDate.set(Calendar.MILLISECOND, object.get("remind-Date-milliseconds").getAsInt());
		
	    if (className.equalsIgnoreCase(FloatingTask.class.getSimpleName())) {
	    	FloatingTask floatingTask = new FloatingTask(taskDescript, location, remindDate, priority, taskIndex);			
	        return floatingTask;	
	    }
	    else if (className.equalsIgnoreCase(DeadlineTask.class.getSimpleName())) {
			Calendar endDate = context.deserialize(object.get("endDate"), Calendar.class);
			endDate.set(Calendar.MILLISECOND, object.get("end-Date-milliseconds").getAsInt());
			DeadlineTask deadlineTask = new DeadlineTask(taskDescript, endDate, location, remindDate, priority, taskIndex);			
	        return deadlineTask;
	    }
	    else {
			Calendar startDate = context.deserialize(object.get("startDate"), Calendar.class);
			startDate.set(Calendar.MILLISECOND, object.get("start-Date-milliseconds").getAsInt());		
			Calendar endDate = context.deserialize(object.get("endDate"), Calendar.class);
			endDate.set(Calendar.MILLISECOND, object.get("end-Date-milliseconds").getAsInt());
			EventTask eventTask = new EventTask(taskDescript, startDate, endDate, location, remindDate, priority, taskIndex);			
	        return eventTask;
	    }		
	}

}
```
